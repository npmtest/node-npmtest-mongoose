{"/home/travis/build/npmtest/node-npmtest-mongoose/test.js":"/* istanbul instrument in package npmtest_mongoose */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mongoose/lib.npmtest_mongoose.js":"/* istanbul instrument in package npmtest_mongoose */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_mongoose = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_mongoose = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-mongoose/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-mongoose && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_mongoose */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_mongoose\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_mongoose.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_mongoose.rollup.js'] =\n            local.assetsDict['/assets.npmtest_mongoose.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_mongoose.__dirname +\n                    '/lib.npmtest_mongoose.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/index.js":"\n/**\n * Export lib/mongoose\n *\n */\n\nmodule.exports = require('./lib/');\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/index.js":"'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar Schema = require('./schema'),\n    SchemaType = require('./schematype'),\n    VirtualType = require('./virtualtype'),\n    STATES = require('./connectionstate'),\n    Types = require('./types'),\n    Query = require('./query'),\n    Model = require('./model'),\n    Document = require('./document'),\n    utils = require('./utils'),\n    format = utils.toCollectionName,\n    pkg = require('../package.json');\n\nvar querystring = require('querystring');\n\nvar Aggregate = require('./aggregate');\nvar PromiseProvider = require('./promise_provider');\n\n/**\n * Mongoose constructor.\n *\n * The exports object of the `mongoose` module is an instance of this class.\n * Most apps will only use this one instance.\n *\n * @api public\n */\n\nfunction Mongoose() {\n  this.connections = [];\n  this.plugins = [];\n  this.models = {};\n  this.modelSchemas = {};\n  // default global options\n  this.options = {\n    pluralization: true\n  };\n  var conn = this.createConnection(); // default connection\n  conn.models = this.models;\n}\n\n/**\n * Expose connection states for user-land\n *\n */\nMongoose.prototype.STATES = STATES;\n\n/**\n * Sets mongoose options\n *\n * ####Example:\n *\n *     mongoose.set('test', value) // sets the 'test' option to `value`\n *\n *     mongoose.set('debug', true) // enable logging collection methods + arguments to the console\n *\n *     mongoose.set('debug', function(collectionName, methodName, arg1, arg2...) {}); // use custom function to log collection methods + arguments\n *\n * @param {String} key\n * @param {String|Function} value\n * @api public\n */\n\nMongoose.prototype.set = function(key, value) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  this.options[key] = value;\n  return this;\n};\nMongoose.prototype.set.$hasSideEffects = true;\n\n/**\n * Gets mongoose options\n *\n * ####Example:\n *\n *     mongoose.get('test') // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nMongoose.prototype.get = Mongoose.prototype.set;\n\n/*!\n * ReplSet connection string check.\n */\n\nvar rgxReplSet = /^.+,.+$/;\n\n/**\n * Checks if ?replicaSet query parameter is specified in URI\n *\n * ####Example:\n *\n *     checkReplicaSetInUri('localhost:27000?replicaSet=rs0'); // true\n *\n * @param {String} uri\n * @return {boolean}\n * @api private\n */\n\nvar checkReplicaSetInUri = function(uri) {\n  if (!uri) {\n    return false;\n  }\n\n  var queryStringStart = uri.indexOf('?');\n  var isReplicaSet = false;\n  if (queryStringStart !== -1) {\n    try {\n      var obj = querystring.parse(uri.substr(queryStringStart + 1));\n      if (obj && obj.replicaSet) {\n        isReplicaSet = true;\n      }\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return isReplicaSet;\n};\n\n/**\n * Creates a Connection instance.\n *\n * Each `connection` instance maps to a single database. This method is helpful when mangaging multiple db connections.\n *\n * If arguments are passed, they are proxied to either [Connection#open](#connection_Connection-open) or [Connection#openSet](#connection_Connection-openSet) appropriately. This means we can pass `db`, `server`, and `replset` options to the driver. _Note that the `safe` option specified in your schema will overwrite the `safe` db option specified here unless you set your schemas `safe` option to `undefined`. See [this](/docs/guide.html#safe) for more information._\n *\n * _Options passed take precedence over options included in connection strings._\n *\n * ####Example:\n *\n *     // with mongodb:// URI\n *     db = mongoose.createConnection('mongodb://user:pass@localhost:port/database');\n *\n *     // and options\n *     var opts = { db: { native_parser: true }}\n *     db = mongoose.createConnection('mongodb://user:pass@localhost:port/database', opts);\n *\n *     // replica sets\n *     db = mongoose.createConnection('mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/database');\n *\n *     // and options\n *     var opts = { replset: { strategy: 'ping', rs_name: 'testSet' }}\n *     db = mongoose.createConnection('mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/database', opts);\n *\n *     // with [host, database_name[, port] signature\n *     db = mongoose.createConnection('localhost', 'database', port)\n *\n *     // and options\n *     var opts = { server: { auto_reconnect: false }, user: 'username', pass: 'mypassword' }\n *     db = mongoose.createConnection('localhost', 'database', port, opts)\n *\n *     // initialize now, connect later\n *     db = mongoose.createConnection();\n *     db.open('localhost', 'database', port, [opts]);\n *\n * @param {String} [uri] a mongodb:// URI\n * @param {Object} [options] options to pass to the driver\n * @param {Object} [options.config] mongoose-specific options\n * @param {Boolean} [options.config.autoIndex] set to false to disable automatic index creation for all models associated with this connection.\n * @see Connection#open #connection_Connection-open\n * @see Connection#openSet #connection_Connection-openSet\n * @return {Connection} the created Connection object\n * @api public\n */\n\nMongoose.prototype.createConnection = function(uri, options) {\n  var conn = new Connection(this);\n  this.connections.push(conn);\n\n  var rsOption = options && (options.replset || options.replSet);\n  if (arguments.length) {\n    if (rgxReplSet.test(arguments[0]) || checkReplicaSetInUri(arguments[0])) {\n      conn.openSet.apply(conn, arguments).catch(function() {});\n    } else if (rsOption &&\n        (rsOption.replicaSet || rsOption.rs_name)) {\n      conn.openSet.apply(conn, arguments).catch(function() {});\n    } else {\n      conn.open.apply(conn, arguments).catch(function() {});\n    }\n  }\n\n  return conn;\n};\nMongoose.prototype.createConnection.$hasSideEffects = true;\n\n/**\n * Opens the default mongoose connection.\n *\n * If arguments are passed, they are proxied to either\n * [Connection#open](#connection_Connection-open) or\n * [Connection#openSet](#connection_Connection-openSet) appropriately.\n *\n * _Options passed take precedence over options included in connection strings._\n *\n * ####Example:\n *\n *     mongoose.connect('mongodb://user:pass@localhost:port/database');\n *\n *     // replica sets\n *     var uri = 'mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/mydatabase';\n *     mongoose.connect(uri);\n *\n *     // with options\n *     mongoose.connect(uri, options);\n *\n *     // connecting to multiple mongos\n *     var uri = 'mongodb://hostA:27501,hostB:27501';\n *     var opts = { mongos: true };\n *     mongoose.connect(uri, opts);\n *\n *     // optional callback that gets fired when initial connection completed\n *     var uri = 'mongodb://nonexistent.domain:27000';\n *     mongoose.connect(uri, function(error) {\n *       // if error is truthy, the initial connection failed.\n *     })\n *\n * @param {String} uri(s)\n * @param {Object} [options]\n * @param {Function} [callback]\n * @see Mongoose#createConnection #index_Mongoose-createConnection\n * @api public\n * @return {MongooseThenable} pseudo-promise wrapper around this\n */\n\nMongoose.prototype.connect = function() {\n  var conn = this.connection;\n  if (rgxReplSet.test(arguments[0]) || checkReplicaSetInUri(arguments[0])) {\n    return new MongooseThenable(this, conn.openSet.apply(conn, arguments));\n  }\n\n  return new MongooseThenable(this, conn.open.apply(conn, arguments));\n};\nMongoose.prototype.connect.$hasSideEffects = true;\n\n/**\n * Disconnects all connections.\n *\n * @param {Function} [fn] called after all connection close.\n * @return {MongooseThenable} pseudo-promise wrapper around this\n * @api public\n */\n\nMongoose.prototype.disconnect = function(fn) {\n  var error;\n  this.connections.forEach(function(conn) {\n    conn.close(function(err) {\n      if (error) {\n        return;\n      }\n      if (err) {\n        error = err;\n      }\n    });\n  });\n\n  var Promise = PromiseProvider.get();\n  return new MongooseThenable(this, new Promise.ES6(function(resolve, reject) {\n    fn && fn(error);\n    if (error) {\n      reject(error);\n      return;\n    }\n    resolve();\n  }));\n};\nMongoose.prototype.disconnect.$hasSideEffects = true;\n\n/**\n * Defines a model or retrieves it.\n *\n * Models defined on the `mongoose` instance are available to all connection created by the same `mongoose` instance.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *\n *     // define an Actor model with this mongoose instance\n *     mongoose.model('Actor', new Schema({ name: String }));\n *\n *     // create a new connection\n *     var conn = mongoose.createConnection(..);\n *\n *     // retrieve the Actor model\n *     var Actor = conn.model('Actor');\n *\n * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the [utils.toCollectionName](#utils_exports.toCollectionName) method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._\n *\n * ####Example:\n *\n *     var schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     var collectionName = 'actor'\n *     var M = mongoose.model('Actor', schema, collectionName)\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} [schema]\n * @param {String} [collection] name (optional, inferred from model name)\n * @param {Boolean} [skipInit] whether to skip initialization (defaults to false)\n * @api public\n */\n\nMongoose.prototype.model = function(name, schema, collection, skipInit) {\n  var model;\n  if (typeof name === 'function') {\n    model = name;\n    name = model.name;\n    if (!(model.prototype instanceof Model)) {\n      throw new mongoose.Error('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (utils.isObject(schema) && !(schema.instanceOfSchema)) {\n    schema = new Schema(schema);\n  }\n  if (schema && !schema.instanceOfSchema) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  if (typeof collection === 'boolean') {\n    skipInit = collection;\n    collection = null;\n  }\n\n  // handle internal options from connection.model()\n  var options;\n  if (skipInit && utils.isObject(skipInit)) {\n    options = skipInit;\n    skipInit = true;\n  } else {\n    options = {};\n  }\n\n  // look up schema for the collection.\n  if (!this.modelSchemas[name]) {\n    if (schema) {\n      // cache it so we only apply plugins once\n      this.modelSchemas[name] = schema;\n    } else {\n      throw new mongoose.Error.MissingSchemaError(name);\n    }\n  }\n\n  if (schema) {\n    this._applyPlugins(schema);\n  }\n\n  var sub;\n\n  // connection.model() may be passing a different schema for\n  // an existing model name. in this case don't read from cache.\n  if (this.models[name] && options.cache !== false) {\n    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {\n      throw new mongoose.Error.OverwriteModelError(name);\n    }\n\n    if (collection) {\n      // subclass current model with alternate collection\n      model = this.models[name];\n      schema = model.prototype.schema;\n      sub = model.__subclass(this.connection, schema, collection);\n      // do not cache the sub model\n      return sub;\n    }\n\n    return this.models[name];\n  }\n\n  // ensure a schema exists\n  if (!schema) {\n    schema = this.modelSchemas[name];\n    if (!schema) {\n      throw new mongoose.Error.MissingSchemaError(name);\n    }\n  }\n\n  // Apply relevant \"global\" options to the schema\n  if (!('pluralization' in schema.options)) schema.options.pluralization = this.options.pluralization;\n\n\n  if (!collection) {\n    collection = schema.get('collection') || format(name, schema.options);\n  }\n\n  var connection = options.connection || this.connection;\n  model = this.Model.compile(model || name, schema, collection, connection, this);\n\n  if (!skipInit) {\n    model.init();\n  }\n\n  if (options.cache === false) {\n    return model;\n  }\n\n  this.models[name] = model;\n  return this.models[name];\n};\nMongoose.prototype.model.$hasSideEffects = true;\n\n/**\n * Returns an array of model names created on this instance of Mongoose.\n *\n * ####Note:\n *\n * _Does not include names of models created using `connection.model()`._\n *\n * @api public\n * @return {Array}\n */\n\nMongoose.prototype.modelNames = function() {\n  var names = Object.keys(this.models);\n  return names;\n};\nMongoose.prototype.modelNames.$hasSideEffects = true;\n\n/**\n * Applies global plugins to `schema`.\n *\n * @param {Schema} schema\n * @api private\n */\n\nMongoose.prototype._applyPlugins = function(schema) {\n  if (schema.$globalPluginsApplied) {\n    return;\n  }\n  var i;\n  var len;\n  for (i = 0, len = this.plugins.length; i < len; ++i) {\n    schema.plugin(this.plugins[i][0], this.plugins[i][1]);\n  }\n  schema.$globalPluginsApplied = true;\n  for (i = 0, len = schema.childSchemas.length; i < len; ++i) {\n    this._applyPlugins(schema.childSchemas[i]);\n  }\n};\nMongoose.prototype._applyPlugins.$hasSideEffects = true;\n\n/**\n * Declares a global plugin executed on all Schemas.\n *\n * Equivalent to calling `.plugin(fn)` on each Schema you create.\n *\n * @param {Function} fn plugin callback\n * @param {Object} [opts] optional options\n * @return {Mongoose} this\n * @see plugins ./plugins.html\n * @api public\n */\n\nMongoose.prototype.plugin = function(fn, opts) {\n  this.plugins.push([fn, opts]);\n  return this;\n};\nMongoose.prototype.plugin.$hasSideEffects = true;\n\n/**\n * The default connection of the mongoose module.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     mongoose.connect(...);\n *     mongoose.connection.on('error', cb);\n *\n * This is the connection used by default for every model created using [mongoose.model](#index_Mongoose-model).\n *\n * @property connection\n * @return {Connection}\n * @api public\n */\n\nMongoose.prototype.__defineGetter__('connection', function() {\n  return this.connections[0];\n});\n\nMongoose.prototype.__defineSetter__('connection', function(v) {\n  this.connections[0] = v;\n});\n\n/*!\n * Driver depentend APIs\n */\n\nvar driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';\n\n/*!\n * Connection\n */\n\nvar Connection = require(driver + '/connection');\n\n/*!\n * Collection\n */\n\nvar Collection = require(driver + '/collection');\n\n/**\n * The Mongoose Aggregate constructor\n *\n * @method Aggregate\n * @api public\n */\n\nMongoose.prototype.Aggregate = Aggregate;\n\n/**\n * The Mongoose Collection constructor\n *\n * @method Collection\n * @api public\n */\n\nMongoose.prototype.Collection = Collection;\n\n/**\n * The Mongoose [Connection](#connection_Connection) constructor\n *\n * @method Connection\n * @api public\n */\n\nMongoose.prototype.Connection = Connection;\n\n/**\n * The Mongoose version\n *\n * @property version\n * @api public\n */\n\nMongoose.prototype.version = pkg.version;\n\n/**\n * The Mongoose constructor\n *\n * The exports of the mongoose module is an instance of this class.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     var mongoose2 = new mongoose.Mongoose();\n *\n * @method Mongoose\n * @api public\n */\n\nMongoose.prototype.Mongoose = Mongoose;\n\n/**\n * The Mongoose [Schema](#schema_Schema) constructor\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     var Schema = mongoose.Schema;\n *     var CatSchema = new Schema(..);\n *\n * @method Schema\n * @api public\n */\n\nMongoose.prototype.Schema = Schema;\n\n/**\n * The Mongoose [SchemaType](#schematype_SchemaType) constructor\n *\n * @method SchemaType\n * @api public\n */\n\nMongoose.prototype.SchemaType = SchemaType;\n\n/**\n * The various Mongoose SchemaTypes.\n *\n * ####Note:\n *\n * _Alias of mongoose.Schema.Types for backwards compatibility._\n *\n * @property SchemaTypes\n * @see Schema.SchemaTypes #schema_Schema.Types\n * @api public\n */\n\nMongoose.prototype.SchemaTypes = Schema.Types;\n\n/**\n * The Mongoose [VirtualType](#virtualtype_VirtualType) constructor\n *\n * @method VirtualType\n * @api public\n */\n\nMongoose.prototype.VirtualType = VirtualType;\n\n/**\n * The various Mongoose Types.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     var array = mongoose.Types.Array;\n *\n * ####Types:\n *\n * - [ObjectId](#types-objectid-js)\n * - [Buffer](#types-buffer-js)\n * - [SubDocument](#types-embedded-js)\n * - [Array](#types-array-js)\n * - [DocumentArray](#types-documentarray-js)\n *\n * Using this exposed access to the `ObjectId` type, we can construct ids on demand.\n *\n *     var ObjectId = mongoose.Types.ObjectId;\n *     var id1 = new ObjectId;\n *\n * @property Types\n * @api public\n */\n\nMongoose.prototype.Types = Types;\n\n/**\n * The Mongoose [Query](#query_Query) constructor.\n *\n * @method Query\n * @api public\n */\n\nMongoose.prototype.Query = Query;\n\n/**\n * The Mongoose [Promise](#promise_Promise) constructor.\n *\n * @method Promise\n * @api public\n */\n\nObject.defineProperty(Mongoose.prototype, 'Promise', {\n  get: function() {\n    return PromiseProvider.get();\n  },\n  set: function(lib) {\n    PromiseProvider.set(lib);\n  }\n});\n\n/**\n * Storage layer for mongoose promises\n *\n * @method PromiseProvider\n * @api public\n */\n\nMongoose.prototype.PromiseProvider = PromiseProvider;\n\n/**\n * The Mongoose [Model](#model_Model) constructor.\n *\n * @method Model\n * @api public\n */\n\nMongoose.prototype.Model = Model;\n\n/**\n * The Mongoose [Document](#document-js) constructor.\n *\n * @method Document\n * @api public\n */\n\nMongoose.prototype.Document = Document;\n\n/**\n * The Mongoose DocumentProvider constructor.\n *\n * @method DocumentProvider\n * @api public\n */\n\nMongoose.prototype.DocumentProvider = require('./document_provider');\n\n/**\n * The [MongooseError](#error_MongooseError) constructor.\n *\n * @method Error\n * @api public\n */\n\nMongoose.prototype.Error = require('./error');\n\n/**\n * The Mongoose CastError constructor\n *\n * @method CastError\n * @param {String} type The name of the type\n * @param {Any} value The value that failed to cast\n * @param {String} path The path `a.b.c` in the doc where this cast error occurred\n * @param {Error} [reason] The original error that was thrown\n * @api public\n */\n\nMongoose.prototype.CastError = require('./error/cast');\n\n/**\n * The [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver Mongoose uses.\n *\n * @property mongo\n * @api public\n */\n\nMongoose.prototype.mongo = require('mongodb');\n\n/**\n * The [mquery](https://github.com/aheckmann/mquery) query builder Mongoose uses.\n *\n * @property mquery\n * @api public\n */\n\nMongoose.prototype.mquery = require('mquery');\n\n/**\n * Wraps the given Mongoose instance into a thenable (pseudo-promise). This\n * is so `connect()` and `disconnect()` can return a thenable while maintaining\n * backwards compatibility.\n *\n * @api private\n */\n\nfunction MongooseThenable(mongoose, promise) {\n  var _this = this;\n  for (var key in mongoose) {\n    if (typeof mongoose[key] === 'function' && mongoose[key].$hasSideEffects) {\n      (function(key) {\n        _this[key] = function() {\n          return mongoose[key].apply(mongoose, arguments);\n        };\n      })(key);\n    } else if (['connection', 'connections'].indexOf(key) !== -1) {\n      _this[key] = mongoose[key];\n    }\n  }\n  this.$opPromise = promise;\n}\n\nMongooseThenable.prototype = new Mongoose;\n\n/**\n * Ability to use mongoose object as a pseudo-promise so `.connect().then()`\n * and `.disconnect().then()` are viable.\n *\n * @param {Function} onFulfilled\n * @param {Function} onRejected\n * @return {Promise}\n * @api private\n */\n\nMongooseThenable.prototype.then = function(onFulfilled, onRejected) {\n  var Promise = PromiseProvider.get();\n  if (!this.$opPromise) {\n    return new Promise.ES6(function(resolve, reject) {\n      reject(new Error('Can only call `.then()` if connect() or disconnect() ' +\n        'has been called'));\n    }).then(onFulfilled, onRejected);\n  }\n  this.$opPromise.$hasHandler = true;\n  return this.$opPromise.then(onFulfilled, onRejected);\n};\n\n/**\n * Ability to use mongoose object as a pseudo-promise so `.connect().then()`\n * and `.disconnect().then()` are viable.\n *\n * @param {Function} onFulfilled\n * @param {Function} onRejected\n * @return {Promise}\n * @api private\n */\n\nMongooseThenable.prototype.catch = function(onRejected) {\n  return this.then(null, onRejected);\n};\n\n/*!\n * The exports object is an instance of Mongoose.\n *\n * @api public\n */\n\nvar mongoose = module.exports = exports = new Mongoose;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema.js":"/*!\n * Module dependencies.\n */\n\nvar readPref = require('./drivers').ReadPreference;\nvar EventEmitter = require('events').EventEmitter;\nvar VirtualType = require('./virtualtype');\nvar utils = require('./utils');\nvar MongooseTypes;\nvar Kareem = require('kareem');\nvar each = require('async/each');\nvar SchemaType = require('./schematype');\n\nvar IS_KAREEM_HOOK = {\n  count: true,\n  find: true,\n  findOne: true,\n  findOneAndUpdate: true,\n  findOneAndRemove: true,\n  insertMany: true,\n  update: true,\n  updateMany: true,\n  updateOne: true\n};\n\n/**\n * Schema constructor.\n *\n * ####Example:\n *\n *     var child = new Schema({ name: String });\n *     var schema = new Schema({ name: String, age: Number, children: [child] });\n *     var Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * ####Options:\n *\n * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true\n * - [capped](/docs/guide.html#capped): bool - defaults to false\n * - [collection](/docs/guide.html#collection): string - no default\n * - [emitIndexErrors](/docs/guide.html#emitIndexErrors): bool - defaults to false.\n * - [id](/docs/guide.html#id): bool - defaults to true\n * - [_id](/docs/guide.html#_id): bool - defaults to true\n * - `minimize`: bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\n * - [read](/docs/guide.html#read): string\n * - [safe](/docs/guide.html#safe): bool - defaults to true.\n * - [shardKey](/docs/guide.html#shardKey): bool - defaults to `null`\n * - [strict](/docs/guide.html#strict): bool - defaults to true\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\n * - [toObject](/docs/guide.html#toObject) - object - no default\n * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [useNestedStrict](/docs/guide.html#useNestedStrict) - boolean - defaults to false\n * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [versionKey](/docs/guide.html#versionKey): string - defaults to \"__v\"\n *\n * ####Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object} definition\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = {};\n  this.statics = {};\n  this.tree = {};\n  this.query = {};\n  this.childSchemas = [];\n\n  this.s = {\n    hooks: new Kareem(),\n    kareemHooks: IS_KAREEM_HOOK\n  };\n\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (obj) {\n    this.add(obj);\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  var _idSubDoc = obj && obj._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  var auto_id = !this.paths['_id'] &&\n      (!this.options.noId && this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    obj = {_id: {auto: true}};\n    obj._id[this.options.typeKey] = Schema.ObjectId;\n    this.add(obj);\n  }\n\n  // ensure the documents receive an id getter unless disabled\n  var autoid = !this.paths['id'] &&\n      (!this.options.noVirtualId && this.options.id);\n  if (autoid) {\n    this.virtual('id').get(idGetter);\n  }\n\n  for (var i = 0; i < this._defaultMiddleware.length; ++i) {\n    var m = this._defaultMiddleware[i];\n    this[m.kind](m.hook, !!m.isAsync, m.fn);\n  }\n\n  if (this.options.timestamps) {\n    this.setupTimestamp(this.options.timestamps);\n  }\n}\n\n/*!\n * Returns this documents _id cast to a string.\n */\n\nfunction idGetter() {\n  if (this.$__._id) {\n    return this.$__._id;\n  }\n\n  this.$__._id = this._id == null\n      ? null\n      : String(this._id);\n  return this.$__._id;\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/**\n * Default middleware attached to a schema. Cannot be changed.\n *\n * This field is used to make sure discriminators don't get multiple copies of\n * built-in middleware. Declared as a constant because changing this at runtime\n * may lead to instability with Model.prototype.discriminator().\n *\n * @api private\n * @property _defaultMiddleware\n */\nObject.defineProperty(Schema.prototype, '_defaultMiddleware', {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: [\n    {\n      kind: 'pre',\n      hook: 'save',\n      fn: function(next, options) {\n        var _this = this;\n        // Nested docs have their own presave\n        if (this.ownerDocument) {\n          return next();\n        }\n\n        var hasValidateBeforeSaveOption = options &&\n            (typeof options === 'object') &&\n            ('validateBeforeSave' in options);\n\n        var shouldValidate;\n        if (hasValidateBeforeSaveOption) {\n          shouldValidate = !!options.validateBeforeSave;\n        } else {\n          shouldValidate = this.schema.options.validateBeforeSave;\n        }\n\n        // Validate\n        if (shouldValidate) {\n          // HACK: use $__original_validate to avoid promises so bluebird doesn't\n          // complain\n          if (this.$__original_validate) {\n            this.$__original_validate({__noPromise: true}, function(error) {\n              return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n                next(error);\n              });\n            });\n          } else {\n            this.validate({__noPromise: true}, function(error) {\n              return _this.schema.s.hooks.execPost('save:error', _this, [ _this], { error: error }, function(error) {\n                next(error);\n              });\n            });\n          }\n        } else {\n          next();\n        }\n      }\n    },\n    {\n      kind: 'pre',\n      hook: 'save',\n      isAsync: true,\n      fn: function(next, done) {\n        var _this = this;\n        var subdocs = this.$__getAllSubdocs();\n\n        if (!subdocs.length || this.$__preSavingFromParent) {\n          done();\n          next();\n          return;\n        }\n\n        each(subdocs, function(subdoc, cb) {\n          subdoc.$__preSavingFromParent = true;\n          subdoc.save(function(err) {\n            cb(err);\n          });\n        }, function(error) {\n          for (var i = 0; i < subdocs.length; ++i) {\n            delete subdocs[i].$__preSavingFromParent;\n          }\n          if (error) {\n            return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n              done(error);\n            });\n          }\n          next();\n          done();\n        });\n      }\n    },\n    {\n      kind: 'pre',\n      hook: 'validate',\n      isAsync: true,\n      fn: function(next, done) {\n        // Hack to ensure that we always wrap validate() in a promise\n        next();\n        done();\n      }\n    },\n    {\n      kind: 'pre',\n      hook: 'remove',\n      isAsync: true,\n      fn: function(next, done) {\n        if (this.ownerDocument) {\n          done();\n          next();\n          return;\n        }\n\n        var subdocs = this.$__getAllSubdocs();\n\n        if (!subdocs.length || this.$__preSavingFromParent) {\n          done();\n          next();\n          return;\n        }\n\n        each(subdocs, function(subdoc, cb) {\n          subdoc.remove({ noop: true }, function(err) {\n            cb(err);\n          });\n        }, function(error) {\n          if (error) {\n            done(error);\n            return;\n          }\n          next();\n          done();\n        });\n      }\n    }\n  ]\n});\n\n\n/**\n * The original object passed to the schema constructor\n *\n * ####Example:\n *\n *     var schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n */\n\nSchema.prototype.obj;\n\n/**\n * Schema as flat paths\n *\n * ####Example:\n *     {\n *         '_id'        : SchemaType,\n *       , 'nested.key' : SchemaType,\n *     }\n *\n * @api private\n * @property paths\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * ####Example:\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n */\n\nSchema.prototype.tree;\n\n/**\n * Returns a deep copy of the schema\n *\n * @return {Schema} the cloned schema\n * @api public\n */\n\nSchema.prototype.clone = function() {\n  var s = new Schema(this.obj, this.options);\n  // Clone the call queue\n  s.callQueue = this.callQueue.map(function(f) { return f; });\n  s.methods = utils.clone(this.methods);\n  s.statics = utils.clone(this.statics);\n  s.s.hooks = this.s.hooks.clone();\n  return s;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} options\n * @return {Object}\n * @api private\n */\n\nSchema.prototype.defaultOptions = function(options) {\n  if (options && options.safe === false) {\n    options.safe = {w: 0};\n  }\n\n  if (options && options.safe && options.safe.w === 0) {\n    // if you turn off safe writes, then versioning goes off as well\n    options.versionKey = false;\n  }\n\n  options = utils.options({\n    strict: true,\n    bufferCommands: true,\n    capped: false, // { size, max, autoIndexId }\n    versionKey: '__v',\n    discriminatorKey: '__t',\n    minimize: true,\n    autoIndex: null,\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    // the following are only applied at construction time\n    noId: false, // deprecated, use { _id: false }\n    _id: true,\n    noVirtualId: false, // deprecated, use { id: false }\n    id: true,\n    typeKey: 'type',\n    retainKeyOrder: false\n  }, options);\n\n  if (options.read) {\n    options.read = readPref(options.read);\n  }\n\n  return options;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * ####Example:\n *\n *     var ToySchema = new Schema;\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n * @param {Object} obj\n * @param {String} prefix\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  prefix = prefix || '';\n  var keys = Object.keys(obj);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n\n    if (obj[key] == null) {\n      throw new TypeError('Invalid value for schema path `' + prefix + key + '`');\n    }\n\n    if (Array.isArray(obj[key]) && obj[key].length === 1 && obj[key][0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + prefix + key + '`');\n    }\n\n    if (utils.isObject(obj[key]) &&\n        (!obj[key].constructor || utils.getFunctionName(obj[key].constructor) === 'Object') &&\n        (!obj[key][this.options.typeKey] || (this.options.typeKey === 'type' && obj[key].type.type))) {\n      if (Object.keys(obj[key]).length) {\n        // nested object { last: { name: String }}\n        this.nested[prefix + key] = true;\n        this.add(obj[key], prefix + key + '.');\n      } else {\n        if (prefix) {\n          this.nested[prefix.substr(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, obj[key]); // mixed type\n      }\n    } else {\n      if (prefix) {\n        this.nested[prefix.substr(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, obj[key]);\n    }\n  }\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.\n *\n *      on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      var schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n */\n\nSchema.reserved = Object.create(null);\nvar reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit =\nreserved.on =\nreserved.once =\nreserved.listeners =\nreserved.removeListener =\n// document properties and functions\nreserved.collection =\nreserved.db =\nreserved.errors =\nreserved.init =\nreserved.isModified =\nreserved.isNew =\nreserved.get =\nreserved.modelName =\nreserved.save =\nreserved.schema =\nreserved.set =\nreserved.toObject =\nreserved.validate =\n// hooks.js\nreserved._pres = reserved._posts = 1;\n\n/*!\n * Document keys to print warnings for\n */\n\nvar warnings = {};\nwarnings.increment = '`increment` should not be used as a schema path name ' +\n    'unless you have disabled versioning.';\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * ####Example\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path\n * @param {Object} constructor\n * @api public\n */\n\nSchema.prototype.path = function(path, obj) {\n  if (obj === undefined) {\n    if (this.paths[path]) {\n      return this.paths[path];\n    }\n    if (this.subpaths[path]) {\n      return this.subpaths[path];\n    }\n    if (this.singleNestedPaths[path]) {\n      return this.singleNestedPaths[path];\n    }\n\n    // subpaths?\n    return /\\.\\d+\\.?.*$/.test(path)\n        ? getPositionalPath(this, path)\n        : undefined;\n  }\n\n  // some path names conflict with document methods\n  if (reserved[path]) {\n    throw new Error('`' + path + '` may not be used as a schema pathname');\n  }\n\n  if (warnings[path]) {\n    console.log('WARN: ' + warnings[path]);\n  }\n\n  // update the tree\n  var subpaths = path.split(/\\./),\n      last = subpaths.pop(),\n      branch = this.tree;\n\n  subpaths.forEach(function(sub, i) {\n    if (!branch[sub]) {\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      var msg = 'Cannot set nested path `' + path + '`. '\n          + 'Parent path `'\n          + subpaths.slice(0, i).concat([sub]).join('.')\n          + '` already set to type ' + branch[sub].name\n          + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  });\n\n  branch[last] = utils.clone(obj);\n\n  this.paths[path] = Schema.interpretAsType(path, obj, this.options);\n\n  if (this.paths[path].$isSingleNested) {\n    for (var key in this.paths[path].schema.paths) {\n      this.singleNestedPaths[path + '.' + key] =\n          this.paths[path].schema.paths[key];\n    }\n    for (key in this.paths[path].schema.singleNestedPaths) {\n      this.singleNestedPaths[path + '.' + key] =\n          this.paths[path].schema.singleNestedPaths[key];\n    }\n\n    this.childSchemas.push(this.paths[path].schema);\n  } else if (this.paths[path].$isMongooseDocumentArray) {\n    this.childSchemas.push(this.paths[path].schema);\n  }\n  return this;\n};\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @api private\n */\n\nSchema.interpretAsType = function(path, obj, options) {\n  if (obj.constructor) {\n    var constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      var oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  var type = obj[options.typeKey] && (options.typeKey !== 'type' || !obj.type.type)\n      ? obj[options.typeKey]\n      : {};\n\n  if (utils.getFunctionName(type.constructor) === 'Object' || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || Array === type || type === 'array') {\n    // if it was specified through { type } look for `cast`\n    var cast = (Array === type || type === 'array')\n        ? obj.cast\n        : type[0];\n\n    if (cast && cast.instanceOfSchema) {\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, Schema.interpretAsType(path, cast, options), obj);\n    }\n\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (cast && (!cast[options.typeKey] || (options.typeKey === 'type' && cast.type.type))\n        && utils.getFunctionName(cast.constructor) === 'Object') {\n      if (Object.keys(cast).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        var childSchemaOptions = {minimize: options.minimize};\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        //propagate 'strict' option to child schema\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n        var childSchema = new Schema(cast, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\n          ? cast[options.typeKey]\n          : cast;\n\n      name = typeof type === 'string'\n          ? type\n          : type.schemaName || utils.getFunctionName(type);\n\n      if (!(name in MongooseTypes)) {\n        throw new TypeError('Undefined type `' + name + '` at array `' + path +\n          '`');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n    return new MongooseTypes.Embedded(type, path, obj);\n  }\n\n  var name;\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else {\n    name = typeof type === 'string'\n        ? type\n      // If not string, `type` is a function. Outside of IE, function.name\n      // gives you the function name. In IE, you need to compute it\n        : type.schemaName || utils.getFunctionName(type);\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n\n  if (undefined == MongooseTypes[name]) {\n    throw new TypeError('Undefined type `' + name + '` at `' + path +\n        '`\\n  Did you try nesting Schemas? ' +\n        'You can only nest using refs or arrays.');\n  }\n\n  return new MongooseTypes[name](path, obj);\n};\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and schemaType as arguments on each iteration.\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function(fn) {\n  var keys = Object.keys(this.paths),\n      len = keys.length;\n\n  for (var i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * @api public\n * @param {Boolean} invalidate refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  var paths = Object.keys(this.paths),\n      i = paths.length,\n      ret = [];\n\n  while (i--) {\n    var path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function(path) {\n  if (path in this.paths) {\n    return 'real';\n  }\n  if (path in this.virtuals) {\n    return 'virtual';\n  }\n  if (path in this.nested) {\n    return 'nested';\n  }\n  if (path in this.subpaths) {\n    return 'real';\n  }\n  if (path in this.singleNestedPaths) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function(path) {\n  var subpaths = path.split(/\\./g);\n  path = '';\n  for (var i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (path in this.paths &&\n        this.paths[path] instanceof MongooseTypes.Mixed) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function(timestamps) {\n  if (timestamps) {\n    var createdAt = timestamps.createdAt || 'createdAt';\n    var updatedAt = timestamps.updatedAt || 'updatedAt';\n    var schemaAdditions = {};\n\n    var parts = createdAt.split('.');\n    var i;\n    var cur = schemaAdditions;\n    for (i = 0; i < parts.length; ++i) {\n      cur[parts[i]] = (i < parts.length - 1 ?\n        cur[parts[i]] || {} :\n        Date);\n    }\n\n    parts = updatedAt.split('.');\n    cur = schemaAdditions;\n    for (i = 0; i < parts.length; ++i) {\n      cur[parts[i]] = (i < parts.length - 1 ?\n        cur[parts[i]] || {} :\n        Date);\n    }\n\n    this.add(schemaAdditions);\n\n    this.pre('save', function(next) {\n      var defaultTimestamp = new Date();\n      var auto_id = this._id && this._id.auto;\n\n      if (!this.get(createdAt) && this.isSelected(createdAt)) {\n        this.set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);\n      }\n\n      if (this.isNew || this.isModified()) {\n        this.set(updatedAt, this.isNew ? this.get(createdAt) : defaultTimestamp);\n      }\n\n      next();\n    });\n\n    var genUpdates = function(currentUpdate, overwrite) {\n      var now = new Date();\n      var updates = {};\n      if (overwrite) {\n        if (!currentUpdate[updatedAt]) {\n          updates[updatedAt] = now;\n        }\n        if (!currentUpdate[createdAt]) {\n          updates[createdAt] = now;\n        }\n        return updates;\n      }\n      updates = { $set: {} };\n      currentUpdate = currentUpdate || {};\n\n      updates.$set[updatedAt] = now;\n\n      if (currentUpdate[createdAt]) {\n        delete currentUpdate[createdAt];\n      }\n      if (currentUpdate.$set && currentUpdate.$set[createdAt]) {\n        delete currentUpdate.$set[createdAt];\n      }\n\n      updates.$setOnInsert = {};\n      updates.$setOnInsert[createdAt] = now;\n\n      return updates;\n    };\n\n    this.methods.initializeTimestamps = function() {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    };\n\n    this.pre('findOneAndUpdate', function(next) {\n      var overwrite = this.options.overwrite;\n      this.findOneAndUpdate({}, genUpdates(this.getUpdate(), overwrite), {\n        overwrite: overwrite\n      });\n      applyTimestampsToChildren(this);\n      next();\n    });\n\n    this.pre('update', function(next) {\n      var overwrite = this.options.overwrite;\n      this.update({}, genUpdates(this.getUpdate(), overwrite), {\n        overwrite: overwrite\n      });\n      applyTimestampsToChildren(this);\n      next();\n    });\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToChildren(query) {\n  var now = new Date();\n  var update = query.getUpdate();\n  var keys = Object.keys(update);\n  var key;\n  var schema = query.model.schema;\n  var len;\n  var createdAt;\n  var updatedAt;\n  var timestamps;\n  var path;\n\n  var hasDollarKey = keys.length && keys[0].charAt(0) === '$';\n\n  if (hasDollarKey) {\n    if (update.$push) {\n      for (key in update.$push) {\n        var $path = schema.path(key);\n        if (update.$push[key] &&\n            $path &&\n            $path.$isMongooseDocumentArray &&\n            $path.schema.options.timestamps) {\n          timestamps = $path.schema.options.timestamps;\n          createdAt = timestamps.createdAt || 'createdAt';\n          updatedAt = timestamps.updatedAt || 'updatedAt';\n          if (update.$push[key].$each) {\n            update.$push[key].$each.forEach(function(subdoc) {\n              subdoc[updatedAt] = now;\n              subdoc[createdAt] = now;\n            });\n          } else {\n            update.$push[key][updatedAt] = now;\n            update.$push[key][createdAt] = now;\n          }\n        }\n      }\n    }\n    if (update.$set) {\n      for (key in update.$set) {\n        path = schema.path(key);\n        if (!path) {\n          continue;\n        }\n        if (Array.isArray(update.$set[key]) && path.$isMongooseDocumentArray) {\n          len = update.$set[key].length;\n          timestamps = schema.path(key).schema.options.timestamps;\n          if (timestamps) {\n            createdAt = timestamps.createdAt || 'createdAt';\n            updatedAt = timestamps.updatedAt || 'updatedAt';\n            for (var i = 0; i < len; ++i) {\n              update.$set[key][i][updatedAt] = now;\n              update.$set[key][i][createdAt] = now;\n            }\n          }\n        } else if (update.$set[key] && path.$isSingleNested) {\n          timestamps = schema.path(key).schema.options.timestamps;\n          if (timestamps) {\n            createdAt = timestamps.createdAt || 'createdAt';\n            updatedAt = timestamps.updatedAt || 'updatedAt';\n            update.$set[key][updatedAt] = now;\n            update.$set[key][createdAt] = now;\n          }\n        }\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction getPositionalPathType(self, path) {\n  var subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths[subpaths[0]];\n  }\n\n  var val = self.path(subpaths[0]);\n  var isNested = false;\n  if (!val) {\n    return val;\n  }\n\n  var last = subpaths.length - 1,\n      subpath,\n      i = 1;\n\n  for (; i < subpaths.length; ++i) {\n    isNested = false;\n    subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        var oldVal = val;\n        val = new SchemaType(subpath);\n        val.cast = function(value, doc, init) {\n          return oldVal.cast(value, doc, init)[0];\n        };\n        val.caster = oldVal.caster;\n        val.schema = oldVal.schema;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    var type = val.schema.pathType(subpath);\n    isNested = (type === 'nested');\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[path] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path) {\n  getPositionalPathType(self, path);\n  return self.subpaths[path];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function(name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the document.\n *\n * ####Example\n *\n *     var toySchema = new Schema(..);\n *\n *     toySchema.pre('save', function (next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     })\n *\n *     toySchema.pre('validate', function (next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     })\n *\n * @param {String} method\n * @param {Function} callback\n * @see hooks.js https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3\n * @api public\n */\n\nSchema.prototype.pre = function() {\n  var name = arguments[0];\n  if (IS_KAREEM_HOOK[name]) {\n    this.s.hooks.pre.apply(this.s.hooks, arguments);\n    return this;\n  }\n  return this.queue('pre', arguments);\n};\n\n/**\n * Defines a post hook for the document\n *\n *     var schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     shema.post('find', function(docs) {\n *       console.log('this fired after you run a find query');\n *     });\n *\n *     var Model = mongoose.model('Model', schema);\n *\n *     var m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String} method name of the method to hook\n * @param {Function} fn callback\n * @see middleware http://mongoosejs.com/docs/middleware.html\n * @see hooks.js https://www.npmjs.com/package/hooks-fixed\n * @see kareem http://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function(method, fn) {\n  if (IS_KAREEM_HOOK[method]) {\n    this.s.hooks.post.apply(this.s.hooks, arguments);\n    return this;\n  }\n  // assuming that all callbacks with arity < 2 are synchronous post hooks\n  if (fn.length < 2) {\n    return this.queue('on', [arguments[0], function(doc) {\n      return fn.call(doc, doc);\n    }]);\n  }\n\n  if (fn.length === 3) {\n    this.s.hooks.post(method + ':error', fn);\n    return this;\n  }\n\n  return this.queue('post', [arguments[0], function(next) {\n    // wrap original function so that the callback goes last,\n    // for compatibility with old code that is using synchronous post hooks\n    var _this = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n    fn.call(this, this, function(err) {\n      return next.apply(_this, [err].concat(args));\n    });\n  }]);\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * @param {Function} plugin callback\n * @param {Object} [opts]\n * @see plugins\n * @api public\n */\n\nSchema.prototype.plugin = function(fn, opts) {\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * ####Example\n *\n *     var schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     var Kitty = mongoose.model('Kitty', schema);\n *\n *     var fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     fizz.purr();\n *     fizz.scratch();\n *\n * @param {String|Object} method name\n * @param {Function} [fn]\n * @api public\n */\n\nSchema.prototype.method = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (var i in name) {\n      this.methods[i] = name[i];\n    }\n  } else {\n    this.methods[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * ####Example\n *\n *     var schema = new Schema(..);\n *     schema.static('findByName', function (name, callback) {\n *       return this.find({ name: name }, callback);\n *     });\n *\n *     var Drink = mongoose.model('Drink', schema);\n *     Drink.findByName('sanpellegrino', function (err, drinks) {\n *       //\n *     });\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name\n * @param {Function} [fn]\n * @api public\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (var i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * ####Example\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)\n * @param {String} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @api public\n */\n\nSchema.prototype.index = function(fields, options) {\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets/gets a schema option.\n *\n * ####Example\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key option name\n * @param {Object} [value] if not passed, the current option value is returned\n * @see Schema ./\n * @api public\n */\n\nSchema.prototype.set = function(key, value, _tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      this.options[key] = readPref(value, _tags);\n      break;\n    case 'safe':\n      this.options[key] = value === false\n          ? {w: 0}\n          : value;\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      break;\n    default:\n      this.options[key] = value;\n  }\n\n  return this;\n};\n\n/**\n * Gets a schema option.\n *\n * @param {String} key option name\n * @api public\n */\n\nSchema.prototype.get = function(key) {\n  return this.options[key];\n};\n\n/**\n * The allowed index types\n *\n * @static indexTypes\n * @receiver Schema\n * @api public\n */\n\nvar indexTypes = '2d 2dsphere hashed text'.split(' ');\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function() {\n    return indexTypes;\n  },\n  set: function() {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Compiles indexes from fields and schema-level indexes\n *\n * @api public\n */\n\nSchema.prototype.indexes = function() {\n  'use strict';\n\n  var indexes = [];\n  var seenPrefix = {};\n\n  var collectIndexes = function(schema, prefix) {\n    if (seenPrefix[prefix]) {\n      return;\n    }\n    seenPrefix[prefix] = true;\n\n    prefix = prefix || '';\n    var key, path, index, field, isObject, options, type;\n    var keys = Object.keys(schema.paths);\n\n    for (var i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      path = schema.paths[key];\n\n      if ((path instanceof MongooseTypes.DocumentArray) || path.$isSingleNested) {\n        collectIndexes(path.schema, key + '.');\n      } else {\n        index = path._index;\n\n        if (index !== false && index !== null && index !== undefined) {\n          field = {};\n          isObject = utils.isObject(index);\n          options = isObject ? index : {};\n          type = typeof index === 'string' ? index :\n              isObject ? index.type :\n                  false;\n\n          if (type && ~Schema.indexTypes.indexOf(type)) {\n            field[prefix + key] = type;\n          } else if (options.text) {\n            field[prefix + key] = 'text';\n            delete options.text;\n          } else {\n            field[prefix + key] = 1;\n          }\n\n          delete options.type;\n          if (!('background' in options)) {\n            options.background = true;\n          }\n\n          indexes.push([field, options]);\n        }\n      }\n    }\n\n    if (prefix) {\n      fixSubIndexPaths(schema, prefix);\n    } else {\n      schema._indexes.forEach(function(index) {\n        if (!('background' in index[1])) {\n          index[1].background = true;\n        }\n      });\n      indexes = indexes.concat(schema._indexes);\n    }\n  };\n\n  collectIndexes(this);\n  return indexes;\n\n  /*!\n   * Checks for indexes added to subdocs using Schema.index().\n   * These indexes need their paths prefixed properly.\n   *\n   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]\n   */\n\n  function fixSubIndexPaths(schema, prefix) {\n    var subindexes = schema._indexes,\n        len = subindexes.length,\n        indexObj,\n        newindex,\n        klen,\n        keys,\n        key,\n        i = 0,\n        j;\n\n    for (i = 0; i < len; ++i) {\n      indexObj = subindexes[i][0];\n      keys = Object.keys(indexObj);\n      klen = keys.length;\n      newindex = {};\n\n      // use forward iteration, order matters\n      for (j = 0; j < klen; ++j) {\n        key = keys[j];\n        newindex[prefix + key] = indexObj[key];\n      }\n\n      indexes.push([newindex, subindexes[i][1]]);\n    }\n  }\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name\n * @param {Object} [options]\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function(name, options) {\n  if (options && options.ref) {\n    if (!options.localField) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (!options.foreignField) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function(next, obj) {\n      if (name in obj) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne) {\n          this.$$populatedVirtuals[name] = Array.isArray(obj[name]) ?\n            obj[name][0] :\n            obj[name];\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(obj[name]) ?\n            obj[name] :\n            obj[name] == null ? [] : [obj[name]];\n        }\n\n        delete obj[name];\n      }\n      if (this.ownerDocument) {\n        next();\n        return this;\n      } else {\n        next();\n      }\n    });\n\n    var virtual = this.virtual(name);\n    virtual.options = options;\n    return virtual.\n      get(function() {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n        if (name in this.$$populatedVirtuals) {\n          return this.$$populatedVirtuals[name];\n        }\n        return null;\n      }).\n      set(function(v) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n        this.$$populatedVirtuals[name] = v;\n      });\n  }\n\n  var virtuals = this.virtuals;\n  var parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' +\n      ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function(mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length - 1)\n        ? new VirtualType(options, name)\n        : {});\n    return mem[part];\n  }, this.tree);\n\n  return virtuals[name];\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getVirtual = function(name) {\n  return _getVirtual(this, name);\n};\n\n/*!\n * ignore\n */\n\nfunction _getVirtual(schema, name) {\n  if (schema.virtuals[name]) {\n    return schema.virtuals[name];\n  }\n  var parts = name.split('.');\n  var cur = '';\n  var nestedSchemaPath = '';\n  for (var i = 0; i < parts.length; ++i) {\n    cur += (cur.length > 0 ? '.' : '') + parts[i];\n    if (schema.virtuals[cur]) {\n      if (i === parts.length - 1) {\n        schema.virtuals[cur].$nestedSchemaPath = nestedSchemaPath;\n        return schema.virtuals[cur];\n      }\n      continue;\n    } else if (schema.paths[cur] && schema.paths[cur].schema) {\n      schema = schema.paths[cur].schema;\n      nestedSchemaPath += (nestedSchemaPath.length > 0 ? '.' : '') + cur;\n      cur = '';\n    } else {\n      return null;\n    }\n  }\n}\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name\n * @return {VirtualType}\n */\n\nSchema.prototype.virtualpath = function(name) {\n  return this.virtuals[name];\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * @param {String|Array} path\n *\n * @api public\n */\nSchema.prototype.remove = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function(name) {\n      if (this.path(name)) {\n        delete this.paths[name];\n\n        var pieces = name.split('.');\n        var last = pieces.pop();\n        var branch = this.tree;\n        for (var i = 0; i < pieces.length; ++i) {\n          branch = branch[pieces[i]];\n        }\n        delete branch[last];\n      }\n    }, this);\n  }\n};\n\n/**\n * Loads an ES6 class into a schema. Maps setters + getters, static methods, and instance methods to schema virtuals, statics, and methods.\n *\n * @param {Function} model\n */\nSchema.prototype.loadClass = function(model, virtualsOnly) {\n  if (model === Object.prototype ||\n      model === Function.prototype ||\n      model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {\n    return this;\n  }\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function(name) {\n      if (name.match(/^(length|name|prototype)$/)) {\n        return;\n      }\n      var method = Object.getOwnPropertyDescriptor(model, name);\n      if (typeof method.value === 'function') this.static(name, method.value);\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    var method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n\n  return (this.loadClass(Object.getPrototypeOf(model)));\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function(path) {\n  var _this = this;\n  var pathschema = _this.path(path);\n  var resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    var p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            var ret;\n            if (parts[p] === '$') {\n              if (p + 1 === parts.length) {\n                // comments.$\n                return foundschema;\n              }\n              // comments.$.comments.$.title\n              ret = search(parts.slice(p + 1), foundschema.schema);\n              if (ret) {\n                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                  !foundschema.schema.$isSingleNested;\n              }\n              return ret;\n            }\n            // this is the last path of the selector\n            ret = search(parts.slice(p), foundschema.schema);\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                !foundschema.schema.$isSingleNested;\n            }\n            return ret;\n          }\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function(path) {\n  var _this = this;\n  var pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    var p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return { schema: foundschema, pathType: 'mixed' };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$') {\n              if (p === parts.length - 1) {\n                return { schema: foundschema, pathType: 'nested' };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return { schema: foundschema, pathType: 'real' };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return { schema: schema, pathType: 'nested' };\n      }\n    }\n    return { schema: foundschema || schema, pathType: 'undefined' };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     var ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * ####Types:\n *\n * - [String](#schema-string-js)\n * - [Number](#schema-number-js)\n * - [Boolean](#schema-boolean-js) | Bool\n * - [Array](#schema-array-js)\n * - [Buffer](#schema-buffer-js)\n * - [Date](#schema-date-js)\n * - [ObjectId](#schema-objectid-js) | Oid\n * - [Mixed](#schema-mixed-js)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     var Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/drivers/index.js":"/*!\n * ignore\n */\n\nvar driver;\n\nif (typeof window === 'undefined') {\n  driver = require(global.MONGOOSE_DRIVER_PATH || './node-mongodb-native');\n} else {\n  driver = require('./browser');\n}\n\n/*!\n * ignore\n */\n\nmodule.exports = driver;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/drivers/node-mongodb-native/index.js":"/*!\n * Module exports.\n */\n\nexports.Binary = require('./binary');\nexports.ObjectId = require('./objectid');\nexports.ReadPreference = require('./ReadPreference');\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/drivers/node-mongodb-native/binary.js":"\n/*!\n * Module dependencies.\n */\n\nvar Binary = require('mongodb').Binary;\n\nmodule.exports = exports = Binary;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/drivers/node-mongodb-native/objectid.js":"\n/*!\n * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId\n * @constructor NodeMongoDbObjectId\n * @see ObjectId\n */\n\nvar ObjectId = require('mongodb').ObjectId;\n\n/*!\n * ignore\n */\n\nmodule.exports = exports = ObjectId;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/drivers/node-mongodb-native/ReadPreference.js":"/*!\n * Module dependencies.\n */\n\nvar mongodb = require('mongodb');\nvar ReadPref = mongodb.ReadPreference;\n\n/*!\n * Converts arguments to ReadPrefs the driver\n * can understand.\n *\n * @param {String|Array} pref\n * @param {Array} [tags]\n */\n\nmodule.exports = function readPref(pref, tags) {\n  if (Array.isArray(pref)) {\n    tags = pref[1];\n    pref = pref[0];\n  }\n\n  if (pref instanceof ReadPref) {\n    return pref;\n  }\n\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return new ReadPref(pref, tags);\n};\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/virtualtype.js":"\n/**\n * VirtualType constructor\n *\n * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.\n *\n * ####Example:\n *\n *     var fullname = schema.virtual('fullname');\n *     fullname instanceof mongoose.VirtualType // true\n *\n * @parma {Object} options\n * @api public\n */\n\nfunction VirtualType(options, name) {\n  this.path = name;\n  this.getters = [];\n  this.setters = [];\n  this.options = options || {};\n}\n\n/**\n * Defines a getter.\n *\n * ####Example:\n *\n *     var virtual = schema.virtual('fullname');\n *     virtual.get(function () {\n *       return this.name.first + ' ' + this.name.last;\n *     });\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.get = function(fn) {\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Defines a setter.\n *\n * ####Example:\n *\n *     var virtual = schema.virtual('fullname');\n *     virtual.set(function (v) {\n *       var parts = v.split(' ');\n *       this.name.first = parts[0];\n *       this.name.last = parts[1];\n *     });\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.set = function(fn) {\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Applies getters to `value` using optional `scope`.\n *\n * @param {Object} value\n * @param {Object} scope\n * @return {any} the value after applying all getters\n * @api public\n */\n\nVirtualType.prototype.applyGetters = function(value, scope) {\n  var v = value;\n  for (var l = this.getters.length - 1; l >= 0; l--) {\n    v = this.getters[l].call(scope, v, this);\n  }\n  return v;\n};\n\n/**\n * Applies setters to `value` using optional `scope`.\n *\n * @param {Object} value\n * @param {Object} scope\n * @return {any} the value after applying all setters\n * @api public\n */\n\nVirtualType.prototype.applySetters = function(value, scope) {\n  var v = value;\n  for (var l = this.setters.length - 1; l >= 0; l--) {\n    v = this.setters[l].call(scope, v, this);\n  }\n  return v;\n};\n\n/*!\n * exports\n */\n\nmodule.exports = VirtualType;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/utils.js":"/*!\n * Module dependencies.\n */\n\nvar Decimal = require('./types/decimal128');\nvar ObjectId = require('./types/objectid');\nvar cloneRegExp = require('regexp-clone');\nvar sliced = require('sliced');\nvar mpath = require('mpath');\nvar ms = require('ms');\nvar MongooseBuffer;\nvar MongooseArray;\nvar Document;\n\n/*!\n * Produces a collection name from model `name`.\n *\n * @param {String} name a model name\n * @return {String} a collection name\n * @api private\n */\n\nexports.toCollectionName = function(name, options) {\n  options = options || {};\n  if (name === 'system.profile') {\n    return name;\n  }\n  if (name === 'system.indexes') {\n    return name;\n  }\n  if (options.pluralization === false) {\n    return name;\n  }\n  return pluralize(name.toLowerCase());\n};\n\n/**\n * Pluralization rules.\n *\n * These rules are applied while processing the argument to `toCollectionName`.\n *\n * @deprecated remove in 4.x gh-1350\n */\n\nexports.pluralization = [\n  [/(m)an$/gi, '$1en'],\n  [/(pe)rson$/gi, '$1ople'],\n  [/(child)$/gi, '$1ren'],\n  [/^(ox)$/gi, '$1en'],\n  [/(ax|test)is$/gi, '$1es'],\n  [/(octop|vir)us$/gi, '$1i'],\n  [/(alias|status)$/gi, '$1es'],\n  [/(bu)s$/gi, '$1ses'],\n  [/(buffal|tomat|potat)o$/gi, '$1oes'],\n  [/([ti])um$/gi, '$1a'],\n  [/sis$/gi, 'ses'],\n  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],\n  [/(hive)$/gi, '$1s'],\n  [/([^aeiouy]|qu)y$/gi, '$1ies'],\n  [/(x|ch|ss|sh)$/gi, '$1es'],\n  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],\n  [/([m|l])ouse$/gi, '$1ice'],\n  [/(kn|w|l)ife$/gi, '$1ives'],\n  [/(quiz)$/gi, '$1zes'],\n  [/s$/gi, 's'],\n  [/([^a-z])$/, '$1'],\n  [/$/gi, 's']\n];\nvar rules = exports.pluralization;\n\n/**\n * Uncountable words.\n *\n * These words are applied while processing the argument to `toCollectionName`.\n * @api public\n */\n\nexports.uncountables = [\n  'advice',\n  'energy',\n  'excretion',\n  'digestion',\n  'cooperation',\n  'health',\n  'justice',\n  'labour',\n  'machinery',\n  'equipment',\n  'information',\n  'pollution',\n  'sewage',\n  'paper',\n  'money',\n  'species',\n  'series',\n  'rain',\n  'rice',\n  'fish',\n  'sheep',\n  'moose',\n  'deer',\n  'news',\n  'expertise',\n  'status',\n  'media'\n];\nvar uncountables = exports.uncountables;\n\n/*!\n * Pluralize function.\n *\n * @author TJ Holowaychuk (extracted from _ext.js_)\n * @param {String} string to pluralize\n * @api private\n */\n\nfunction pluralize(str) {\n  var found;\n  if (!~uncountables.indexOf(str.toLowerCase())) {\n    found = rules.filter(function(rule) {\n      return str.match(rule[0]);\n    });\n    if (found[0]) {\n      return str.replace(found[0][0], found[0][1]);\n    }\n  }\n  return str;\n}\n\n/*!\n * Determines if `a` and `b` are deep equal.\n *\n * Modified from node/lib/assert.js\n *\n * @param {any} a a value to compare to `b`\n * @param {any} b a value to compare to `a`\n * @return {Boolean}\n * @api private\n */\n\nexports.deepEqual = function deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n\n  if ((a instanceof ObjectId && b instanceof ObjectId) ||\n      (a instanceof Decimal && b instanceof Decimal)) {\n    return a.toString() === b.toString();\n  }\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source &&\n        a.ignoreCase === b.ignoreCase &&\n        a.multiline === b.multiline &&\n        a.global === b.global;\n  }\n\n  if (typeof a !== 'object' && typeof b !== 'object') {\n    return a == b;\n  }\n\n  if (a === null || b === null || a === undefined || b === undefined) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  // Handle MongooseNumbers\n  if (a instanceof Number && b instanceof Number) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (Buffer.isBuffer(a)) {\n    return exports.buffer.areEqual(a, b);\n  }\n\n  if (isMongooseObject(a)) {\n    a = a.toObject();\n  }\n  if (isMongooseObject(b)) {\n    b = b.toObject();\n  }\n\n  try {\n    var ka = Object.keys(a),\n        kb = Object.keys(b),\n        key, i;\n  } catch (e) {\n    // happens when one is a string literal and the other isn't\n    return false;\n  }\n\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length) {\n    return false;\n  }\n\n  // the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n\n  // ~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i]) {\n      return false;\n    }\n  }\n\n  // equivalent values for every corresponding key, and\n  // ~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/*!\n * Object clone with Mongoose natives support.\n *\n * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.\n *\n * Functions are never cloned.\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @return {Object} the cloned object\n * @api private\n */\n\nexports.clone = function clone(obj, options) {\n  if (obj === undefined || obj === null) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return cloneArray(obj, options);\n  }\n\n  if (isMongooseObject(obj)) {\n    if (options && options.json && typeof obj.toJSON === 'function') {\n      return obj.toJSON(options);\n    }\n    return obj.toObject(options);\n  }\n\n  if (obj.constructor) {\n    switch (exports.getFunctionName(obj.constructor)) {\n      case 'Object':\n        return cloneObject(obj, options);\n      case 'Date':\n        return new obj.constructor(+obj);\n      case 'RegExp':\n        return cloneRegExp(obj);\n      default:\n        // ignore\n        break;\n    }\n  }\n\n  if (obj instanceof ObjectId) {\n    return new ObjectId(obj.id);\n  }\n  if (obj instanceof Decimal) {\n    if (options && options.flattenDecimals) {\n      return obj.toJSON();\n    }\n    return Decimal.fromString(obj.toString());\n  }\n\n  if (!obj.constructor && exports.isObject(obj)) {\n    // object created with Object.create(null)\n    return cloneObject(obj, options);\n  }\n\n  if (obj.valueOf) {\n    return obj.valueOf();\n  }\n};\nvar clone = exports.clone;\n\n/*!\n * ignore\n */\n\nfunction cloneObject(obj, options) {\n  var retainKeyOrder = options && options.retainKeyOrder,\n      minimize = options && options.minimize,\n      ret = {},\n      hasKeys,\n      keys,\n      val,\n      k,\n      i;\n\n  if (retainKeyOrder) {\n    for (k in obj) {\n      val = clone(obj[k], options);\n\n      if (!minimize || (typeof val !== 'undefined')) {\n        hasKeys || (hasKeys = true);\n        ret[k] = val;\n      }\n    }\n  } else {\n    // faster\n\n    keys = Object.keys(obj);\n    i = keys.length;\n\n    while (i--) {\n      k = keys[i];\n      val = clone(obj[k], options);\n\n      if (!minimize || (typeof val !== 'undefined')) {\n        if (!hasKeys) {\n          hasKeys = true;\n        }\n        ret[k] = val;\n      }\n    }\n  }\n\n  return minimize\n      ? hasKeys && ret\n      : ret;\n}\n\nfunction cloneArray(arr, options) {\n  var ret = [];\n  for (var i = 0, l = arr.length; i < l; i++) {\n    ret.push(clone(arr[i], options));\n  }\n  return ret;\n}\n\n/*!\n * Shallow copies defaults into options.\n *\n * @param {Object} defaults\n * @param {Object} options\n * @return {Object} the merged object\n * @api private\n */\n\nexports.options = function(defaults, options) {\n  var keys = Object.keys(defaults),\n      i = keys.length,\n      k;\n\n  options = options || {};\n\n  while (i--) {\n    k = keys[i];\n    if (!(k in options)) {\n      options[k] = defaults[k];\n    }\n  }\n\n  return options;\n};\n\n/*!\n * Generates a random string\n *\n * @api private\n */\n\nexports.random = function() {\n  return Math.random().toString().substr(3);\n};\n\n/*!\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.merge = function merge(to, from, options) {\n  options = options || {};\n  var keys = Object.keys(from);\n  var i = 0;\n  var len = keys.length;\n  var key;\n\n  if (options.retainKeyOrder) {\n    while (i < len) {\n      key = keys[i++];\n      if (to[key] == null) {\n        to[key] = from[key];\n      } else if (exports.isObject(from[key])) {\n        merge(to[key], from[key], options);\n      } else if (options.overwrite) {\n        to[key] = from[key];\n      }\n    }\n  } else {\n    while (len--) {\n      key = keys[len];\n      if (to[key] == null) {\n        to[key] = from[key];\n      } else if (exports.isObject(from[key])) {\n        merge(to[key], from[key], options);\n      } else if (options.overwrite) {\n        to[key] = from[key];\n      }\n    }\n  }\n};\n\n/*!\n * toString helper\n */\n\nvar toString = Object.prototype.toString;\n\n/*!\n * Applies toObject recursively.\n *\n * @param {Document|Array|Object} obj\n * @return {Object}\n * @api private\n */\n\nexports.toObject = function toObject(obj) {\n  Document || (Document = require('./document'));\n  var ret;\n\n  if (exports.isNullOrUndefined(obj)) {\n    return obj;\n  }\n\n  if (obj instanceof Document) {\n    return obj.toObject();\n  }\n\n  if (Array.isArray(obj)) {\n    ret = [];\n\n    for (var i = 0, len = obj.length; i < len; ++i) {\n      ret.push(toObject(obj[i]));\n    }\n\n    return ret;\n  }\n\n  if ((obj.constructor && exports.getFunctionName(obj.constructor) === 'Object') ||\n      (!obj.constructor && exports.isObject(obj))) {\n    ret = {};\n\n    for (var k in obj) {\n      ret[k] = toObject(obj[k]);\n    }\n\n    return ret;\n  }\n\n  return obj;\n};\n\n/*!\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nexports.isObject = function(arg) {\n  if (Buffer.isBuffer(arg)) {\n    return true;\n  }\n  return toString.call(arg) === '[object Object]';\n};\n\n/*!\n * A faster Array.prototype.slice.call(arguments) alternative\n * @api private\n */\n\nexports.args = sliced;\n\n/*!\n * process.nextTick helper.\n *\n * Wraps `callback` in a try/catch + nextTick.\n *\n * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.\n *\n * @param {Function} callback\n * @api private\n */\n\nexports.tick = function tick(callback) {\n  if (typeof callback !== 'function') {\n    return;\n  }\n  return function() {\n    try {\n      callback.apply(this, arguments);\n    } catch (err) {\n      // only nextTick on err to get out of\n      // the event loop and avoid state corruption.\n      process.nextTick(function() {\n        throw err;\n      });\n    }\n  };\n};\n\n/*!\n * Returns if `v` is a mongoose object that has a `toObject()` method we can use.\n *\n * This is for compatibility with libs like Date.js which do foolish things to Natives.\n *\n * @param {any} v\n * @api private\n */\n\nexports.isMongooseObject = function(v) {\n  Document || (Document = require('./document'));\n  MongooseArray || (MongooseArray = require('./types').Array);\n  MongooseBuffer || (MongooseBuffer = require('./types').Buffer);\n\n  return v instanceof Document ||\n      (v && v.isMongooseArray) ||\n      (v && v.isMongooseBuffer);\n};\nvar isMongooseObject = exports.isMongooseObject;\n\n/*!\n * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.\n *\n * @param {Object} object\n * @api private\n */\n\nexports.expires = function expires(object) {\n  if (!(object && object.constructor.name === 'Object')) {\n    return;\n  }\n  if (!('expires' in object)) {\n    return;\n  }\n\n  var when;\n  if (typeof object.expires !== 'string') {\n    when = object.expires;\n  } else {\n    when = Math.round(ms(object.expires) / 1000);\n  }\n  object.expireAfterSeconds = when;\n  delete object.expires;\n};\n\n/*!\n * Populate options constructor\n */\n\nfunction PopulateOptions(path, select, match, options, model, subPopulate) {\n  this.path = path;\n  this.match = match;\n  this.select = select;\n  this.options = options;\n  this.model = model;\n  if (typeof subPopulate === 'object') {\n    this.populate = subPopulate;\n  }\n  this._docs = {};\n}\n\n// make it compatible with utils.clone\nPopulateOptions.prototype.constructor = Object;\n\n// expose\nexports.PopulateOptions = PopulateOptions;\n\n/*!\n * populate helper\n */\n\nexports.populate = function populate(path, select, model, match, options, subPopulate) {\n  // The order of select/conditions args is opposite Model.find but\n  // necessary to keep backward compatibility (select could be\n  // an array, string, or object literal).\n\n  // might have passed an object specifying all arguments\n  if (arguments.length === 1) {\n    if (path instanceof PopulateOptions) {\n      return [path];\n    }\n\n    if (Array.isArray(path)) {\n      return path.map(function(o) {\n        return exports.populate(o)[0];\n      });\n    }\n\n    if (exports.isObject(path)) {\n      match = path.match;\n      options = path.options;\n      select = path.select;\n      model = path.model;\n      subPopulate = path.populate;\n      path = path.path;\n    }\n  } else if (typeof model !== 'string' && typeof model !== 'function') {\n    options = match;\n    match = model;\n    model = undefined;\n  }\n\n  if (typeof path !== 'string') {\n    throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');\n  }\n\n  if (typeof subPopulate === 'object') {\n    subPopulate = exports.populate(subPopulate);\n  }\n\n  var ret = [];\n  var paths = path.split(' ');\n  options = exports.clone(options, { retainKeyOrder: true });\n  for (var i = 0; i < paths.length; ++i) {\n    ret.push(new PopulateOptions(paths[i], select, match, options, model, subPopulate));\n  }\n\n  return ret;\n};\n\n/*!\n * Return the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Object} obj\n */\n\nexports.getValue = function(path, obj, map) {\n  return mpath.get(path, obj, '_doc', map);\n};\n\n/*!\n * Sets the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Anything} val\n * @param {Object} obj\n */\n\nexports.setValue = function(path, val, obj, map) {\n  mpath.set(path, val, obj, '_doc', map);\n};\n\n/*!\n * Returns an array of values from object `o`.\n *\n * @param {Object} o\n * @return {Array}\n * @private\n */\n\nexports.object = {};\nexports.object.vals = function vals(o) {\n  var keys = Object.keys(o),\n      i = keys.length,\n      ret = [];\n\n  while (i--) {\n    ret.push(o[keys[i]]);\n  }\n\n  return ret;\n};\n\n/*!\n * @see exports.options\n */\n\nexports.object.shallowCopy = exports.options;\n\n/*!\n * Safer helper for hasOwnProperty checks\n *\n * @param {Object} obj\n * @param {String} prop\n */\n\nvar hop = Object.prototype.hasOwnProperty;\nexports.object.hasOwnProperty = function(obj, prop) {\n  return hop.call(obj, prop);\n};\n\n/*!\n * Determine if `val` is null or undefined\n *\n * @return {Boolean}\n */\n\nexports.isNullOrUndefined = function(val) {\n  return val === null || val === undefined;\n};\n\n/*!\n * ignore\n */\n\nexports.array = {};\n\n/*!\n * Flattens an array.\n *\n * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]\n *\n * @param {Array} arr\n * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsey value, the item will not be included in the results.\n * @return {Array}\n * @private\n */\n\nexports.array.flatten = function flatten(arr, filter, ret) {\n  ret || (ret = []);\n\n  arr.forEach(function(item) {\n    if (Array.isArray(item)) {\n      flatten(item, filter, ret);\n    } else {\n      if (!filter || filter(item)) {\n        ret.push(item);\n      }\n    }\n  });\n\n  return ret;\n};\n\n/*!\n * Removes duplicate values from an array\n *\n * [1, 2, 3, 3, 5] => [1, 2, 3, 5]\n * [ ObjectId(\"550988ba0c19d57f697dc45e\"), ObjectId(\"550988ba0c19d57f697dc45e\") ]\n *    => [ObjectId(\"550988ba0c19d57f697dc45e\")]\n *\n * @param {Array} arr\n * @return {Array}\n * @private\n */\n\nexports.array.unique = function(arr) {\n  var primitives = {};\n  var ids = {};\n  var ret = [];\n  var length = arr.length;\n  for (var i = 0; i < length; ++i) {\n    if (typeof arr[i] === 'number' || typeof arr[i] === 'string') {\n      if (primitives[arr[i]]) {\n        continue;\n      }\n      ret.push(arr[i]);\n      primitives[arr[i]] = true;\n    } else if (arr[i] instanceof ObjectId) {\n      if (ids[arr[i].toString()]) {\n        continue;\n      }\n      ret.push(arr[i]);\n      ids[arr[i].toString()] = true;\n    } else {\n      ret.push(arr[i]);\n    }\n  }\n\n  return ret;\n};\n\n/*!\n * Determines if two buffers are equal.\n *\n * @param {Buffer} a\n * @param {Object} b\n */\n\nexports.buffer = {};\nexports.buffer.areEqual = function(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    return false;\n  }\n  if (!Buffer.isBuffer(b)) {\n    return false;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (var i = 0, len = a.length; i < len; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexports.getFunctionName = function(fn) {\n  if (fn.name) {\n    return fn.name;\n  }\n  return (fn.toString().trim().match(/^function\\s*([^\\s(]+)/) || [])[1];\n};\n\nexports.decorate = function(destination, source) {\n  for (var key in source) {\n    destination[key] = source[key];\n  }\n};\n\n/**\n * merges to with a copy of from\n *\n * @param {Object} to\n * @param {Object} fromObj\n * @api private\n */\n\nexports.mergeClone = function(to, fromObj) {\n  var keys = Object.keys(fromObj);\n  var len = keys.length;\n  var i = 0;\n  var key;\n\n  while (i < len) {\n    key = keys[i++];\n    if (typeof to[key] === 'undefined') {\n      // make sure to retain key order here because of a bug handling the $each\n      // operator in mongodb 2.4.4\n      to[key] = exports.clone(fromObj[key], {retainKeyOrder: 1});\n    } else {\n      if (exports.isObject(fromObj[key])) {\n        var obj = fromObj[key];\n        if (isMongooseObject(fromObj[key]) && !fromObj[key].isMongooseBuffer) {\n          obj = obj.toObject({ transform: false, virtuals: false });\n        }\n        if (fromObj[key].isMongooseBuffer) {\n          obj = new Buffer(obj);\n        }\n        exports.mergeClone(to[key], obj);\n      } else {\n        // make sure to retain key order here because of a bug handling the\n        // $each operator in mongodb 2.4.4\n        to[key] = exports.clone(fromObj[key], {retainKeyOrder: 1});\n      }\n    }\n  }\n};\n\n/**\n * Executes a function on each element of an array (like _.each)\n *\n * @param {Array} arr\n * @param {Function} fn\n * @api private\n */\n\nexports.each = function(arr, fn) {\n  for (var i = 0; i < arr.length; ++i) {\n    fn(arr[i]);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/types/decimal128.js":"/**\n * ObjectId type constructor\n *\n * ####Example\n *\n *     var id = new mongoose.Types.ObjectId;\n *\n * @constructor ObjectId\n */\n\nmodule.exports = require('bson').Decimal128;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/types/objectid.js":"/**\n * ObjectId type constructor\n *\n * ####Example\n *\n *     var id = new mongoose.Types.ObjectId;\n *\n * @constructor ObjectId\n */\n\nvar ObjectId = require('../drivers').ObjectId;\n\nmodule.exports = ObjectId;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schematype.js":"/*!\n * Module dependencies.\n */\n\nvar $exists = require('./schema/operators/exists');\nvar $type = require('./schema/operators/type');\nvar utils = require('./utils');\nvar MongooseError = require('./error');\nvar CastError = MongooseError.CastError;\nvar ValidatorError = MongooseError.ValidatorError;\n\n/**\n * SchemaType constructor\n *\n * @param {String} path\n * @param {Object} [options]\n * @param {String} [instance]\n * @api public\n */\n\nfunction SchemaType(path, options, instance) {\n  this.path = path;\n  this.instance = instance;\n  this.validators = [];\n  this.setters = [];\n  this.getters = [];\n  this.options = options;\n  this._index = null;\n  this.selected;\n\n  for (var i in options) {\n    if (this[i] && typeof this[i] === 'function') {\n      // { unique: true, index: true }\n      if (i === 'index' && this._index) {\n        continue;\n      }\n\n      var opts = Array.isArray(options[i])\n          ? options[i]\n          : [options[i]];\n\n      this[i].apply(this, opts);\n    }\n  }\n}\n\n/**\n * Sets a default value for this SchemaType.\n *\n * ####Example:\n *\n *     var schema = new Schema({ n: { type: Number, default: 10 })\n *     var M = db.model('M', schema)\n *     var m = new M;\n *     console.log(m.n) // 10\n *\n * Defaults can be either `functions` which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.\n *\n * ####Example:\n *\n *     // values are cast:\n *     var schema = new Schema({ aNumber: { type: Number, default: 4.815162342 }})\n *     var M = db.model('M', schema)\n *     var m = new M;\n *     console.log(m.aNumber) // 4.815162342\n *\n *     // default unique objects for Mixed types:\n *     var schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default(function () {\n *       return {};\n *     });\n *\n *     // if we don't use a function to return object literals for Mixed defaults,\n *     // each document will receive a reference to the same object literal creating\n *     // a \"shared\" object instance:\n *     var schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default({});\n *     var M = db.model('M', schema);\n *     var m1 = new M;\n *     m1.mixed.added = 1;\n *     console.log(m1.mixed); // { added: 1 }\n *     var m2 = new M;\n *     console.log(m2.mixed); // { added: 1 }\n *\n * @param {Function|any} val the default value\n * @return {defaultValue}\n * @api public\n */\n\nSchemaType.prototype.default = function(val) {\n  if (arguments.length === 1) {\n    if (val === void 0) {\n      this.defaultValue = void 0;\n      return void 0;\n    }\n    this.defaultValue = val;\n    return this.defaultValue;\n  } else if (arguments.length > 1) {\n    this.defaultValue = utils.args(arguments);\n  }\n  return this.defaultValue;\n};\n\n/**\n * Declares the index options for this schematype.\n *\n * ####Example:\n *\n *     var s = new Schema({ name: { type: String, index: true })\n *     var s = new Schema({ loc: { type: [Number], index: 'hashed' })\n *     var s = new Schema({ loc: { type: [Number], index: '2d', sparse: true })\n *     var s = new Schema({ loc: { type: [Number], index: { type: '2dsphere', sparse: true }})\n *     var s = new Schema({ date: { type: Date, index: { unique: true, expires: '1d' }})\n *     Schema.path('my.path').index(true);\n *     Schema.path('my.date').index({ expires: 60 });\n *     Schema.path('my.path').index({ unique: true, sparse: true });\n *\n * ####NOTE:\n *\n * _Indexes are created in the background by default. Specify `background: false` to override._\n *\n * [Direction doesn't matter for single key indexes](http://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeysIndexes)\n *\n * @param {Object|Boolean|String} options\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.index = function(options) {\n  this._index = options;\n  utils.expires(this._index);\n  return this;\n};\n\n/**\n * Declares an unique index.\n *\n * ####Example:\n *\n *     var s = new Schema({ name: { type: String, unique: true }});\n *     Schema.path('name').index({ unique: true });\n *\n * _NOTE: violating the constraint returns an `E11000` error from MongoDB when saving, not a Mongoose validation error._\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.unique = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `unique` set to true');\n  }\n  if (this._index == null || this._index === true) {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = {type: this._index};\n  }\n\n  this._index.unique = bool;\n  return this;\n};\n\n/**\n * Declares a full text index.\n *\n * ###Example:\n *\n *      var s = new Schema({name : {type: String, text : true })\n *      Schema.path('name').index({text : true});\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.text = function(bool) {\n  if (this._index === null || this._index === undefined ||\n    typeof this._index === 'boolean') {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = {type: this._index};\n  }\n\n  this._index.text = bool;\n  return this;\n};\n\n/**\n * Declares a sparse index.\n *\n * ####Example:\n *\n *     var s = new Schema({ name: { type: String, sparse: true })\n *     Schema.path('name').index({ sparse: true });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.sparse = function(bool) {\n  if (this._index === null || this._index === undefined ||\n    typeof this._index === 'boolean') {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = {type: this._index};\n  }\n\n  this._index.sparse = bool;\n  return this;\n};\n\n/**\n * Adds a setter to this schematype.\n *\n * ####Example:\n *\n *     function capitalize (val) {\n *       if (typeof val !== 'string') val = '';\n *       return val.charAt(0).toUpperCase() + val.substring(1);\n *     }\n *\n *     // defining within the schema\n *     var s = new Schema({ name: { type: String, set: capitalize }})\n *\n *     // or by retreiving its SchemaType\n *     var s = new Schema({ name: String })\n *     s.path('name').set(capitalize)\n *\n * Setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.\n *\n * Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.\n *\n * You can set up email lower case normalization easily via a Mongoose setter.\n *\n *     function toLower (v) {\n *       return v.toLowerCase();\n *     }\n *\n *     var UserSchema = new Schema({\n *       email: { type: String, set: toLower }\n *     })\n *\n *     var User = db.model('User', UserSchema)\n *\n *     var user = new User({email: 'AVENUE@Q.COM'})\n *     console.log(user.email); // 'avenue@q.com'\n *\n *     // or\n *     var user = new User\n *     user.email = 'Avenue@Q.com'\n *     console.log(user.email) // 'avenue@q.com'\n *\n * As you can see above, setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.\n *\n * _NOTE: we could have also just used the built-in `lowercase: true` SchemaType option instead of defining our own function._\n *\n *     new Schema({ email: { type: String, lowercase: true }})\n *\n * Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return val;\n *       }\n *     }\n *\n *     var VirusSchema = new Schema({\n *       name: { type: String, required: true, set: inspector },\n *       taxonomy: { type: String, set: inspector }\n *     })\n *\n *     var Virus = db.model('Virus', VirusSchema);\n *     var v = new Virus({ name: 'Parvoviridae', taxonomy: 'Parvovirinae' });\n *\n *     console.log(v.name);     // name is required\n *     console.log(v.taxonomy); // Parvovirinae\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.set = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('A setter must be a function.');\n  }\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Adds a getter to this schematype.\n *\n * ####Example:\n *\n *     function dob (val) {\n *       if (!val) return val;\n *       return (val.getMonth() + 1) + \"/\" + val.getDate() + \"/\" + val.getFullYear();\n *     }\n *\n *     // defining within the schema\n *     var s = new Schema({ born: { type: Date, get: dob })\n *\n *     // or by retreiving its SchemaType\n *     var s = new Schema({ born: Date })\n *     s.path('born').get(dob)\n *\n * Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.\n *\n * Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:\n *\n *     function obfuscate (cc) {\n *       return '****-****-****-' + cc.slice(cc.length-4, cc.length);\n *     }\n *\n *     var AccountSchema = new Schema({\n *       creditCardNumber: { type: String, get: obfuscate }\n *     });\n *\n *     var Account = db.model('Account', AccountSchema);\n *\n *     Account.findById(id, function (err, found) {\n *       console.log(found.creditCardNumber); // '****-****-****-1234'\n *     });\n *\n * Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return schematype.path + ' is not';\n *       }\n *     }\n *\n *     var VirusSchema = new Schema({\n *       name: { type: String, required: true, get: inspector },\n *       taxonomy: { type: String, get: inspector }\n *     })\n *\n *     var Virus = db.model('Virus', VirusSchema);\n *\n *     Virus.findById(id, function (err, virus) {\n *       console.log(virus.name);     // name is required\n *       console.log(virus.taxonomy); // taxonomy is not\n *     })\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.get = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('A getter must be a function.');\n  }\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Adds validator(s) for this document path.\n *\n * Validators always receive the value to validate as their first argument and must return `Boolean`. Returning `false` means validation failed.\n *\n * The error message argument is optional. If not passed, the [default generic error message template](#error_messages_MongooseError-messages) will be used.\n *\n * ####Examples:\n *\n *     // make sure every value is equal to \"something\"\n *     function validator (val) {\n *       return val == 'something';\n *     }\n *     new Schema({ name: { type: String, validate: validator }});\n *\n *     // with a custom error message\n *\n *     var custom = [validator, 'Uh oh, {PATH} does not equal \"something\".']\n *     new Schema({ name: { type: String, validate: custom }});\n *\n *     // adding many validators at a time\n *\n *     var many = [\n *         { validator: validator, msg: 'uh oh' }\n *       , { validator: anotherValidator, msg: 'failed' }\n *     ]\n *     new Schema({ name: { type: String, validate: many }});\n *\n *     // or utilizing SchemaType methods directly:\n *\n *     var schema = new Schema({ name: 'string' });\n *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');\n *\n * ####Error message templates:\n *\n * From the examples above, you may have noticed that error messages support basic templating. There are a few other template keywords besides `{PATH}` and `{VALUE}` too. To find out more, details are available [here](#error_messages_MongooseError.messages)\n *\n * ####Asynchronous validation:\n *\n * Passing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either `true` or `false` to communicate either success or failure respectively.\n *\n *     schema.path('name').validate({\n *       isAsync: true,\n *       validator: function (value, respond) {\n *         doStuff(value, function () {\n *           ...\n *           respond(false); // validation failed\n *         });\n *       },\n *       message: 'Custom error message!' // Optional\n *     });\n *\n *     // Can also return a promise\n *     schema.path('name').validate({\n *       isAsync: true,\n *       validator: function (value, respond) {\n *         return new Promise(resolve => {\n *           resolve(false); // validation failed\n *         });\n *       }\n *     });\n *\n * You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.\n *\n * Validation occurs `pre('save')` or whenever you manually execute [document#validate](#document_Document-validate).\n *\n * If validation fails during `pre('save')` and no callback was passed to receive the error, an `error` event will be emitted on your Models associated db [connection](#connection_Connection), passing the validation error object along.\n *\n *     var conn = mongoose.createConnection(..);\n *     conn.on('error', handleError);\n *\n *     var Product = conn.model('Product', yourSchema);\n *     var dvd = new Product(..);\n *     dvd.save(); // emits error on the `conn` above\n *\n * If you desire handling these errors at the Model level, attach an `error` listener to your Model and the event will instead be emitted there.\n *\n *     // registering an error listener on the Model lets us handle errors more locally\n *     Product.on('error', handleError);\n *\n * @param {RegExp|Function|Object} obj validator\n * @param {String} [errorMsg] optional error message\n * @param {String} [type] optional validator type\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.validate = function(obj, message, type) {\n  if (typeof obj === 'function' || obj && utils.getFunctionName(obj.constructor) === 'RegExp') {\n    var properties;\n    if (message instanceof Object && !type) {\n      properties = utils.clone(message);\n      if (!properties.message) {\n        properties.message = properties.msg;\n      }\n      properties.validator = obj;\n      properties.type = properties.type || 'user defined';\n    } else {\n      if (!message) {\n        message = MongooseError.messages.general.default;\n      }\n      if (!type) {\n        type = 'user defined';\n      }\n      properties = {message: message, type: type, validator: obj};\n    }\n    this.validators.push(properties);\n    return this;\n  }\n\n  var i,\n      length,\n      arg;\n\n  for (i = 0, length = arguments.length; i < length; i++) {\n    arg = arguments[i];\n    if (!(arg && utils.getFunctionName(arg.constructor) === 'Object')) {\n      var msg = 'Invalid validator. Received (' + typeof arg + ') '\n          + arg\n          + '. See http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate';\n\n      throw new Error(msg);\n    }\n    this.validate(arg.validator, arg);\n  }\n\n  return this;\n};\n\n/**\n * Adds a required validator to this SchemaType. The validator gets added\n * to the front of this SchemaType's validators array using `unshift()`.\n *\n * ####Example:\n *\n *     var s = new Schema({ born: { type: Date, required: true })\n *\n *     // or with custom error message\n *\n *     var s = new Schema({ born: { type: Date, required: '{PATH} is required!' })\n *\n *     // or with a function\n *\n *     var s = new Schema({\n *       userId: ObjectId,\n *       username: {\n *         type: String,\n *         required: function() { return this.userId != null; }\n *       }\n *     })\n *\n *     // or with a function and a custom message\n *     var s = new Schema({\n *       userId: ObjectId,\n *       username: {\n *         type: String,\n *         required: [\n *           function() { return this.userId != null; },\n *           'username is required if id is specified'\n *         ]\n *       }\n *     })\n *\n *     // or through the path API\n *\n *     Schema.path('name').required(true);\n *\n *     // with custom error messaging\n *\n *     Schema.path('name').required(true, 'grrr :( ');\n *\n *     // or make a path conditionally required based on a function\n *     var isOver18 = function() { return this.age >= 18; };\n *     Schema.path('voterRegistrationId').required(isOver18);\n *\n * The required validator uses the SchemaType's `checkRequired` function to\n * determine whether a given value satisfies the required validator. By default,\n * a value satisfies the required validator if `val != null` (that is, if\n * the value is not null nor undefined). However, most built-in mongoose schema\n * types override the default `checkRequired` function:\n *\n * @param {Boolean} required enable/disable the validator\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @see SchemaArray#checkRequired #schema_array_SchemaArray.checkRequired\n * @see SchemaBoolean#checkRequired #schema_boolean_SchemaBoolean-checkRequired\n * @see SchemaBuffer#checkRequired #schema_buffer_SchemaBuffer.schemaName\n * @see SchemaNumber#checkRequired #schema_number_SchemaNumber-min\n * @see SchemaObjectId#checkRequired #schema_objectid_ObjectId-auto\n * @see SchemaString#checkRequired #schema_string_SchemaString-checkRequired\n * @api public\n */\n\nSchemaType.prototype.required = function(required, message) {\n  if (required === false) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.requiredValidator;\n    }, this);\n\n    this.isRequired = false;\n    return this;\n  }\n\n  var _this = this;\n  this.isRequired = true;\n\n  this.requiredValidator = function(v) {\n    // in here, `this` refers to the validating document.\n    // no validation when this path wasn't selected in the query.\n    if ('isSelected' in this && !this.isSelected(_this.path) && !this.isModified(_this.path)) {\n      return true;\n    }\n\n    return ((typeof required === 'function') && !required.apply(this)) ||\n        _this.checkRequired(v, this);\n  };\n  this.originalRequiredValue = required;\n\n  if (typeof required === 'string') {\n    message = required;\n    required = undefined;\n  }\n\n  var msg = message || MongooseError.messages.general.required;\n  this.validators.unshift({\n    validator: this.requiredValidator,\n    message: msg,\n    type: 'required'\n  });\n\n  return this;\n};\n\n/**\n * Gets the default value\n *\n * @param {Object} scope the scope which callback are executed\n * @param {Boolean} init\n * @api private\n */\n\nSchemaType.prototype.getDefault = function(scope, init) {\n  var ret = typeof this.defaultValue === 'function'\n      ? this.defaultValue.call(scope)\n      : this.defaultValue;\n\n  if (ret !== null && ret !== undefined) {\n    var casted = this.cast(ret, scope, init);\n    if (casted && casted.$isSingleNested) {\n      casted.$parent = scope;\n    }\n    return casted;\n  }\n  return ret;\n};\n\n/**\n * Applies setters\n *\n * @param {Object} value\n * @param {Object} scope\n * @param {Boolean} init\n * @api private\n */\n\nSchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {\n  var v = value,\n      setters = this.setters,\n      len = setters.length,\n      caster = this.caster;\n\n  while (len--) {\n    v = setters[len].call(scope, v, this);\n  }\n\n  if (Array.isArray(v) && caster && caster.setters) {\n    var newVal = [];\n    for (var i = 0; i < v.length; i++) {\n      newVal.push(caster.applySetters(v[i], scope, init, priorVal));\n    }\n    v = newVal;\n  }\n\n  if (v === null || v === undefined) {\n    return v;\n  }\n\n  // do not cast until all setters are applied #665\n  v = this.cast(v, scope, init, priorVal, options);\n\n  return v;\n};\n\n/**\n * Applies getters to a value\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaType.prototype.applyGetters = function(value, scope) {\n  var v = value,\n      getters = this.getters,\n      len = getters.length;\n\n  if (!len) {\n    return v;\n  }\n\n  while (len--) {\n    v = getters[len].call(scope, v, this);\n  }\n\n  return v;\n};\n\n/**\n * Sets default `select()` behavior for this path.\n *\n * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.\n *\n * ####Example:\n *\n *     T = db.model('T', new Schema({ x: { type: String, select: true }}));\n *     T.find(..); // field x will always be selected ..\n *     // .. unless overridden;\n *     T.find().select('-x').exec(callback);\n *\n * @param {Boolean} val\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.select = function select(val) {\n  this.selected = !!val;\n  return this;\n};\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * @param {any} value\n * @param {Function} callback\n * @param {Object} scope\n * @api private\n */\n\nSchemaType.prototype.doValidate = function(value, fn, scope) {\n  var err = false;\n  var path = this.path;\n  var count = this.validators.length;\n\n  if (!count) {\n    return fn(null);\n  }\n\n  var validate = function(ok, validatorProperties) {\n    if (err) {\n      return;\n    }\n    if (ok === undefined || ok) {\n      --count || fn(null);\n    } else {\n      err = new ValidatorError(validatorProperties);\n      fn(err);\n    }\n  };\n\n  var _this = this;\n  this.validators.forEach(function(v) {\n    if (err) {\n      return;\n    }\n\n    var validator = v.validator;\n    var ok;\n\n    var validatorProperties = utils.clone(v);\n    validatorProperties.path = path;\n    validatorProperties.value = value;\n\n    if (validator instanceof RegExp) {\n      validate(validator.test(value), validatorProperties);\n    } else if (typeof validator === 'function') {\n      if (value === undefined && !_this.isRequired) {\n        validate(true, validatorProperties);\n        return;\n      }\n      if (validatorProperties.isAsync) {\n        asyncValidate(validator, scope, value, validatorProperties, validate);\n      } else if (validator.length === 2 && !('isAsync' in validatorProperties)) {\n        legacyAsyncValidate(validator, scope, value, validatorProperties,\n          validate);\n      } else {\n        try {\n          ok = validator.call(scope, value);\n        } catch (error) {\n          ok = false;\n          validatorProperties.reason = error;\n        }\n        if (ok && typeof ok.then === 'function') {\n          ok.then(\n            function(ok) { validate(ok, validatorProperties); },\n            function(error) {\n              validatorProperties.reason = error;\n              ok = false;\n              validate(ok, validatorProperties);\n            });\n        } else {\n          validate(ok, validatorProperties);\n        }\n      }\n    }\n  });\n};\n\n/*!\n * Handle async validators\n */\n\nfunction asyncValidate(validator, scope, value, props, cb) {\n  var returnVal = validator.call(scope, value, function(ok, customMsg) {\n    if (typeof returnVal === 'boolean') {\n      return;\n    }\n    if (customMsg) {\n      props.message = customMsg;\n    }\n    cb(ok, props);\n  });\n  if (typeof returnVal === 'boolean') {\n    cb(returnVal, props);\n  }\n}\n\nvar legacyAsyncValidate = require('util').deprecate(asyncValidate,\n  'Implicit async custom validators (custom validators that take 2 ' +\n  'arguments) are deprecated in mongoose >= 4.9.0. See ' +\n  'http://mongoosejs.com/docs/validation.html#async-custom-validators for ' +\n  'more info.');\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @param {any} value\n * @param {Object} scope\n * @return {MongooseError|undefined}\n * @api private\n */\n\nSchemaType.prototype.doValidateSync = function(value, scope) {\n  var err = null,\n      path = this.path,\n      count = this.validators.length;\n\n  if (!count) {\n    return null;\n  }\n\n  var validate = function(ok, validatorProperties) {\n    if (err) {\n      return;\n    }\n    if (ok !== undefined && !ok) {\n      err = new ValidatorError(validatorProperties);\n    }\n  };\n\n  var validators = this.validators;\n  if (value === void 0) {\n    if (this.validators.length > 0 && this.validators[0].type === 'required') {\n      validators = [this.validators[0]];\n    } else {\n      return null;\n    }\n  }\n\n  validators.forEach(function(v) {\n    if (err) {\n      return;\n    }\n\n    var validator = v.validator;\n    var validatorProperties = utils.clone(v);\n    validatorProperties.path = path;\n    validatorProperties.value = value;\n    var ok;\n\n    if (validator instanceof RegExp) {\n      validate(validator.test(value), validatorProperties);\n    } else if (typeof validator === 'function') {\n      // if not async validators\n      if (validator.length !== 2 && !validatorProperties.isAsync) {\n        try {\n          ok = validator.call(scope, value);\n        } catch (error) {\n          ok = false;\n          validatorProperties.reason = error;\n        }\n        validate(ok, validatorProperties);\n      }\n    }\n  });\n\n  return err;\n};\n\n/**\n * Determines if value is a valid Reference.\n *\n * @param {SchemaType} self\n * @param {Object} value\n * @param {Document} doc\n * @param {Boolean} init\n * @return {Boolean}\n * @api private\n */\n\nSchemaType._isRef = function(self, value, doc, init) {\n  // fast path\n  var ref = init && self.options && self.options.ref;\n\n  if (!ref && doc && doc.$__fullPath) {\n    // checks for\n    // - this populated with adhoc model and no ref was set in schema OR\n    // - setting / pushing values after population\n    var path = doc.$__fullPath(self.path);\n    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    ref = owner.populated(path);\n  }\n\n  if (ref) {\n    if (value == null) {\n      return true;\n    }\n    if (!Buffer.isBuffer(value) &&  // buffers are objects too\n        value._bsontype !== 'Binary' // raw binary value from the db\n        && utils.isObject(value)    // might have deselected _id in population query\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.castForQuery(val);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val) {\n  var _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(val)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(m);\n  });\n}\n\n/*!\n * ignore\n */\n\nSchemaType.prototype.$conditionalHandlers = {\n  $all: handleArray,\n  $eq: handleSingle,\n  $in: handleArray,\n  $ne: handleSingle,\n  $nin: handleArray,\n  $exists: $exists,\n  $type: $type\n};\n\n/**\n * Cast the given value with the given optional query operator.\n *\n * @param {String} [$conditional] query operator, like `$eq` or `$in`\n * @param {any} val\n * @api private\n */\n\nSchemaType.prototype.castForQuery = function($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  return this.cast(val);\n};\n\n/**\n * Default check for if this path satisfies the `required` validator.\n *\n * @param {any} val\n * @api private\n */\n\nSchemaType.prototype.checkRequired = function(val) {\n  return val != null;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = SchemaType;\n\nexports.CastError = CastError;\n\nexports.ValidatorError = ValidatorError;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/operators/exists.js":"'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  if (typeof val !== 'boolean') {\n    throw new Error('$exists parameter must be a boolean!');\n  }\n\n  return val;\n};\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/operators/type.js":"'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  if (typeof val !== 'number' && typeof val !== 'string') {\n    throw new Error('$type parameter must be number or string');\n  }\n\n  return val;\n};\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error.js":"\n/**\n * MongooseError constructor\n *\n * @param {String} msg Error message\n * @inherits Error https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error\n */\n\nfunction MongooseError(msg) {\n  Error.call(this);\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.message = msg;\n  this.name = 'MongooseError';\n}\n\n/*!\n * Inherits from Error.\n */\n\nMongooseError.prototype = Object.create(Error.prototype);\nMongooseError.prototype.constructor = Error;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseError;\n\n/**\n * The default built-in validator error messages.\n *\n * @see Error.messages #error_messages_MongooseError-messages\n * @api public\n */\n\nMongooseError.messages = require('./error/messages');\n\n// backward compat\nMongooseError.Messages = MongooseError.messages;\n\n/*!\n * Expose subclasses\n */\n\nMongooseError.CastError = require('./error/cast');\nMongooseError.DocumentNotFoundError = require('./error/notFound');\nMongooseError.ValidationError = require('./error/validation');\nMongooseError.ValidatorError = require('./error/validator');\nMongooseError.VersionError = require('./error/version');\nMongooseError.OverwriteModelError = require('./error/overwriteModel');\nMongooseError.MissingSchemaError = require('./error/missingSchema');\nMongooseError.DivergentArrayError = require('./error/divergentArray');\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error/messages.js":"\n/**\n * The default built-in validator error messages. These may be customized.\n *\n *     // customize within each schema or globally like so\n *     var mongoose = require('mongoose');\n *     mongoose.Error.messages.String.enum  = \"Your custom message for {PATH}.\";\n *\n * As you might have noticed, error messages support basic templating\n *\n * - `{PATH}` is replaced with the invalid document path\n * - `{VALUE}` is replaced with the invalid value\n * - `{TYPE}` is replaced with the validator type such as \"regexp\", \"min\", or \"user defined\"\n * - `{MIN}` is replaced with the declared min value for the Number.min validator\n * - `{MAX}` is replaced with the declared max value for the Number.max validator\n *\n * Click the \"show code\" link below to see all defaults.\n *\n * @static messages\n * @receiver MongooseError\n * @api public\n */\n\nvar msg = module.exports = exports = {};\n\nmsg.general = {};\nmsg.general.default = 'Validator failed for path `{PATH}` with value `{VALUE}`';\nmsg.general.required = 'Path `{PATH}` is required.';\n\nmsg.Number = {};\nmsg.Number.min = 'Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).';\nmsg.Number.max = 'Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).';\n\nmsg.Date = {};\nmsg.Date.min = 'Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).';\nmsg.Date.max = 'Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).';\n\nmsg.String = {};\nmsg.String.enum = '`{VALUE}` is not a valid enum value for path `{PATH}`.';\nmsg.String.match = 'Path `{PATH}` is invalid ({VALUE}).';\nmsg.String.minlength = 'Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).';\nmsg.String.maxlength = 'Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).';\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error/cast.js":"/*!\n * Module dependencies.\n */\n\nvar MongooseError = require('../error.js');\nvar util = require('util');\n\n/**\n * Casting Error constructor.\n *\n * @param {String} type\n * @param {String} value\n * @inherits MongooseError\n * @api private\n */\n\nfunction CastError(type, value, path, reason) {\n  var stringValue = util.inspect(value);\n  stringValue = stringValue.replace(/^'/, '\"').replace(/'$/, '\"');\n  if (stringValue.charAt(0) !== '\"') {\n    stringValue = '\"' + stringValue + '\"';\n  }\n  MongooseError.call(this, 'Cast to ' + type + ' failed for value ' +\n    stringValue + ' at path \"' + path + '\"');\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.stringValue = stringValue;\n  this.name = 'CastError';\n  this.kind = type;\n  this.value = value;\n  this.path = path;\n  this.reason = reason;\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nCastError.prototype = Object.create(MongooseError.prototype);\nCastError.prototype.constructor = MongooseError;\n\n/*!\n * ignore\n */\n\nCastError.prototype.setModel = function(model) {\n  this.model = model;\n  this.message = 'Cast to ' + this.kind + ' failed for value ' +\n    this.stringValue + ' at path \"' + this.path + '\"' + ' for model \"' +\n    model.modelName + '\"';\n};\n\n/*!\n * exports\n */\n\nmodule.exports = CastError;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error/notFound.js":"'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar MongooseError = require('../error.js');\nvar util = require('util');\n\n/*!\n * OverwriteModel Error constructor.\n *\n * @inherits MongooseError\n */\n\nfunction DocumentNotFoundError(query) {\n  MongooseError.call(this, 'No document found for query \"' +\n    util.inspect(query) + '\"');\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n\n  this.name = 'DocumentNotFoundError';\n  this.query = query;\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nDocumentNotFoundError.prototype = Object.create(MongooseError.prototype);\nDocumentNotFoundError.prototype.constructor = MongooseError;\n\n/*!\n * exports\n */\n\nmodule.exports = DocumentNotFoundError;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error/validation.js":"/*!\n * Module requirements\n */\n\nvar MongooseError = require('../error.js');\n\n/**\n * Document Validation Error\n *\n * @api private\n * @param {Document} instance\n * @inherits MongooseError\n */\n\nfunction ValidationError(instance) {\n  this.errors = {};\n  if (instance && instance.constructor.name === 'model') {\n    MongooseError.call(this, instance.constructor.modelName + ' validation failed');\n  } else {\n    MongooseError.call(this, 'Validation failed');\n  }\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.name = 'ValidationError';\n  if (instance) {\n    instance.errors = this.errors;\n  }\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nValidationError.prototype = Object.create(MongooseError.prototype);\nValidationError.prototype.constructor = MongooseError;\n\n\n/**\n * Console.log helper\n */\n\nValidationError.prototype.toString = function() {\n  var ret = this.name + ': ';\n  var msgs = [];\n\n  Object.keys(this.errors || {}).forEach(function(key) {\n    if (this === this.errors[key]) {\n      return;\n    }\n    msgs.push(String(this.errors[key]));\n  }, this);\n\n  return ret + msgs.join(', ');\n};\n\n/*!\n * Module exports\n */\n\nmodule.exports = exports = ValidationError;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error/validator.js":"/*!\n * Module dependencies.\n */\n\nvar MongooseError = require('../error.js');\n\n/**\n * Schema validator error\n *\n * @param {Object} properties\n * @inherits MongooseError\n * @api private\n */\n\nfunction ValidatorError(properties) {\n  var msg = properties.message;\n  if (!msg) {\n    msg = MongooseError.messages.general.default;\n  }\n\n  var message = this.formatMessage(msg, properties);\n  MongooseError.call(this, message);\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.properties = properties;\n  this.name = 'ValidatorError';\n  this.kind = properties.type;\n  this.path = properties.path;\n  this.value = properties.value;\n  this.reason = properties.reason;\n}\n\n/*!\n * Inherits from MongooseError\n */\n\nValidatorError.prototype = Object.create(MongooseError.prototype);\nValidatorError.prototype.constructor = MongooseError;\n\n/*!\n * The object used to define this validator. Not enumerable to hide\n * it from `require('util').inspect()` output re: gh-3925\n */\n\nObject.defineProperty(ValidatorError.prototype, 'properties', {\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/*!\n * Formats error messages\n */\n\nValidatorError.prototype.formatMessage = function(msg, properties) {\n  var propertyNames = Object.keys(properties);\n  for (var i = 0; i < propertyNames.length; ++i) {\n    var propertyName = propertyNames[i];\n    if (propertyName === 'message') {\n      continue;\n    }\n    msg = msg.replace('{' + propertyName.toUpperCase() + '}', properties[propertyName]);\n  }\n  return msg;\n};\n\n/*!\n * toString helper\n */\n\nValidatorError.prototype.toString = function() {\n  return this.message;\n};\n\n/*!\n * exports\n */\n\nmodule.exports = ValidatorError;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error/version.js":"'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar MongooseError = require('../error.js');\n\n/**\n * Version Error constructor.\n *\n * @inherits MongooseError\n * @api private\n */\n\nfunction VersionError(doc) {\n  MongooseError.call(this, 'No matching document found for id \"' + doc._id +\n    '\"');\n  this.name = 'VersionError';\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nVersionError.prototype = Object.create(MongooseError.prototype);\nVersionError.prototype.constructor = MongooseError;\n\n/*!\n * exports\n */\n\nmodule.exports = VersionError;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error/overwriteModel.js":"\n/*!\n * Module dependencies.\n */\n\nvar MongooseError = require('../error.js');\n\n/*!\n * OverwriteModel Error constructor.\n *\n * @inherits MongooseError\n */\n\nfunction OverwriteModelError(name) {\n  MongooseError.call(this, 'Cannot overwrite `' + name + '` model once compiled.');\n  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);\n  this.name = 'OverwriteModelError';\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nOverwriteModelError.prototype = Object.create(MongooseError.prototype);\nOverwriteModelError.prototype.constructor = MongooseError;\n\n/*!\n * exports\n */\n\nmodule.exports = OverwriteModelError;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error/missingSchema.js":"\n/*!\n * Module dependencies.\n */\n\nvar MongooseError = require('../error.js');\n\n/*!\n * MissingSchema Error constructor.\n *\n * @inherits MongooseError\n */\n\nfunction MissingSchemaError(name) {\n  var msg = 'Schema hasn\\'t been registered for model \"' + name + '\".\\n'\n          + 'Use mongoose.model(name, schema)';\n  MongooseError.call(this, msg);\n  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);\n  this.name = 'MissingSchemaError';\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nMissingSchemaError.prototype = Object.create(MongooseError.prototype);\nMissingSchemaError.prototype.constructor = MongooseError;\n\n/*!\n * exports\n */\n\nmodule.exports = MissingSchemaError;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error/divergentArray.js":"\n/*!\n * Module dependencies.\n */\n\nvar MongooseError = require('../error.js');\n\n/*!\n * DivergentArrayError constructor.\n *\n * @inherits MongooseError\n */\n\nfunction DivergentArrayError(paths) {\n  var msg = 'For your own good, using `document.save()` to update an array '\n          + 'which was selected using an $elemMatch projection OR '\n          + 'populated using skip, limit, query conditions, or exclusion of '\n          + 'the _id field when the operation results in a $pop or $set of '\n          + 'the entire array is not supported. The following '\n          + 'path(s) would have been modified unsafely:\\n'\n          + '  ' + paths.join('\\n  ') + '\\n'\n          + 'Use Model.update() to update these arrays instead.';\n          // TODO write up a docs page (FAQ) and link to it\n\n  MongooseError.call(this, msg);\n  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);\n  this.name = 'DivergentArrayError';\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nDivergentArrayError.prototype = Object.create(MongooseError.prototype);\nDivergentArrayError.prototype.constructor = MongooseError;\n\n\n/*!\n * exports\n */\n\nmodule.exports = DivergentArrayError;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/index.js":"\n/*!\n * Module exports.\n */\n\nexports.String = require('./string');\n\nexports.Number = require('./number');\n\nexports.Boolean = require('./boolean');\n\nexports.DocumentArray = require('./documentarray');\n\nexports.Embedded = require('./embedded');\n\nexports.Array = require('./array');\n\nexports.Buffer = require('./buffer');\n\nexports.Date = require('./date');\n\nexports.ObjectId = require('./objectid');\n\nexports.Mixed = require('./mixed');\n\nexports.Decimal128 = exports.Decimal = require('./decimal128');\n\n// alias\n\nexports.Oid = exports.ObjectId;\nexports.Object = exports.Mixed;\nexports.Bool = exports.Boolean;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/string.js":"/*!\n * Module dependencies.\n */\n\nvar SchemaType = require('../schematype');\nvar CastError = SchemaType.CastError;\nvar MongooseError = require('../error');\nvar utils = require('../utils');\nvar Document;\n\n/**\n * String SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaString(key, options) {\n  this.enumValues = [];\n  this.regExp = null;\n  SchemaType.call(this, key, options, 'String');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaString.schemaName = 'String';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaString.prototype = Object.create(SchemaType.prototype);\nSchemaString.prototype.constructor = SchemaString;\n\n/**\n * Adds an enum validator\n *\n * ####Example:\n *\n *     var states = ['opening', 'open', 'closing', 'closed']\n *     var s = new Schema({ state: { type: String, enum: states }})\n *     var M = db.model('M', s)\n *     var m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n *     // or with custom error messages\n *     var enum = {\n *       values: ['opening', 'open', 'closing', 'closed'],\n *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'\n *     }\n *     var s = new Schema({ state: { type: String, enum: enum })\n *     var M = db.model('M', s)\n *     var m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaString.prototype.enum = function() {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.enumValidator;\n    }, this);\n    this.enumValidator = false;\n  }\n\n  if (arguments[0] === void 0 || arguments[0] === false) {\n    return this;\n  }\n\n  var values;\n  var errorMessage;\n\n  if (utils.isObject(arguments[0])) {\n    values = arguments[0].values;\n    errorMessage = arguments[0].message;\n  } else {\n    values = arguments;\n    errorMessage = MongooseError.messages.String.enum;\n  }\n\n  for (var i = 0; i < values.length; i++) {\n    if (undefined !== values[i]) {\n      this.enumValues.push(this.cast(values[i]));\n    }\n  }\n\n  var vals = this.enumValues;\n  this.enumValidator = function(v) {\n    return undefined === v || ~vals.indexOf(v);\n  };\n  this.validators.push({\n    validator: this.enumValidator,\n    message: errorMessage,\n    type: 'enum',\n    enumValues: vals\n  });\n\n  return this;\n};\n\n/**\n * Adds a lowercase setter.\n *\n * ####Example:\n *\n *     var s = new Schema({ email: { type: String, lowercase: true }})\n *     var M = db.model('M', s);\n *     var m = new M({ email: 'SomeEmail@example.COM' });\n *     console.log(m.email) // someemail@example.com\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.lowercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(function(v, self) {\n    if (typeof v !== 'string') {\n      v = self.cast(v);\n    }\n    if (v) {\n      return v.toLowerCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds an uppercase setter.\n *\n * ####Example:\n *\n *     var s = new Schema({ caps: { type: String, uppercase: true }})\n *     var M = db.model('M', s);\n *     var m = new M({ caps: 'an example' });\n *     console.log(m.caps) // AN EXAMPLE\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.uppercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(function(v, self) {\n    if (typeof v !== 'string') {\n      v = self.cast(v);\n    }\n    if (v) {\n      return v.toUpperCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds a trim setter.\n *\n * The string value will be trimmed when set.\n *\n * ####Example:\n *\n *     var s = new Schema({ name: { type: String, trim: true }})\n *     var M = db.model('M', s)\n *     var string = ' some name '\n *     console.log(string.length) // 11\n *     var m = new M({ name: string })\n *     console.log(m.name.length) // 9\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.trim = function(shouldTrim) {\n  if (arguments.length > 0 && !shouldTrim) {\n    return this;\n  }\n  return this.set(function(v, self) {\n    if (typeof v !== 'string') {\n      v = self.cast(v);\n    }\n    if (v) {\n      return v.trim();\n    }\n    return v;\n  });\n};\n\n/**\n * Sets a minimum length validator.\n *\n * ####Example:\n *\n *     var schema = new Schema({ postalCode: { type: String, minlength: 5 })\n *     var Address = db.model('Address', schema)\n *     var address = new Address({ postalCode: '9512' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length\n *     var minlength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];\n *     var schema = new Schema({ postalCode: { type: String, minlength: minlength })\n *     var Address = mongoose.model('Address', schema);\n *     var address = new Address({ postalCode: '9512' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).\n *     })\n *\n * @param {Number} value minimum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaString.prototype.minlength = function(value, message) {\n  if (this.minlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    var msg = message || MongooseError.messages.String.minlength;\n    msg = msg.replace(/{MINLENGTH}/, value);\n    this.validators.push({\n      validator: this.minlengthValidator = function(v) {\n        return v === null || v.length >= value;\n      },\n      message: msg,\n      type: 'minlength',\n      minlength: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum length validator.\n *\n * ####Example:\n *\n *     var schema = new Schema({ postalCode: { type: String, maxlength: 9 })\n *     var Address = db.model('Address', schema)\n *     var address = new Address({ postalCode: '9512512345' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length\n *     var maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];\n *     var schema = new Schema({ postalCode: { type: String, maxlength: maxlength })\n *     var Address = mongoose.model('Address', schema);\n *     var address = new Address({ postalCode: '9512512345' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (9).\n *     })\n *\n * @param {Number} value maximum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaString.prototype.maxlength = function(value, message) {\n  if (this.maxlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    var msg = message || MongooseError.messages.String.maxlength;\n    msg = msg.replace(/{MAXLENGTH}/, value);\n    this.validators.push({\n      validator: this.maxlengthValidator = function(v) {\n        return v === null || v.length <= value;\n      },\n      message: msg,\n      type: 'maxlength',\n      maxlength: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a regexp validator.\n *\n * Any value that does not pass `regExp`.test(val) will fail validation.\n *\n * ####Example:\n *\n *     var s = new Schema({ name: { type: String, match: /^a/ }})\n *     var M = db.model('M', s)\n *     var m = new M({ name: 'I am invalid' })\n *     m.validate(function (err) {\n *       console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"\n *       m.name = 'apples'\n *       m.validate(function (err) {\n *         assert.ok(err) // success\n *       })\n *     })\n *\n *     // using a custom error message\n *     var match = [ /\\.html$/, \"That file doesn't end in .html ({VALUE})\" ];\n *     var s = new Schema({ file: { type: String, match: match }})\n *     var M = db.model('M', s);\n *     var m = new M({ file: 'invalid' });\n *     m.validate(function (err) {\n *       console.log(String(err)) // \"ValidationError: That file doesn't end in .html (invalid)\"\n *     })\n *\n * Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.\n *\n *     var s = new Schema({ name: { type: String, match: /^a/, required: true }})\n *\n * @param {RegExp} regExp regular expression to test against\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaString.prototype.match = function match(regExp, message) {\n  // yes, we allow multiple match validators\n\n  var msg = message || MongooseError.messages.String.match;\n\n  var matchValidator = function(v) {\n    if (!regExp) {\n      return false;\n    }\n\n    var ret = ((v != null && v !== '')\n        ? regExp.test(v)\n        : true);\n    return ret;\n  };\n\n  this.validators.push({\n    validator: matchValidator,\n    message: msg,\n    type: 'regexp',\n    regexp: regExp\n  });\n  return this;\n};\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaString.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return (value instanceof String || typeof value === 'string') && value.length;\n};\n\n/**\n * Casts to String\n *\n * @api private\n */\n\nSchemaString.prototype.cast = function(value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = require('./../document'));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (typeof value === 'string') {\n      return value;\n    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {\n      throw new CastError('string', value, this.path);\n    }\n\n    // Handle the case where user directly sets a populated\n    // path to a plain object; cast to the Model used in\n    // the population query.\n    var path = doc.$__fullPath(this.path);\n    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    var pop = owner.populated(path, true);\n    var ret = new pop.options.model(value);\n    ret.$__.wasPopulated = true;\n    return ret;\n  }\n\n  // If null or undefined\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (typeof value !== 'undefined') {\n    // handle documents being passed\n    if (value._id && typeof value._id === 'string') {\n      return value._id;\n    }\n\n    // Re: gh-647 and gh-3030, we're ok with casting using `toString()`\n    // **unless** its the default Object.toString, because \"[object Object]\"\n    // doesn't really qualify as useful data\n    if (value.toString && value.toString !== Object.prototype.toString) {\n      return value.toString();\n    }\n  }\n\n  throw new CastError('string', value, this.path);\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.castForQuery(val);\n}\n\nfunction handleArray(val) {\n  var _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(val)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(m);\n  });\n}\n\nSchemaString.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $all: handleArray,\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle,\n      $options: handleSingle,\n      $regex: handleSingle,\n      $not: handleSingle\n    });\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [val]\n * @api private\n */\n\nSchemaString.prototype.castForQuery = function($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with String.');\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  if (Object.prototype.toString.call(val) === '[object RegExp]') {\n    return val;\n  }\n  return this.cast(val);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaString;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/number.js":"/*!\n * Module requirements.\n */\n\nvar SchemaType = require('../schematype');\nvar CastError = SchemaType.CastError;\nvar handleBitwiseOperator = require('./operators/bitwise');\nvar MongooseError = require('../error');\nvar utils = require('../utils');\nvar Document;\n\n/**\n * Number SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaNumber(key, options) {\n  SchemaType.call(this, key, options, 'Number');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaNumber.schemaName = 'Number';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaNumber.prototype = Object.create(SchemaType.prototype);\nSchemaNumber.prototype.constructor = SchemaNumber;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return typeof value === 'number' || value instanceof Number;\n};\n\n/**\n * Sets a minimum number validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ n: { type: Number, min: 10 })\n *     var M = db.model('M', s)\n *     var m = new M({ n: 9 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     var min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     var schema = new Schema({ n: { type: Number, min: min })\n *     var M = mongoose.model('Measurement', schema);\n *     var s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n *     })\n *\n * @param {Number} value minimum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaNumber.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    var msg = message || MongooseError.messages.Number.min;\n    msg = msg.replace(/{MIN}/, value);\n    this.validators.push({\n      validator: this.minValidator = function(v) {\n        return v == null || v >= value;\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum number validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ n: { type: Number, max: 10 })\n *     var M = db.model('M', s)\n *     var m = new M({ n: 11 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     var max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     var schema = new Schema({ n: { type: Number, max: max })\n *     var M = mongoose.model('Measurement', schema);\n *     var s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n *     })\n *\n * @param {Number} maximum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaNumber.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    var msg = message || MongooseError.messages.Number.max;\n    msg = msg.replace(/{MAX}/, value);\n    this.validators.push({\n      validator: this.maxValidator = function(v) {\n        return v == null || v <= value;\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to number\n *\n * @param {Object} value value to cast\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaNumber.prototype.cast = function(value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = require('./../document'));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (typeof value === 'number') {\n      return value;\n    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {\n      throw new CastError('number', value, this.path);\n    }\n\n    // Handle the case where user directly sets a populated\n    // path to a plain object; cast to the Model used in\n    // the population query.\n    var path = doc.$__fullPath(this.path);\n    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    var pop = owner.populated(path, true);\n    var ret = new pop.options.model(value);\n    ret.$__.wasPopulated = true;\n    return ret;\n  }\n\n  var val = value && typeof value._id !== 'undefined' ?\n    value._id : // documents\n    value;\n\n  if (!isNaN(val)) {\n    if (val === null) {\n      return val;\n    }\n    if (val === '') {\n      return null;\n    }\n    if (typeof val === 'string' || typeof val === 'boolean') {\n      val = Number(val);\n    }\n    if (val instanceof Number) {\n      return val;\n    }\n    if (typeof val === 'number') {\n      return val;\n    }\n    if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {\n      return new Number(val);\n    }\n  }\n\n  throw new CastError('number', value, this.path);\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nfunction handleArray(val) {\n  var _this = this;\n  if (!Array.isArray(val)) {\n    return [this.cast(val)];\n  }\n  return val.map(function(m) {\n    return _this.cast(m);\n  });\n}\n\nSchemaNumber.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $bitsAllClear: handleBitwiseOperator,\n      $bitsAnyClear: handleBitwiseOperator,\n      $bitsAllSet: handleBitwiseOperator,\n      $bitsAnySet: handleBitwiseOperator,\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle,\n      $mod: handleArray\n    });\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaNumber.prototype.castForQuery = function($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Number.');\n    }\n    return handler.call(this, val);\n  }\n  val = this.cast($conditional);\n  return val;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaNumber;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/operators/bitwise.js":"/*!\n * Module requirements.\n */\n\nvar CastError = require('../../error/cast');\n\n/*!\n * ignore\n */\n\nfunction handleBitwiseOperator(val) {\n  var _this = this;\n  if (Array.isArray(val)) {\n    return val.map(function(v) {\n      return _castNumber(_this.path, v);\n    });\n  } else if (Buffer.isBuffer(val)) {\n    return val;\n  }\n  // Assume trying to cast to number\n  return _castNumber(_this.path, val);\n}\n\n/*!\n * ignore\n */\n\nfunction _castNumber(path, num) {\n  var v = Number(num);\n  if (isNaN(v)) {\n    throw new CastError('number', num, path);\n  }\n  return v;\n}\n\nmodule.exports = handleBitwiseOperator;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/boolean.js":"/*!\n * Module dependencies.\n */\n\nvar utils = require('../utils');\n\nvar SchemaType = require('../schematype');\n\n/**\n * Boolean SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBoolean(path, options) {\n  SchemaType.call(this, path, options, 'Boolean');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBoolean.schemaName = 'Boolean';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBoolean.prototype = Object.create(SchemaType.prototype);\nSchemaBoolean.prototype.constructor = SchemaBoolean;\n\n/**\n * Check if the given value satisfies a required validator. For a boolean\n * to satisfy a required validator, it must be strictly equal to true or to\n * false.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaBoolean.prototype.checkRequired = function(value) {\n  return value === true || value === false;\n};\n\n/**\n * Casts to boolean\n *\n * @param {Object} value\n * @api private\n */\n\nSchemaBoolean.prototype.cast = function(value) {\n  if (value === null) {\n    return value;\n  }\n  if (value === '0') {\n    return false;\n  }\n  if (value === 'true') {\n    return true;\n  }\n  if (value === 'false') {\n    return false;\n  }\n  return !!value;\n};\n\nSchemaBoolean.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaBoolean.prototype.castForQuery = function($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = SchemaBoolean.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this.cast(val);\n  }\n\n  return this.cast($conditional);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBoolean;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/documentarray.js":"/* eslint no-empty: 1 */\n\n/*!\n * Module dependencies.\n */\n\nvar ArrayType = require('./array');\nvar CastError = require('../error/cast');\nvar EventEmitter = require('events').EventEmitter;\nvar MongooseDocumentArray = require('../types/documentarray');\nvar SchemaType = require('../schematype');\nvar Subdocument = require('../types/embedded');\nvar applyHooks = require('../services/model/applyHooks');\nvar discriminator = require('../services/model/discriminator');\nvar util = require('util');\nvar utils = require('../utils');\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArray(key, schema, options) {\n  var EmbeddedDocument = _createConstructor(schema, options);\n\n  ArrayType.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.$isMongooseDocumentArray = true;\n  var fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      var arr = fn.call(this);\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDocumentArray.schemaName = 'DocumentArray';\n\n/*!\n * Inherits from ArrayType.\n */\nDocumentArray.prototype = Object.create(ArrayType.prototype);\nDocumentArray.prototype.constructor = DocumentArray;\n\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options) {\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n  }\n\n  EmbeddedDocument.prototype = Object.create(Subdocument.prototype);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n\n  // apply methods\n  for (var i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  applyHooks(EmbeddedDocument, schema);\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/*!\n * Ignore\n */\n\nDocumentArray.prototype.discriminator = function(name, schema) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema);\n\n  var EmbeddedDocument = _createConstructor(schema);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nDocumentArray.prototype.doValidate = function(array, fn, scope, options) {\n  var _this = this;\n  SchemaType.prototype.doValidate.call(this, array, function(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    var count = array && array.length;\n    var error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n\n    for (var i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      var doc = array[i];\n      if (!doc) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        doc = array[i] = new _this.casterConstructor(doc, array, undefined,\n            undefined, i);\n      }\n\n      // HACK: use $__original_validate to avoid promises so bluebird doesn't\n      // complain\n      if (doc.$__original_validate) {\n        doc.$__original_validate({__noPromise: true}, callback);\n      } else {\n        doc.validate({__noPromise: true}, callback);\n      }\n    }\n  }, scope);\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nDocumentArray.prototype.doValidateSync = function(array, scope) {\n  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError) {\n    return schemaTypeError;\n  }\n\n  var count = array && array.length,\n      resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (var i = 0, len = count; i < len; ++i) {\n    // only first error\n    if (resultError) {\n      break;\n    }\n    // sidestep sparse entries\n    var doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    var subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nDocumentArray.prototype.cast = function(value, doc, init, prev, options) {\n  var selected,\n      subdoc,\n      i;\n\n  if (!Array.isArray(value)) {\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init, prev);\n  }\n\n  if (!(value && value.isMongooseDocumentArray) &&\n      (!options || !options.skipDocumentArrayCast)) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n    if (prev && prev._handlers) {\n      for (var key in prev._handlers) {\n        doc.removeListener(key, prev._handlers[key]);\n      }\n    }\n  } else if (value && value.isMongooseDocumentArray) {\n    // We need to create a new array, otherwise change tracking will\n    // update the old doc (gh-4449)\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  i = value.length;\n\n  while (i--) {\n    if (!value[i]) {\n      continue;\n    }\n\n    var Constructor = this.casterConstructor;\n    if (Constructor.discriminators &&\n        typeof value[i][Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[value[i][Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[value[i][Constructor.schema.options.discriminatorKey]];\n    }\n\n    // Check if the document has a different schema (re gh-3701)\n    if ((value[i] instanceof Subdocument) &&\n        value[i].schema !== Constructor.schema) {\n      value[i] = value[i].toObject({ transform: false, virtuals: false });\n    }\n    if (!(value[i] instanceof Subdocument) && value[i]) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, true, selected, i);\n        value[i] = subdoc.init(value[i]);\n      } else {\n        if (prev && (subdoc = prev.id(value[i]._id))) {\n          subdoc = prev.id(value[i]._id);\n        }\n\n        if (prev && subdoc) {\n          // handle resetting doc with existing id but differing data\n          // doc.array = [{ doc: 'val' }]\n          subdoc.set(value[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          value[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(value[i], value, undefined,\n                undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            value[i] = subdoc;\n          } catch (error) {\n            var valueInErrorMessage = util.inspect(value[i]);\n            throw new CastError('embedded', valueInErrorMessage,\n              value._path, error);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArray} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  var path = array.path + '.';\n  var keys = Object.keys(fields);\n  var i = keys.length;\n  var selected = {};\n  var hasKeys;\n  var key;\n  var sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.indexOf(path) === 0) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.indexOf('$.') === 0) {\n        sub = sub.substr(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArray;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/array.js":"/*!\n * Module dependencies.\n */\n\nvar $exists = require('./operators/exists');\nvar $type = require('./operators/type');\nvar SchemaType = require('../schematype');\nvar CastError = SchemaType.CastError;\nvar Types = {\n  Boolean: require('./boolean'),\n  Date: require('./date'),\n  Number: require('./number'),\n  String: require('./string'),\n  ObjectId: require('./objectid'),\n  Buffer: require('./buffer')\n};\nvar MongooseArray = require('../types').Array;\nvar EmbeddedDoc = require('../types').Embedded;\nvar Mixed = require('./mixed');\nvar cast = require('../cast');\nvar util = require('util');\nvar utils = require('../utils');\nvar castToNumber = require('./operators/helpers').castToNumber;\nvar geospatial = require('./operators/geospatial');\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  var typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n\n  if (cast) {\n    var castOptions = {};\n\n    if (utils.getFunctionName(cast.constructor) === 'Object') {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    // support { type: 'String' }\n    var name = typeof cast === 'string'\n        ? cast\n        : utils.getFunctionName(cast);\n\n    var caster = name in Types\n        ? Types[name]\n        : cast;\n\n    this.casterConstructor = caster;\n    if (typeof caster === 'function') {\n      this.caster = new caster(null, castOptions);\n    } else {\n      this.caster = caster;\n    }\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  SchemaType.call(this, key, options, 'Array');\n\n  var defaultArr;\n  var fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    this.default(function() {\n      var arr = [];\n      if (fn) {\n        arr = defaultArr();\n      } else if (defaultArr != null) {\n        arr = defaultArr;\n      }\n      // Leave it up to `cast()` to convert the array\n      return arr;\n    });\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\n\n/**\n * Check if the given value satisfies a required validator. The given value\n * must be not null nor undefined, and have a positive length.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function(value) {\n  return !!(value && value.length);\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init) {\n  if (Array.isArray(value)) {\n    if (!value.length && doc) {\n      var indexes = doc.schema.indexedPaths();\n\n      for (var i = 0, l = indexes.length; i < l; ++i) {\n        var pathIndex = indexes[i][0][this.path];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n    }\n\n    if (!(value && value.isMongooseArray)) {\n      value = new MongooseArray(value, this.path, doc);\n    } else if (value && value.isMongooseArray) {\n      // We need to create a new array, otherwise change tracking will\n      // update the old doc (gh-4449)\n      value = new MongooseArray(value, this.path, doc);\n    }\n\n    if (this.caster) {\n      try {\n        for (i = 0, l = value.length; i < l; i++) {\n          value[i] = this.caster.cast(value[i], doc, init);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e);\n      }\n    }\n\n    return value;\n  }\n  // gh-2442: if we're loading this from the db and its not an array, mark\n  // the whole array as modified.\n  if (!!doc && !!init) {\n    doc.markModified(this.path);\n  }\n  return this.cast([value], doc, init);\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, value) {\n  var handler,\n      val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    var Constructor = this.casterConstructor;\n\n    if (val &&\n        Constructor.discriminators &&\n        Constructor.schema.options.discriminatorKey &&\n        typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n    }\n\n    var proto = this.casterConstructor.prototype;\n    var method = proto && (proto.castForQuery || proto.cast);\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n    var caster = this.caster;\n\n    if (Array.isArray(val)) {\n      val = val.map(function(v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n        if (val != null) {\n          v = new Constructor(v);\n          return v;\n        }\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function(v) {\n    if (utils.isObject(v)) {\n      var o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n    return v;\n  }, this);\n\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  var keys = Object.keys(val);\n  var numKeys = keys.length;\n  var key;\n  var value;\n  for (var i = 0; i < numKeys; ++i) {\n    key = keys[i];\n    value = val[key];\n    if (key.indexOf('$') === 0 && value) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nvar handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = handle.$and = function(val) {\n  if (!Array.isArray(val)) {\n    throw new TypeError('conditional $or/$and require array');\n  }\n\n  var ret = [];\n  for (var i = 0; i < val.length; ++i) {\n    ret.push(cast(this.casterConstructor.schema, val[i]));\n  }\n\n  return ret;\n};\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$in =\nhandle.$lt =\nhandle.$lte =\nhandle.$ne =\nhandle.$nin =\nhandle.$regex = SchemaArray.prototype.castForQuery;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/date.js":"/*!\n * Module requirements.\n */\n\nvar MongooseError = require('../error');\nvar utils = require('../utils');\n\nvar SchemaType = require('../schematype');\n\nvar CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options) {\n  SchemaType.call(this, key, options, 'Date');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDate.schemaName = 'Date';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\n\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     var schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function(when) {\n  if (!this._index || this._index.constructor.name !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function(value) {\n  return value instanceof Date;\n};\n\n/**\n * Sets a minimum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     var schema = new Schema({ d: { type: Date, min: min })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaDate.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    var msg = message || MongooseError.messages.Date.min;\n    msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));\n    var _this = this;\n    this.validators.push({\n      validator: this.minValidator = function(val) {\n        var min = (value === Date.now ? value() : _this.cast(value));\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     var schema = new Schema({ d: { type: Date, max: max })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaDate.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    var msg = message || MongooseError.messages.Date.max;\n    msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));\n    var _this = this;\n    this.validators.push({\n      validator: this.maxValidator = function(val) {\n        var max = (value === Date.now ? value() : _this.cast(value));\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDate.prototype.cast = function(value) {\n  // If null or undefined\n  if (value === null || value === void 0 || value === '') {\n    return null;\n  }\n\n  if (value instanceof Date) {\n    if (isNaN(value.valueOf())) {\n      throw new CastError('date', value, this.path);\n    }\n\n    return value;\n  }\n\n  var date;\n\n  if (typeof value === 'boolean') {\n    throw new CastError('date', value, this.path);\n  }\n\n  if (value instanceof Number || typeof value === 'number'\n      || String(value) == Number(value)) {\n    // support for timestamps\n    date = new Date(Number(value));\n  } else if (value.valueOf) {\n    // support for moment.js\n    date = new Date(value.valueOf());\n  }\n\n  if (!isNaN(date.valueOf())) {\n    return date;\n  }\n\n  throw new CastError('date', value, this.path);\n};\n\n/*!\n * Date Query casting.\n *\n * @api private\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDate.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function($conditional, val) {\n  var handler;\n\n  if (arguments.length !== 2) {\n    return this.cast($conditional);\n  }\n\n  handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDate;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/objectid.js":"/* eslint no-empty: 1 */\n\n/*!\n * Module dependencies.\n */\n\nvar SchemaType = require('../schematype'),\n    CastError = SchemaType.CastError,\n    oid = require('../types/objectid'),\n    utils = require('../utils'),\n    Document;\n\n/**\n * ObjectId SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction ObjectId(key, options) {\n  SchemaType.call(this, key, options, 'ObjectID');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nObjectId.schemaName = 'ObjectId';\n\n/*!\n * Inherits from SchemaType.\n */\nObjectId.prototype = Object.create(SchemaType.prototype);\nObjectId.prototype.constructor = ObjectId;\n\n/**\n * Adds an auto-generated ObjectId default if turnOn is true.\n * @param {Boolean} turnOn auto generated ObjectId defaults\n * @api public\n * @return {SchemaType} this\n */\n\nObjectId.prototype.auto = function(turnOn) {\n  if (turnOn) {\n    this.default(defaultId);\n    this.set(resetId);\n  }\n\n  return this;\n};\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nObjectId.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return value instanceof oid;\n};\n\n/**\n * Casts to ObjectId\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nObjectId.prototype.cast = function(value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = require('./../document'));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (value instanceof oid) {\n      return value;\n    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {\n      throw new CastError('ObjectId', value, this.path);\n    }\n\n    // Handle the case where user directly sets a populated\n    // path to a plain object; cast to the Model used in\n    // the population query.\n    var path = doc.$__fullPath(this.path);\n    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    var pop = owner.populated(path, true);\n    var ret = value;\n    if (!doc.$__.populated ||\n        !doc.$__.populated[path] ||\n        !doc.$__.populated[path].options ||\n        !doc.$__.populated[path].options.options ||\n        !doc.$__.populated[path].options.options.lean) {\n      ret = new pop.options.model(value);\n      ret.$__.wasPopulated = true;\n    }\n\n    return ret;\n  }\n\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (value instanceof oid) {\n    return value;\n  }\n\n  if (value._id) {\n    if (value._id instanceof oid) {\n      return value._id;\n    }\n    if (value._id.toString instanceof Function) {\n      try {\n        return new oid(value._id.toString());\n      } catch (e) {\n      }\n    }\n  }\n\n  if (value.toString instanceof Function) {\n    try {\n      return new oid(value.toString());\n    } catch (err) {\n      throw new CastError('ObjectId', value, this.path);\n    }\n  }\n\n  throw new CastError('ObjectId', value, this.path);\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nObjectId.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [val]\n * @api private\n */\n\nObjectId.prototype.castForQuery = function($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with ObjectId.');\n    }\n    return handler.call(this, val);\n  }\n  return this.cast($conditional);\n};\n\n/*!\n * ignore\n */\n\nfunction defaultId() {\n  return new oid();\n}\n\nfunction resetId(v) {\n  this.$__._id = null;\n  return v;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = ObjectId;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/buffer.js":"/*!\n * Module dependencies.\n */\n\nvar handleBitwiseOperator = require('./operators/bitwise');\nvar utils = require('../utils');\n\nvar MongooseBuffer = require('../types').Buffer;\nvar SchemaType = require('../schematype');\n\nvar Binary = MongooseBuffer.Binary;\nvar CastError = SchemaType.CastError;\nvar Document;\n\n/**\n * Buffer SchemaType constructor\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBuffer(key, options) {\n  SchemaType.call(this, key, options, 'Buffer');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBuffer.schemaName = 'Buffer';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBuffer.prototype = Object.create(SchemaType.prototype);\nSchemaBuffer.prototype.constructor = SchemaBuffer;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy a\n * required validator, a buffer must not be null or undefined and have\n * non-zero length.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaBuffer.prototype.checkRequired = function(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return !!(value && value.length);\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaBuffer.prototype.cast = function(value, doc, init) {\n  var ret;\n  if (SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = require('./../document'));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (Buffer.isBuffer(value)) {\n      return value;\n    } else if (!utils.isObject(value)) {\n      throw new CastError('buffer', value, this.path);\n    }\n\n    // Handle the case where user directly sets a populated\n    // path to a plain object; cast to the Model used in\n    // the population query.\n    var path = doc.$__fullPath(this.path);\n    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    var pop = owner.populated(path, true);\n    ret = new pop.options.model(value);\n    ret.$__.wasPopulated = true;\n    return ret;\n  }\n\n  // documents\n  if (value && value._id) {\n    value = value._id;\n  }\n\n  if (value && value.isMongooseBuffer) {\n    return value;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    if (!value || !value.isMongooseBuffer) {\n      value = new MongooseBuffer(value, [this.path, doc]);\n    }\n\n    return value;\n  } else if (value instanceof Binary) {\n    ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n    if (typeof value.sub_type !== 'number') {\n      throw new CastError('buffer', value, this.path);\n    }\n    ret._subtype = value.sub_type;\n    return ret;\n  }\n\n  if (value === null) {\n    return value;\n  }\n\n  var type = typeof value;\n  if (type === 'string' || type === 'number' || Array.isArray(value)) {\n    if (type === 'number') {\n      value = [value];\n    }\n    ret = new MongooseBuffer(value, [this.path, doc]);\n    return ret;\n  }\n\n  throw new CastError('buffer', value, this.path);\n};\n\n/*!\n * ignore\n */\nfunction handleSingle(val) {\n  return this.castForQuery(val);\n}\n\nSchemaBuffer.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $bitsAllClear: handleBitwiseOperator,\n      $bitsAnyClear: handleBitwiseOperator,\n      $bitsAllSet: handleBitwiseOperator,\n      $bitsAnySet: handleBitwiseOperator,\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaBuffer.prototype.castForQuery = function($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Buffer.');\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  var casted = this.cast(val);\n  return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBuffer;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/types/index.js":"\n/*!\n * Module exports.\n */\n\nexports.Array = require('./array');\nexports.Buffer = require('./buffer');\n\nexports.Document = // @deprecate\nexports.Embedded = require('./embedded');\n\nexports.DocumentArray = require('./documentarray');\nexports.Decimal128 = require('./decimal128');\nexports.ObjectId = require('./objectid');\n\nexports.Subdocument = require('./subdocument');\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/types/array.js":"/*!\n * Module dependencies.\n */\n\nvar EmbeddedDocument = require('./embedded');\nvar Document = require('../document');\nvar ObjectId = require('./objectid');\nvar utils = require('../utils');\nvar isMongooseObject = utils.isMongooseObject;\n\n/**\n * Mongoose Array constructor.\n *\n * ####NOTE:\n *\n * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._\n *\n * @param {Array} values\n * @param {String} path\n * @param {Document} doc parent document\n * @api private\n * @inherits Array\n * @see http://bit.ly/f6CnZU\n */\n\nfunction MongooseArray(values, path, doc) {\n  var arr = [].concat(values);\n\n  var keysMA = Object.keys(MongooseArray.mixin);\n  var numKeys = keysMA.length;\n  for (var i = 0; i < numKeys; ++i) {\n    arr[keysMA[i]] = MongooseArray.mixin[keysMA[i]];\n  }\n\n  arr._path = path;\n  arr.isMongooseArray = true;\n  arr.validators = [];\n  arr._atomics = {};\n  arr._schema = void 0;\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc && doc instanceof Document) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n  }\n\n  return arr;\n}\n\nMongooseArray.mixin = {\n  /*!\n   * ignore\n   */\n  toBSON: function() {\n    return this.toObject({\n      transform: false,\n      virtuals: false,\n      _skipDepopulateTopLevel: true,\n      depopulate: true,\n      flattenDecimals: false\n    });\n  },\n\n  /**\n   * Stores a queue of atomic operations to perform\n   *\n   * @property _atomics\n   * @api private\n   */\n\n  _atomics: undefined,\n\n  /**\n   * Parent owner document\n   *\n   * @property _parent\n   * @api private\n   * @receiver MongooseArray\n   */\n\n  _parent: undefined,\n\n  /**\n   * Casts a member based on this arrays schema.\n   *\n   * @param {any} value\n   * @return value the casted value\n   * @method _cast\n   * @api private\n   * @receiver MongooseArray\n   */\n\n  _cast: function(value) {\n    var populated = false;\n    var Model;\n\n    if (this._parent) {\n      populated = this._parent.populated(this._path, true);\n    }\n\n    if (populated && value !== null && value !== undefined) {\n      // cast to the populated Models schema\n      Model = populated.options.model;\n\n      // only objects are permitted so we can safely assume that\n      // non-objects are to be interpreted as _id\n      if (Buffer.isBuffer(value) ||\n          value instanceof ObjectId || !utils.isObject(value)) {\n        value = {_id: value};\n      }\n\n      // gh-2399\n      // we should cast model only when it's not a discriminator\n      var isDisc = value.schema && value.schema.discriminatorMapping &&\n          value.schema.discriminatorMapping.key !== undefined;\n      if (!isDisc) {\n        value = new Model(value);\n      }\n      return this._schema.caster.cast(value, this._parent, true);\n    }\n\n    return this._schema.caster.cast(value, this._parent, false);\n  },\n\n  /**\n   * Marks this array as modified.\n   *\n   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)\n   *\n   * @param {EmbeddedDocument} embeddedDoc the embedded doc that invoked this method on the Array\n   * @param {String} embeddedPath the path which changed in the embeddedDoc\n   * @method _markModified\n   * @api private\n   * @receiver MongooseArray\n   */\n\n  _markModified: function(elem, embeddedPath) {\n    var parent = this._parent,\n        dirtyPath;\n\n    if (parent) {\n      dirtyPath = this._path;\n\n      if (arguments.length) {\n        if (embeddedPath != null) {\n          // an embedded doc bubbled up the change\n          dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;\n        } else {\n          // directly set an index\n          dirtyPath = dirtyPath + '.' + elem;\n        }\n      }\n\n      parent.markModified(dirtyPath);\n    }\n\n    return this;\n  },\n\n  /**\n   * Register an atomic operation with the parent.\n   *\n   * @param {Array} op operation\n   * @param {any} val\n   * @method _registerAtomic\n   * @api private\n   * @receiver MongooseArray\n   */\n\n  _registerAtomic: function(op, val) {\n    if (op === '$set') {\n      // $set takes precedence over all other ops.\n      // mark entire array modified.\n      this._atomics = {$set: val};\n      return this;\n    }\n\n    var atomics = this._atomics;\n\n    // reset pop/shift after save\n    if (op === '$pop' && !('$pop' in atomics)) {\n      var _this = this;\n      this._parent.once('save', function() {\n        _this._popped = _this._shifted = null;\n      });\n    }\n\n    // check for impossible $atomic combos (Mongo denies more than one\n    // $atomic op on a single path\n    if (this._atomics.$set ||\n        Object.keys(atomics).length && !(op in atomics)) {\n      // a different op was previously registered.\n      // save the entire thing.\n      this._atomics = {$set: this};\n      return this;\n    }\n\n    var selector;\n\n    if (op === '$pullAll' || op === '$pushAll' || op === '$addToSet') {\n      atomics[op] || (atomics[op] = []);\n      atomics[op] = atomics[op].concat(val);\n    } else if (op === '$pullDocs') {\n      var pullOp = atomics['$pull'] || (atomics['$pull'] = {});\n      if (val[0] instanceof EmbeddedDocument) {\n        selector = pullOp['$or'] || (pullOp['$or'] = []);\n        Array.prototype.push.apply(selector, val.map(function(v) {\n          return v.toObject({transform: false, virtuals: false});\n        }));\n      } else {\n        selector = pullOp['_id'] || (pullOp['_id'] = {$in: []});\n        selector['$in'] = selector['$in'].concat(val);\n      }\n    } else {\n      atomics[op] = val;\n    }\n\n    return this;\n  },\n\n  /**\n   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.\n   *\n   * If no atomics exist, we return all array values after conversion.\n   *\n   * @return {Array}\n   * @method $__getAtomics\n   * @memberOf MongooseArray\n   * @api private\n   */\n\n  $__getAtomics: function() {\n    var ret = [];\n    var keys = Object.keys(this._atomics);\n    var i = keys.length;\n\n    if (i === 0) {\n      ret[0] = ['$set', this.toObject({depopulate: 1, transform: false, _isNested: true, virtuals: false})];\n      return ret;\n    }\n\n    while (i--) {\n      var op = keys[i];\n      var val = this._atomics[op];\n\n      // the atomic values which are arrays are not MongooseArrays. we\n      // need to convert their elements as if they were MongooseArrays\n      // to handle populated arrays versus DocumentArrays properly.\n      if (isMongooseObject(val)) {\n        val = val.toObject({depopulate: 1, transform: false, _isNested: true, virtuals: false});\n      } else if (Array.isArray(val)) {\n        val = this.toObject.call(val, {depopulate: 1, transform: false, _isNested: true});\n      } else if (val.valueOf) {\n        val = val.valueOf();\n      }\n\n      if (op === '$addToSet') {\n        val = {$each: val};\n      }\n\n      ret.push([op, val]);\n    }\n\n    return ret;\n  },\n\n  /**\n   * Returns the number of pending atomic operations to send to the db for this array.\n   *\n   * @api private\n   * @return {Number}\n   * @method hasAtomics\n   * @receiver MongooseArray\n   */\n\n  hasAtomics: function hasAtomics() {\n    if (!(this._atomics && this._atomics.constructor.name === 'Object')) {\n      return 0;\n    }\n\n    return Object.keys(this._atomics).length;\n  },\n\n  /**\n   * Internal helper for .map()\n   *\n   * @api private\n   * @return {Number}\n   * @method _mapCast\n   * @receiver MongooseArray\n   */\n  _mapCast: function(val, index) {\n    return this._cast(val, this.length + index);\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * @param {Object} [args...]\n   * @api public\n   * @method push\n   * @receiver MongooseArray\n   */\n\n  push: function() {\n    var values = [].map.call(arguments, this._mapCast, this);\n    values = this._schema.applySetters(values, this._parent, undefined,\n        undefined, {skipDocumentArrayCast: true});\n    var ret = [].push.apply(this, values);\n\n    // $pushAll might be fibbed (could be $push). But it makes it easier to\n    // handle what could have been $push, $pushAll combos\n    this._registerAtomic('$pushAll', values);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pushes items to the array non-atomically.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @param {any} [args...]\n   * @api public\n   * @method nonAtomicPush\n   * @receiver MongooseArray\n   */\n\n  nonAtomicPush: function() {\n    var values = [].map.call(arguments, this._mapCast, this);\n    var ret = [].push.apply(this, values);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pops the array atomically at most one time per document `save()`.\n   *\n   * #### NOTE:\n   *\n   * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      var popped = doc.array.$pop();\n   *      console.log(popped); // 3\n   *      console.log(doc.array); // [1,2]\n   *\n   *      // no affect\n   *      popped = doc.array.$pop();\n   *      console.log(doc.array); // [1,2]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $pop works again\n   *        popped = doc.array.$pop();\n   *        console.log(popped); // 2\n   *        console.log(doc.array); // [1]\n   *      })\n   *\n   * @api public\n   * @method $pop\n   * @memberOf MongooseArray\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n   * @method $pop\n   * @receiver MongooseArray\n   */\n\n  $pop: function() {\n    this._registerAtomic('$pop', 1);\n    this._markModified();\n\n    // only allow popping once\n    if (this._popped) {\n      return;\n    }\n    this._popped = true;\n\n    return [].pop.call(this);\n  },\n\n  /**\n   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @see MongooseArray#$pop #types_array_MongooseArray-%24pop\n   * @api public\n   * @method pop\n   * @receiver MongooseArray\n   */\n\n  pop: function() {\n    var ret = [].pop.call(this);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Atomically shifts the array at most one time per document `save()`.\n   *\n   * ####NOTE:\n   *\n   * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      var shifted = doc.array.$shift();\n   *      console.log(shifted); // 1\n   *      console.log(doc.array); // [2,3]\n   *\n   *      // no affect\n   *      shifted = doc.array.$shift();\n   *      console.log(doc.array); // [2,3]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $shift works again\n   *        shifted = doc.array.$shift();\n   *        console.log(shifted ); // 2\n   *        console.log(doc.array); // [3]\n   *      })\n   *\n   * @api public\n   * @memberOf MongooseArray\n   * @method $shift\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n   */\n\n  $shift: function $shift() {\n    this._registerAtomic('$pop', -1);\n    this._markModified();\n\n    // only allow shifting once\n    if (this._shifted) {\n      return;\n    }\n    this._shifted = true;\n\n    return [].shift.call(this);\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Example:\n   *\n   *     doc.array = [2,3];\n   *     var res = doc.array.shift();\n   *     console.log(res) // 2\n   *     console.log(doc.array) // [3]\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method shift\n   * @receiver MongooseArray\n   */\n\n  shift: function() {\n    var ret = [].shift.call(this);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically. Equality is determined by casting\n   * the provided value to an embedded document and comparing using\n   * [the `Document.equals()` function.](./api.html#document_Document-equals)\n   *\n   * ####Examples:\n   *\n   *     doc.array.pull(ObjectId)\n   *     doc.array.pull({ _id: 'someId' })\n   *     doc.array.pull(36)\n   *     doc.array.pull('tag 1', 'tag 2')\n   *\n   * To remove a document from a subdocument array we may pass an object with a matching `_id`.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull({ _id: 4815162342 }) // removed\n   *\n   * Or we may passing the _id directly and let mongoose take care of it.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull(4815162342); // works\n   *\n   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.\n   *\n   * @param {any} [args...]\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n   * @api public\n   * @method pull\n   * @receiver MongooseArray\n   */\n\n  pull: function() {\n    var values = [].map.call(arguments, this._cast, this),\n        cur = this._parent.get(this._path),\n        i = cur.length,\n        mem;\n\n    while (i--) {\n      mem = cur[i];\n      if (mem instanceof Document) {\n        var some = values.some(function(v) {\n          return mem.equals(v);\n        });\n        if (some) {\n          [].splice.call(cur, i, 1);\n        }\n      } else if (~cur.indexOf.call(values, mem)) {\n        [].splice.call(cur, i, 1);\n      }\n    }\n\n    if (values[0] instanceof EmbeddedDocument) {\n      this._registerAtomic('$pullDocs', values.map(function(v) {\n        return v._id || v;\n      }));\n    } else {\n      this._registerAtomic('$pullAll', values);\n    }\n\n    this._markModified();\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method splice\n   * @receiver MongooseArray\n   */\n\n  splice: function splice() {\n    var ret, vals, i;\n\n    if (arguments.length) {\n      vals = [];\n      for (i = 0; i < arguments.length; ++i) {\n        vals[i] = i < 2\n            ? arguments[i]\n            : this._cast(arguments[i], arguments[0] + (i - 2));\n      }\n      ret = [].splice.apply(this, vals);\n      this._registerAtomic('$set', this);\n      this._markModified();\n    }\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method unshift\n   * @receiver MongooseArray\n   */\n\n  unshift: function() {\n    var values = [].map.call(arguments, this._cast, this);\n    values = this._schema.applySetters(values, this._parent);\n    [].unshift.apply(this, values);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return this.length;\n  },\n\n  /**\n   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method sort\n   * @receiver MongooseArray\n   */\n\n  sort: function() {\n    var ret = [].sort.apply(this, arguments);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Adds values to the array if not already present.\n   *\n   * ####Example:\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *     var added = doc.array.addToSet(4,5);\n   *     console.log(doc.array) // [2,3,4,5]\n   *     console.log(added)     // [5]\n   *\n   * @param {any} [args...]\n   * @return {Array} the values that were added\n   * @receiver MongooseArray\n   * @api public\n   * @method addToSet\n   */\n\n  addToSet: function addToSet() {\n    var values = [].map.call(arguments, this._mapCast, this);\n    values = this._schema.applySetters(values, this._parent);\n    var added = [];\n    var type = '';\n    if (values[0] instanceof EmbeddedDocument) {\n      type = 'doc';\n    } else if (values[0] instanceof Date) {\n      type = 'date';\n    }\n\n    values.forEach(function(v) {\n      var found;\n      switch (type) {\n        case 'doc':\n          found = this.some(function(doc) {\n            return doc.equals(v);\n          });\n          break;\n        case 'date':\n          var val = +v;\n          found = this.some(function(d) {\n            return +d === val;\n          });\n          break;\n        default:\n          found = ~this.indexOf(v);\n      }\n\n      if (!found) {\n        [].push.call(this, v);\n        this._registerAtomic('$addToSet', v);\n        this._markModified();\n        [].push.call(added, v);\n      }\n    }, this);\n\n    return added;\n  },\n\n  /**\n   * Sets the casted `val` at index `i` and marks the array modified.\n   *\n   * ####Example:\n   *\n   *     // given documents based on the following\n   *     var Doc = mongoose.model('Doc', new Schema({ array: [Number] }));\n   *\n   *     var doc = new Doc({ array: [2,3,4] })\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *\n   *     doc.array.set(1,\"5\");\n   *     console.log(doc.array); // [2,5,4] // properly cast to number\n   *     doc.save() // the change is saved\n   *\n   *     // VS not using array#set\n   *     doc.array[1] = \"5\";\n   *     console.log(doc.array); // [2,\"5\",4] // no casting\n   *     doc.save() // change is not saved\n   *\n   * @return {Array} this\n   * @api public\n   * @method set\n   * @receiver MongooseArray\n   */\n\n  set: function set(i, val) {\n    var value = this._cast(val, i);\n    value = this._schema.caster instanceof EmbeddedDocument ?\n        value :\n        this._schema.caster.applySetters(val, this._parent)\n    ;\n    this[i] = value;\n    this._markModified(i);\n    return this;\n  },\n\n  /**\n   * Returns a native js Array.\n   *\n   * @param {Object} options\n   * @return {Array}\n   * @api public\n   * @method toObject\n   * @receiver MongooseArray\n   */\n\n  toObject: function(options) {\n    if (options && options.depopulate) {\n      options._isNested = true;\n      return this.map(function(doc) {\n        return doc instanceof Document\n            ? doc.toObject(options)\n            : doc;\n      });\n    }\n\n    return this.slice();\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @api public\n   * @method inspect\n   * @receiver MongooseArray\n   */\n\n  inspect: function() {\n    return JSON.stringify(this);\n  },\n\n  /**\n   * Return the index of `obj` or `-1` if not found.\n   *\n   * @param {Object} obj the item to look for\n   * @return {Number}\n   * @api public\n   * @method indexOf\n   * @receiver MongooseArray\n   */\n\n  indexOf: function indexOf(obj) {\n    if (obj instanceof ObjectId) {\n      obj = obj.toString();\n    }\n    for (var i = 0, len = this.length; i < len; ++i) {\n      if (obj == this[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n};\n\n/**\n * Alias of [pull](#types_array_MongooseArray-pull)\n *\n * @see MongooseArray#pull #types_array_MongooseArray-pull\n * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n * @api public\n * @memberOf MongooseArray\n * @method remove\n */\n\nMongooseArray.mixin.remove = MongooseArray.mixin.pull;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseArray;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/types/embedded.js":"/* eslint no-func-assign: 1 */\n\n/*!\n * Module dependencies.\n */\n\nvar Document = require('../document_provider')();\nvar EventEmitter = require('events').EventEmitter;\nvar PromiseProvider = require('../promise_provider');\n\n/**\n * EmbeddedDocument constructor.\n *\n * @param {Object} obj js object returned from the db\n * @param {MongooseDocumentArray} parentArr the parent array of this document\n * @param {Boolean} skipId\n * @inherits Document\n * @api private\n */\n\nfunction EmbeddedDocument(obj, parentArr, skipId, fields, index) {\n  if (parentArr) {\n    this.__parentArray = parentArr;\n    this.__parent = parentArr._parent;\n  } else {\n    this.__parentArray = undefined;\n    this.__parent = undefined;\n  }\n  this.__index = index;\n\n  Document.call(this, obj, fields, skipId);\n\n  var _this = this;\n  this.on('isNew', function(val) {\n    _this.isNew = val;\n  });\n\n  _this.on('save', function() {\n    _this.constructor.emit('save', _this);\n  });\n}\n\n/*!\n * Inherit from Document\n */\nEmbeddedDocument.prototype = Object.create(Document.prototype);\nEmbeddedDocument.prototype.constructor = EmbeddedDocument;\n\nfor (var i in EventEmitter.prototype) {\n  EmbeddedDocument[i] = EventEmitter.prototype[i];\n}\n\nEmbeddedDocument.prototype.toBSON = function() {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n};\n\n/**\n * Marks the embedded doc modified.\n *\n * ####Example:\n *\n *     var doc = blogpost.comments.id(hexstring);\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *\n * @param {String} path the path which changed\n * @api public\n * @receiver EmbeddedDocument\n */\n\nEmbeddedDocument.prototype.markModified = function(path) {\n  this.$__.activePaths.modify(path);\n  if (!this.__parentArray) {\n    return;\n  }\n\n  if (this.isNew) {\n    // Mark the WHOLE parent array as modified\n    // if this is a new document (i.e., we are initializing\n    // a document),\n    this.__parentArray._markModified();\n  } else {\n    this.__parentArray._markModified(this, path);\n  }\n};\n\n/*!\n * ignore\n */\n\nEmbeddedDocument.prototype.populate = function() {\n  throw new Error('Mongoose does not support calling populate() on nested ' +\n    'docs. Instead of `doc.arr[0].populate(\"path\")`, use ' +\n    '`doc.populate(\"arr.0.path\")`');\n};\n\n/**\n * Used as a stub for [hooks.js](https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3)\n *\n * ####NOTE:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @return {Promise} resolved Promise\n * @api private\n */\n\nEmbeddedDocument.prototype.save = function(fn) {\n  var Promise = PromiseProvider.get();\n  return new Promise.ES6(function(resolve) {\n    fn && fn();\n    resolve();\n  });\n};\n\n/*!\n * Registers remove event listeners for triggering\n * on subdocuments.\n *\n * @param {EmbeddedDocument} sub\n * @api private\n */\n\nfunction registerRemoveListener(sub) {\n  var owner = sub.ownerDocument();\n\n  function emitRemove() {\n    owner.removeListener('save', emitRemove);\n    owner.removeListener('remove', emitRemove);\n    sub.emit('remove', sub);\n    sub.constructor.emit('remove', sub);\n    owner = sub = null;\n  }\n\n  owner.on('save', emitRemove);\n  owner.on('remove', emitRemove);\n}\n\n/**\n * Removes the subdocument from its parent array.\n *\n * @param {Object} [options]\n * @param {Function} [fn]\n * @api public\n */\n\nEmbeddedDocument.prototype.remove = function(options, fn) {\n  if ( typeof options === 'function' && !fn ) {\n    fn = options;\n    options = undefined;\n  }\n  if (!this.__parentArray || (options && options.noop)) {\n    fn && fn(null);\n    return this;\n  }\n\n  var _id;\n  if (!this.willRemove) {\n    _id = this._doc._id;\n    if (!_id) {\n      throw new Error('For your own good, Mongoose does not know ' +\n          'how to remove an EmbeddedDocument that has no _id');\n    }\n    this.__parentArray.pull({_id: _id});\n    this.willRemove = true;\n    registerRemoveListener(this);\n  }\n\n  if (fn) {\n    fn(null);\n  }\n\n  return this;\n};\n\n/**\n * Override #update method of parent documents.\n * @api private\n */\n\nEmbeddedDocument.prototype.update = function() {\n  throw new Error('The #update method is not available on EmbeddedDocuments');\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n */\n\nEmbeddedDocument.prototype.inspect = function() {\n  return this.toObject({ transform: false, retainKeyOrder: true, virtuals: false });\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * @param {String} path the field to invalidate\n * @param {String|Error} err error which states the reason `path` was invalid\n * @return {Boolean}\n * @api public\n */\n\nEmbeddedDocument.prototype.invalidate = function(path, err, val, first) {\n  if (!this.__parent) {\n    Document.prototype.invalidate.call(this, path, err, val);\n    if (err.name === 'ValidatorError') {\n      return true;\n    }\n    throw err;\n  }\n\n  var index = this.__index;\n  if (typeof index !== 'undefined') {\n    var parentPath = this.__parentArray._path;\n    var fullPath = [parentPath, index, path].join('.');\n    this.__parent.invalidate(fullPath, err, val);\n  }\n\n  if (first) {\n    this.$__.validationError = this.ownerDocument().$__.validationError;\n  }\n\n  return true;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api private\n * @method $markValid\n * @receiver EmbeddedDocument\n */\n\nEmbeddedDocument.prototype.$markValid = function(path) {\n  if (!this.__parent) {\n    return;\n  }\n\n  var index = this.__index;\n  if (typeof index !== 'undefined') {\n    var parentPath = this.__parentArray._path;\n    var fullPath = [parentPath, index, path].join('.');\n    this.__parent.$markValid(fullPath);\n  }\n};\n\n/**\n * Checks if a path is invalid\n *\n * @param {String} path the field to check\n * @api private\n * @method $isValid\n * @receiver EmbeddedDocument\n */\n\nEmbeddedDocument.prototype.$isValid = function(path) {\n  var index = this.__index;\n  if (typeof index !== 'undefined' && this.__parent) {\n    return !this.__parent.$__.validationError ||\n      !this.__parent.$__.validationError.errors[this.$__fullPath(path)];\n  }\n\n  return true;\n};\n\n/**\n * Returns the top level document of this sub-document.\n *\n * @return {Document}\n */\n\nEmbeddedDocument.prototype.ownerDocument = function() {\n  if (this.$__.ownerDocument) {\n    return this.$__.ownerDocument;\n  }\n\n  var parent = this.__parent;\n  if (!parent) {\n    return this;\n  }\n\n  while (parent.__parent || parent.$parent) {\n    parent = parent.__parent || parent.$parent;\n  }\n\n  this.$__.ownerDocument = parent;\n  return this.$__.ownerDocument;\n};\n\n/**\n * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf EmbeddedDocument\n */\n\nEmbeddedDocument.prototype.$__fullPath = function(path) {\n  if (!this.$__.fullPath) {\n    var parent = this; // eslint-disable-line consistent-this\n    if (!parent.__parent) {\n      return path;\n    }\n\n    var paths = [];\n    while (parent.__parent || parent.$parent) {\n      if (parent.__parent) {\n        paths.unshift(parent.__parentArray._path);\n      } else {\n        paths.unshift(parent.$basePath);\n      }\n      parent = parent.__parent || parent.$parent;\n    }\n\n    this.$__.fullPath = paths.join('.');\n\n    if (!this.$__.ownerDocument) {\n      // optimization\n      this.$__.ownerDocument = parent;\n    }\n  }\n\n  return path\n      ? this.$__.fullPath + '.' + path\n      : this.$__.fullPath;\n};\n\n/**\n * Returns this sub-documents parent document.\n *\n * @api public\n */\n\nEmbeddedDocument.prototype.parent = function() {\n  return this.__parent;\n};\n\n/**\n * Returns this sub-documents parent array.\n *\n * @api public\n */\n\nEmbeddedDocument.prototype.parentArray = function() {\n  return this.__parentArray;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = EmbeddedDocument;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/document_provider.js":"'use strict';\n\n/* eslint-env browser */\n\n/*!\n * Module dependencies.\n */\nvar Document = require('./document.js');\nvar BrowserDocument = require('./browserDocument.js');\n\n/**\n * Returns the Document constructor for the current context\n *\n * @api private\n */\nmodule.exports = function() {\n  if (typeof window !== 'undefined' && typeof document !== 'undefined' && document === window.document) {\n    return BrowserDocument;\n  }\n  return Document;\n};\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/document.js":"/*!\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar MongooseError = require('./error');\nvar MixedSchema = require('./schema/mixed');\nvar Schema = require('./schema');\nvar ObjectExpectedError = require('./error/objectExpected');\nvar StrictModeError = require('./error/strict');\nvar ValidatorError = require('./schematype').ValidatorError;\nvar utils = require('./utils');\nvar clone = utils.clone;\nvar isMongooseObject = utils.isMongooseObject;\nvar inspect = require('util').inspect;\nvar ValidationError = MongooseError.ValidationError;\nvar InternalCache = require('./internal');\nvar deepEqual = utils.deepEqual;\nvar hooks = require('hooks-fixed');\nvar PromiseProvider = require('./promise_provider');\nvar DocumentArray;\nvar MongooseArray;\nvar Embedded;\nvar flatten = require('./services/common').flatten;\nvar mpath = require('mpath');\n\n/**\n * Document constructor.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has was retreived from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId) {\n  this.$__ = new InternalCache;\n  this.$__.emitter = new EventEmitter();\n  this.isNew = true;\n  this.errors = undefined;\n\n  var schema = this.schema;\n\n  if (typeof fields === 'boolean') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options && schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  var required = schema.requiredPaths(true);\n  for (var i = 0; i < required.length; ++i) {\n    this.$__.activePaths.require(required[i]);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n  this._doc = this.$__buildDoc(obj, fields, skipId);\n\n  if (obj) {\n    if (obj instanceof Document) {\n      this.isNew = obj.isNew;\n    }\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true);\n    } else {\n      this.set(obj, undefined, true);\n    }\n  }\n\n  if (!schema.options.strict && obj) {\n    var _this = this,\n        keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      if (!(key in schema.tree)) {\n        defineKey(key, null, _this);\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n    ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n      'removeAllListeners', 'addListener'],\n    function(emitterFn) {\n      Document.prototype[emitterFn] = function() {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      };\n    });\n\nDocument.prototype.constructor = Document;\n\n/**\n * The documents schema.\n *\n * @api public\n * @property schema\n */\n\nDocument.prototype.schema;\n\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n */\n\nDocument.prototype.isNew;\n\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n */\n\nDocument.prototype.errors;\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @return {Object}\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === 'Object') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === '_id') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== '_id' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== 'object')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split('.');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join('.')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split('.');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = '';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb.\n *\n * @param {Object} doc document returned by mongo\n * @param {Function} fn callback\n * @api public\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit('init', this);\n  this.constructor.emit('init', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n};\n\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\nfunction init(self, obj, doc, prefix) {\n  prefix = prefix || '';\n\n  var keys = Object.keys(obj);\n  var len = keys.length;\n  var schema;\n  var path;\n  var i;\n  var index = 0;\n\n  if (self.schema.options.retainKeyOrder) {\n    while (index < len) {\n      _init(index++);\n    }\n  } else {\n    while (len--) {\n      _init(len);\n    }\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schema = self.schema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (self.schema.$isRootDiscriminator && !self.isSelected(path)) {\n      return;\n    }\n\n    if (!schema && utils.isObject(obj[i]) &&\n        (!obj[i].constructor || utils.getFunctionName(obj[i].constructor) === 'Object')) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n      init(self, obj[i], doc[i], path + '.');\n    } else if (!schema) {\n      doc[i] = obj[i];\n    } else {\n      if (obj[i] === null) {\n        doc[i] = null;\n      } else if (obj[i] !== undefined) {\n        if (schema) {\n          try {\n            doc[i] = schema.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Stores the current values of the shard keys.\n *\n * ####Note:\n *\n * _Shard key values do not / are not allowed to change._\n *\n * @api private\n * @method $__storeShard\n * @memberOf Document\n */\n\nDocument.prototype.$__storeShard = function() {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === 'Object')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don't take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== 'Date')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n};\n\n/*!\n * Set up middleware support\n */\n\nfor (var k in hooks) {\n  if (k === 'pre' || k === 'post') {\n    Document.prototype['$' + k] = Document['$' + k] = hooks[k];\n  } else {\n    Document.prototype[k] = Document[k] = hooks[k];\n  }\n}\n\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n */\n\nDocument.prototype.update = function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n};\n\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n */\n\nDocument.prototype.set = function(path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === 'Object') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && 'strict' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== 'string') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + '.'\n          : '';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === 'Object')\n        && pathtype !== 'virtual'\n        && pathtype !== 'real'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don't overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === 'real' || pathtype === 'virtual') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === 'nested' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === 'throw') {\n        if (pathtype === 'nested') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === 'nested' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === 'Object')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split('.');\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join('.');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join('.');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction cleanModifiedSubpaths(doc, path) {\n  var _modifiedPaths = Object.keys(doc.$__.activePaths.states.modify);\n  var _numModifiedPaths = _modifiedPaths.length;\n  for (var j = 0; j < _numModifiedPaths; ++j) {\n    if (_modifiedPaths[j].indexOf(path + '.') === 0) {\n      delete doc.$__.activePaths.states.modify[_modifiedPaths[j]];\n    }\n  }\n}\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n */\n\nDocument.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/embedded');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require('./types/array'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic('$set', val);\n\n      // Small hack for gh-1638: if we're overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + '.') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = '';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === 'Object') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\nDocument.prototype.getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\nDocument.prototype.setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @api public\n */\n\nDocument.prototype.get = function(path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split('.'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don't apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n};\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n */\n\nDocument.prototype.$__path = function(path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @api public\n */\n\nDocument.prototype.markModified = function(path) {\n  this.$__.activePaths.modify(path);\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * ####Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save() // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * ####Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save() // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function() {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split('.');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n};\n\n/**\n * Returns true if this document was modified, else false.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(' ');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + '.') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some('modify');\n};\n\n/**\n * Checks if a path is set to its default.\n *\n * ####Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     var m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  return (path in this.$__.activePaths.states.default);\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  return (path in this.$__.activePaths.states.modify);\n};\n\n/**\n * Checks if `path` was initialized.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  return (path in this.$__.activePaths.states.init);\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     Thing.findOne().select('name').exec(function (err, doc) {\n *        doc.isSelected('name') // true\n *        doc.isSelected('age')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + '.';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + '.') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * ####Example\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Object} optional options internal options\n * @param {Function} callback optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\nDocument.prototype.validate = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  this.$__validate(callback || function() {});\n};\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc) {\n  var i;\n\n  // only validate required fields when necessary\n  var paths = Object.keys(doc.$__.activePaths.states.require).filter(function(path) {\n    if (!doc.isSelected(path) && !doc.isModified(path)) {\n      return false;\n    }\n    var p = doc.schema.path(path);\n    if (typeof p.originalRequiredValue === 'function') {\n      return p.originalRequiredValue.call(doc);\n    }\n    return true;\n  });\n\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.init));\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.modify));\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.default));\n\n  var subdocs = doc.$__getAllSubdocs();\n  var subdoc;\n  var len = subdocs.length;\n  for (i = 0; i < len; ++i) {\n    subdoc = subdocs[i];\n    if (subdoc.$isSingleNested &&\n        doc.isModified(subdoc.$basePath) &&\n        !doc.isDirectModified(subdoc.$basePath)) {\n      paths.push(subdoc.$basePath);\n    }\n  }\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (i = 0; i < paths.length; ++i) {\n    var path = paths[i];\n    var val = doc.getValue(path);\n    if (val && val.isMongooseArray && !Buffer.isBuffer(val) && !val.isMongooseDocumentArray) {\n      var numElements = val.length;\n      for (var j = 0; j < numElements; ++j) {\n        paths.push(path + '.' + j);\n      }\n    }\n  }\n\n  var flattenOptions = { skipArrays: true };\n  for (i = 0; i < paths.length; ++i) {\n    var pathToCheck = paths[i];\n    if (doc.schema.nested[pathToCheck]) {\n      var _v = doc.getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      var flat = flatten(_v, '', flattenOptions);\n      var _subpaths = Object.keys(flat).map(function(p) {\n        return pathToCheck + '.' + p;\n      });\n      paths = paths.concat(_subpaths);\n    }\n  }\n\n  return paths;\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit('validate', _this);\n    _this.constructor.emit('validate', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost('validate:error', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost('validate:error', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n};\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     var err = doc.validateSync();\n *     if ( err ){\n *       handleError( err );\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @return {MongooseError|undefined} MongooseError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api private\n * @method $markValid\n * @receiver Document\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/**\n * Checks if a path is invalid\n *\n * @param {String} path the field to check\n * @method $isValid\n * @api private\n * @receiver Document\n */\n\nDocument.prototype.$isValid = function(path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n */\n\nDocument.prototype.$__reset = function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  this.$__.activePaths\n  .map('init', 'modify', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n */\n\nDocument.prototype.$__dirty = function() {\n  var _this = this;\n\n  var all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + '.';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n};\n\n/*!\n * Compiles schemas.\n */\n\nfunction compile(tree, proto, prefix, options) {\n  var keys = Object.keys(tree),\n      i = keys.length,\n      limb,\n      key;\n\n  while (i--) {\n    key = keys[i];\n    limb = tree[key];\n\n    defineKey(key,\n        ((utils.getFunctionName(limb.constructor) === 'Object'\n        && Object.keys(limb).length)\n        && (!limb[options.typeKey] || (options.typeKey === 'type' && limb.type.type))\n            ? limb\n            : null)\n        , proto\n        , prefix\n        , keys\n        , options);\n  }\n}\n\n// gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\nfunction getOwnPropertyDescriptors(object) {\n  var result = {};\n\n  Object.getOwnPropertyNames(object).forEach(function(key) {\n    result[key] = Object.getOwnPropertyDescriptor(object, key);\n    result[key].enumerable = true;\n  });\n\n  return result;\n}\n\n/*!\n * Defines the accessor named prop on the incoming prototype.\n */\n\nfunction defineKey(prop, subprops, prototype, prefix, keys, options) {\n  var path = (prefix ? prefix + '.' : '') + prop;\n  prefix = prefix || '';\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        var _this = this;\n        if (!this.$__.getters) {\n          this.$__.getters = {};\n        }\n\n        if (!this.$__.getters[path]) {\n          var nested = Object.create(Object.getPrototypeOf(this), getOwnPropertyDescriptors(this));\n\n          // save scope for nested getters/setters\n          if (!prefix) {\n            nested.$__.scope = this;\n          }\n\n          // shadow inherited getters from sub-objects so\n          // thing.nested.nested.nested... doesn't occur (gh-366)\n          var i = 0,\n              len = keys.length;\n\n          for (; i < len; ++i) {\n            // over-write the parents getter without triggering it\n            Object.defineProperty(nested, keys[i], {\n              enumerable: false,    // It doesn't show up.\n              writable: true,       // We can set it later.\n              configurable: true,   // We can Object.defineProperty again.\n              value: undefined      // It shadows its parent.\n            });\n          }\n\n          Object.defineProperty(nested, 'toObject', {\n            enumerable: true,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return clone(_this.get(path), { retainKeyOrder: true });\n            }\n          });\n\n          Object.defineProperty(nested, 'toJSON', {\n            enumerable: true,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path);\n            }\n          });\n\n          Object.defineProperty(nested, '$__isNested', {\n            enumerable: true,\n            configurable: true,\n            writable: false,\n            value: true\n          });\n\n          compile(subprops, nested, path, options);\n          this.$__.getters[path] = nested;\n        }\n\n        return this.$__.getters[path];\n      },\n      set: function(v) {\n        if (v instanceof Document) {\n          v = v.toObject({ transform: false });\n        }\n        return (this.$__.scope || this).set(path, v);\n      }\n    });\n  } else {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        return this.get.call(this.$__.scope || this, path);\n      },\n      set: function(v) {\n        return this.set.call(this.$__.scope || this, path, v);\n      }\n    });\n  }\n}\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map('init', 'modify', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @api private\n * @method $__getAllSubdocs\n * @memberOf Document\n */\n\nDocument.prototype.$__getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  Embedded = Embedded || require('./types/embedded');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  var q = doc.schema && doc.schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n  var pair;\n\n  for (var i = 0; i < q.length; ++i) {\n    pair = q[i];\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners('error').length) {\n    this.emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  } else if (this.listeners && this.listeners('error').length) {\n    this.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === 'Object') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  ('minimize' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, 'paths', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, 'virtuals', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain javascript object, ready for storage in MongoDB.\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters)\n * - `virtuals` apply virtual getters (can override `getters` option)\n * - `minimize` remove empty objects (defaults to true)\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)\n * - `versionKey` whether to include the version key (defaults to true)\n * - `retainKeyOrder` keep the order of object keys. If this is set to true, `Object.keys(new Doc({ a: 1, b: 2}).toObject())` will always produce `['a', 'b']` (defaults to false)\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     var doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * Transforms are applied _only to the document and are not applied to sub-documents_.\n *\n * Transforms, like all of these options, are also available for `toJSON`.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @return {Object} js object\n * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\nfunction minimize(obj) {\n  var keys = Object.keys(obj),\n      i = keys.length,\n      hasKeys,\n      key,\n      val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isObject(val) && !Buffer.isBuffer(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n      ? obj\n      : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @param {String} type either `virtuals` or `paths`\n * @return {Object} `json`\n */\n\nfunction applyGetters(self, json, type, options) {\n  var schema = self.schema,\n      paths = Object.keys(schema[type]),\n      i = paths.length,\n      path;\n\n  while (i--) {\n    path = paths[i];\n\n    var parts = path.split('.'),\n        plen = parts.length,\n        last = plen - 1,\n        branch = json,\n        part;\n\n    for (var ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      if (ii === last) {\n        branch[part] = clone(self.get(path), options);\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @api public\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n */\n\nDocument.prototype.inspect = function(options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === 'Object';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n */\n\nDocument.prototype.toString = function() {\n  return inspect(this.inspect());\n};\n\n/**\n * Returns true if the Document stores the same data as doc.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get('_id');\n  var docid = doc.get ? doc.get('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n};\n\n/**\n * Populates document references, executing the `callback` when complete.\n * If you want to use promises instead, use this function with\n * [`execPopulate()`](#document_Document-execPopulate)\n *\n * ####Example:\n *\n *     doc\n *     .populate('company')\n *     .populate({\n *       path: 'notes',\n *       match: /airline/,\n *       select: 'text',\n *       model: 'modelName'\n *       options: opts\n *     }, function (err, user) {\n *       assert(doc._id === user._id) // the document itself is passed\n *     })\n *\n *     // summary\n *     doc.populate(path)                   // not executed\n *     doc.populate(options);               // not executed\n *     doc.populate(path, callback)         // executed\n *     doc.populate(options, callback);     // executed\n *     doc.populate(callback);              // executed\n *     doc.populate(options).execPopulate() // executed, returns promise\n *\n *\n * ####NOTE:\n *\n * Population does not occur unless a `callback` is passed *or* you explicitly\n * call `execPopulate()`.\n * Passing the same path a second time will overwrite the previous path options.\n * See [Model.populate()](#model_Model.populate) for explaination of options.\n *\n * @see Model.populate #model_Model.populate\n * @see Document.execPopulate #document_Document-execPopulate\n * @param {String|Object} [path] The path to populate or an options object\n * @param {Function} [callback] When passed, population is invoked\n * @api public\n * @return {Document} this\n */\n\nDocument.prototype.populate = function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === 'function') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n};\n\n/**\n * Explicitly executes population and returns a promise. Useful for ES2015\n * integration.\n *\n * ####Example:\n *\n *     var promise = doc.\n *       populate('company').\n *       populate({\n *         path: 'notes',\n *         match: /airline/,\n *         select: 'text',\n *         model: 'modelName'\n *         options: opts\n *       }).\n *       execPopulate();\n *\n *     // summary\n *     doc.execPopulate().then(resolve, reject);\n *\n *\n * @see Document.populate #document_Document-populate\n * @api public\n * @return {Promise} promise that resolves to the document when population is done\n */\n\nDocument.prototype.execPopulate = function() {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, undefined is returned.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, this is a no-op.\n *\n * @param {String} path\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n */\n\nDocument.prototype.depopulate = function(path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/mixed.js":"/*!\n * Module dependencies.\n */\n\nvar SchemaType = require('../schematype');\nvar utils = require('../utils');\n\n/**\n * Mixed SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction Mixed(path, options) {\n  if (options && options.default) {\n    var def = options.default;\n    if (Array.isArray(def) && def.length === 0) {\n      // make sure empty array defaults are handled\n      options.default = Array;\n    } else if (!options.shared && utils.isObject(def) && Object.keys(def).length === 0) {\n      // prevent odd \"shared\" objects between documents\n      options.default = function() {\n        return {};\n      };\n    }\n  }\n\n  SchemaType.call(this, path, options, 'Mixed');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nMixed.schemaName = 'Mixed';\n\n/*!\n * Inherits from SchemaType.\n */\nMixed.prototype = Object.create(SchemaType.prototype);\nMixed.prototype.constructor = Mixed;\n\n/**\n * Casts `val` for Mixed.\n *\n * _this is a no-op_\n *\n * @param {Object} value to cast\n * @api private\n */\n\nMixed.prototype.cast = function(val) {\n  return val;\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $cond\n * @param {any} [val]\n * @api private\n */\n\nMixed.prototype.castForQuery = function($cond, val) {\n  if (arguments.length === 2) {\n    return val;\n  }\n  return $cond;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Mixed;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error/objectExpected.js":"/*!\n * Module dependencies.\n */\n\nvar MongooseError = require('../error.js');\n\n/**\n * Strict mode error constructor\n *\n * @param {String} type\n * @param {String} value\n * @inherits MongooseError\n * @api private\n */\n\nfunction ObjectExpectedError(path, val) {\n  MongooseError.call(this, 'Tried to set nested object field `' + path +\n    '` to primitive value `' + val + '` and strict mode is set to throw.');\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.name = 'ObjectExpectedError';\n  this.path = path;\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nObjectExpectedError.prototype = Object.create(MongooseError.prototype);\nObjectExpectedError.prototype.constructor = MongooseError;\n\nmodule.exports = ObjectExpectedError;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error/strict.js":"/*!\n * Module dependencies.\n */\n\nvar MongooseError = require('../error.js');\n\n/**\n * Strict mode error constructor\n *\n * @param {String} type\n * @param {String} value\n * @inherits MongooseError\n * @api private\n */\n\nfunction StrictModeError(path, msg) {\n  msg = msg || 'Field `' + path + '` is not in schema and strict ' +\n    'mode is set to throw.';\n  MongooseError.call(this, msg);\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.name = 'StrictModeError';\n  this.path = path;\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nStrictModeError.prototype = Object.create(MongooseError.prototype);\nStrictModeError.prototype.constructor = MongooseError;\n\nmodule.exports = StrictModeError;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/internal.js":"/*!\n * Dependencies\n */\n\nvar StateMachine = require('./statemachine');\nvar ActiveRoster = StateMachine.ctor('require', 'modify', 'init', 'default', 'ignore');\n\nmodule.exports = exports = InternalCache;\n\nfunction InternalCache() {\n  this.strictMode = undefined;\n  this.selected = undefined;\n  this.shardval = undefined;\n  this.saveError = undefined;\n  this.validationError = undefined;\n  this.adhocPaths = undefined;\n  this.removing = undefined;\n  this.inserting = undefined;\n  this.version = undefined;\n  this.getters = {};\n  this._id = undefined;\n  this.populate = undefined; // what we want to populate in this doc\n  this.populated = undefined;// the _ids that have been populated\n  this.wasPopulated = false; // if this doc was the result of a population\n  this.scope = undefined;\n  this.activePaths = new ActiveRoster;\n\n  // embedded docs\n  this.ownerDocument = undefined;\n  this.fullPath = undefined;\n}\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/statemachine.js":"\n/*!\n * Module dependencies.\n */\n\nvar utils = require('./utils');\n\n/*!\n * StateMachine represents a minimal `interface` for the\n * constructors it builds via StateMachine.ctor(...).\n *\n * @api private\n */\n\nvar StateMachine = module.exports = exports = function StateMachine() {\n};\n\n/*!\n * StateMachine.ctor('state1', 'state2', ...)\n * A factory method for subclassing StateMachine.\n * The arguments are a list of states. For each state,\n * the constructor's prototype gets state transition\n * methods named after each state. These transition methods\n * place their path argument into the given state.\n *\n * @param {String} state\n * @param {String} [state]\n * @return {Function} subclass constructor\n * @private\n */\n\nStateMachine.ctor = function() {\n  var states = utils.args(arguments);\n\n  var ctor = function() {\n    StateMachine.apply(this, arguments);\n    this.paths = {};\n    this.states = {};\n    this.stateNames = states;\n\n    var i = states.length,\n        state;\n\n    while (i--) {\n      state = states[i];\n      this.states[state] = {};\n    }\n  };\n\n  ctor.prototype = new StateMachine();\n\n  states.forEach(function(state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function(path) {\n      this._changeState(path, state);\n    };\n  });\n\n  return ctor;\n};\n\n/*!\n * This function is wrapped by the state change functions:\n *\n * - `require(path)`\n * - `modify(path)`\n * - `init(path)`\n *\n * @api private\n */\n\nStateMachine.prototype._changeState = function _changeState(path, nextState) {\n  var prevBucket = this.states[this.paths[path]];\n  if (prevBucket) delete prevBucket[path];\n\n  this.paths[path] = nextState;\n  this.states[nextState][path] = true;\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clear = function clear(state) {\n  var keys = Object.keys(this.states[state]),\n      i = keys.length,\n      path;\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};\n\n/*!\n * Checks to see if at least one path is in the states passed in via `arguments`\n * e.g., this.some('required', 'inited')\n *\n * @param {String} state that we want to check for.\n * @private\n */\n\nStateMachine.prototype.some = function some() {\n  var _this = this;\n  var what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function(state) {\n    return Object.keys(_this.states[state]).length;\n  });\n};\n\n/*!\n * This function builds the functions that get assigned to `forEach` and `map`,\n * since both of those methods share a lot of the same logic.\n *\n * @param {String} iterMethod is either 'forEach' or 'map'\n * @return {Function}\n * @api private\n */\n\nStateMachine.prototype._iter = function _iter(iterMethod) {\n  return function() {\n    var numArgs = arguments.length,\n        states = utils.args(arguments, 0, numArgs - 1),\n        callback = arguments[numArgs - 1];\n\n    if (!states.length) states = this.stateNames;\n\n    var _this = this;\n\n    var paths = states.reduce(function(paths, state) {\n      return paths.concat(Object.keys(_this.states[state]));\n    }, []);\n\n    return paths[iterMethod](function(path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};\n\n/*!\n * Iterates over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @private\n */\n\nStateMachine.prototype.forEach = function forEach() {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};\n\n/*!\n * Maps over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @return {Array}\n * @private\n */\n\nStateMachine.prototype.map = function map() {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/promise_provider.js":"/*!\n * Module dependencies.\n */\n\nvar MPromise = require('./promise');\n\n/**\n * Helper for multiplexing promise implementations\n *\n * @api private\n */\n\nvar Promise = {\n  _promise: MPromise\n};\n\n/**\n * Get the current promise constructor\n *\n * @api private\n */\nPromise.get = function() {\n  return Promise._promise;\n};\n\n/**\n * Set the current promise constructor\n *\n * @api private\n */\n\nPromise.set = function(lib) {\n  if (lib === MPromise) {\n    return Promise.reset();\n  }\n  Promise._promise = require('./ES6Promise');\n  Promise._promise.use(lib);\n  require('mquery').Promise = Promise._promise.ES6;\n};\n\n/**\n * Resets to using mpromise\n *\n * @api private\n */\n\nPromise.reset = function() {\n  Promise._promise = MPromise;\n};\n\nmodule.exports = Promise;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/promise.js":"/*!\n * Module dependencies\n */\n\nvar MPromise = require('mpromise');\nvar util = require('util');\n\n/**\n * Promise constructor.\n *\n * Promises are returned from executed queries. Example:\n *\n *     var query = Candy.find({ bar: true });\n *     var promise = query.exec();\n *\n * DEPRECATED. Mongoose 5.0 will use native promises by default (or bluebird,\n * if native promises are not present) but still\n * support plugging in your own ES6-compatible promises library. Mongoose 5.0\n * will **not** support mpromise.\n *\n * @param {Function} fn a function which will be called when the promise is resolved that accepts `fn(err, ...){}` as signature\n * @inherits mpromise https://github.com/aheckmann/mpromise\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `err`: Emits when the promise is rejected\n * @event `complete`: Emits when the promise is fulfilled\n * @api public\n * @deprecated\n */\n\nfunction Promise(fn) {\n  MPromise.call(this, fn);\n}\n\n/**\n * ES6-style promise constructor wrapper around mpromise.\n *\n * @param {Function} resolver\n * @return {Promise} new promise\n * @api public\n */\nPromise.ES6 = function(resolver) {\n  var promise = new Promise();\n\n  // No try/catch for backwards compatibility\n  resolver(\n    function() {\n      promise.complete.apply(promise, arguments);\n    },\n    function(e) {\n      promise.error(e);\n    });\n\n  return promise;\n};\n\n/*!\n * Inherit from mpromise\n */\n\nPromise.prototype = Object.create(MPromise.prototype, {\n  constructor: {\n    value: Promise,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  }\n});\n\n/*!\n * ignore\n */\n\nPromise.prototype.then = util.deprecate(Promise.prototype.then,\n  'Mongoose: mpromise (mongoose\\'s default promise library) is deprecated, ' +\n  'plug in your own promise library instead: ' +\n  'http://mongoosejs.com/docs/promises.html');\n\n/**\n * ES6-style `.catch()` shorthand\n *\n * @method catch\n * @memberOf Promise\n * @param {Function} onReject\n * @return {Promise}\n * @api public\n */\n\nPromise.prototype.catch = function(onReject) {\n  return this.then(null, onReject);\n};\n\n/*!\n * Override event names for backward compatibility.\n */\n\nPromise.SUCCESS = 'complete';\nPromise.FAILURE = 'err';\n\n/**\n * Adds `listener` to the `event`.\n *\n * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.\n *\n * @see mpromise#on https://github.com/aheckmann/mpromise#on\n * @method on\n * @memberOf Promise\n * @param {String} event\n * @param {Function} listener\n * @return {Promise} this\n * @api public\n */\n\n/**\n * Rejects this promise with `reason`.\n *\n * If the promise has already been fulfilled or rejected, not action is taken.\n *\n * @see mpromise#reject https://github.com/aheckmann/mpromise#reject\n * @method reject\n * @memberOf Promise\n * @param {Object|String|Error} reason\n * @return {Promise} this\n * @api public\n */\n\n/**\n * Rejects this promise with `err`.\n *\n * If the promise has already been fulfilled or rejected, not action is taken.\n *\n * Differs from [#reject](#promise_Promise-reject) by first casting `err` to an `Error` if it is not `instanceof Error`.\n *\n * @api public\n * @param {Error|String} err\n * @return {Promise} this\n */\n\nPromise.prototype.error = function(err) {\n  if (!(err instanceof Error)) {\n    if (err instanceof Object) {\n      err = util.inspect(err);\n    }\n    err = new Error(err);\n  }\n  return this.reject(err);\n};\n\n/**\n * Resolves this promise to a rejected state if `err` is passed or a fulfilled state if no `err` is passed.\n *\n * If the promise has already been fulfilled or rejected, not action is taken.\n *\n * `err` will be cast to an Error if not already instanceof Error.\n *\n * _NOTE: overrides [mpromise#resolve](https://github.com/aheckmann/mpromise#resolve) to provide error casting._\n *\n * @param {Error} [err] error or null\n * @param {Object} [val] value to fulfill the promise with\n * @api public\n * @deprecated\n */\n\nPromise.prototype.resolve = function(err) {\n  if (err) return this.error(err);\n  return this.fulfill.apply(this, Array.prototype.slice.call(arguments, 1));\n};\n\n/**\n * Adds a single function as a listener to both err and complete.\n *\n * It will be executed with traditional node.js argument position when the promise is resolved.\n *\n *     promise.addBack(function (err, args...) {\n *       if (err) return handleError(err);\n *       console.log('success');\n *     })\n *\n * Alias of [mpromise#onResolve](https://github.com/aheckmann/mpromise#onresolve).\n *\n * _Deprecated. Use `onResolve` instead._\n *\n * @method addBack\n * @param {Function} listener\n * @return {Promise} this\n * @deprecated\n */\n\nPromise.prototype.addBack = Promise.prototype.onResolve;\n\n/**\n * Fulfills this promise with passed arguments.\n *\n * @method fulfill\n * @receiver Promise\n * @see https://github.com/aheckmann/mpromise#fulfill\n * @param {any} args\n * @api public\n * @deprecated\n */\n\n/**\n * Fulfills this promise with passed arguments.\n *\n * Alias of [mpromise#fulfill](https://github.com/aheckmann/mpromise#fulfill).\n *\n * _Deprecated. Use `fulfill` instead._\n *\n * @method complete\n * @receiver Promise\n * @param {any} args\n * @api public\n * @deprecated\n */\n\nPromise.prototype.complete = MPromise.prototype.fulfill;\n\n/**\n * Adds a listener to the `complete` (success) event.\n *\n * Alias of [mpromise#onFulfill](https://github.com/aheckmann/mpromise#onfulfill).\n *\n * _Deprecated. Use `onFulfill` instead._\n *\n * @method addCallback\n * @param {Function} listener\n * @return {Promise} this\n * @api public\n * @deprecated\n */\n\nPromise.prototype.addCallback = Promise.prototype.onFulfill;\n\n/**\n * Adds a listener to the `err` (rejected) event.\n *\n * Alias of [mpromise#onReject](https://github.com/aheckmann/mpromise#onreject).\n *\n * _Deprecated. Use `onReject` instead._\n *\n * @method addErrback\n * @param {Function} listener\n * @return {Promise} this\n * @api public\n * @deprecated\n */\n\nPromise.prototype.addErrback = Promise.prototype.onReject;\n\n/**\n * Creates a new promise and returns it. If `onFulfill` or `onReject` are passed, they are added as SUCCESS/ERROR callbacks to this promise after the nextTick.\n *\n * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification.\n *\n * ####Example:\n *\n *     var promise = Meetups.find({ tags: 'javascript' }).select('_id').exec();\n *     promise.then(function (meetups) {\n *       var ids = meetups.map(function (m) {\n *         return m._id;\n *       });\n *       return People.find({ meetups: { $in: ids } }).exec();\n *     }).then(function (people) {\n *       if (people.length < 10000) {\n *         throw new Error('Too few people!!!');\n *       } else {\n *         throw new Error('Still need more people!!!');\n *       }\n *     }).then(null, function (err) {\n *       assert.ok(err instanceof Error);\n *     });\n *\n * @see promises-A+ https://github.com/promises-aplus/promises-spec\n * @see mpromise#then https://github.com/aheckmann/mpromise#then\n * @method then\n * @memberOf Promise\n * @param {Function} onFulFill\n * @param {Function} onReject\n * @return {Promise} newPromise\n * @deprecated\n */\n\n/**\n * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function(){ throw new Error('shucks') });\n *     setTimeout(function () {\n *       p.fulfill();\n *       // error was caught and swallowed by the promise returned from\n *       // p.then(). we either have to always register handlers on\n *       // the returned promises or we can do the following...\n *     }, 10);\n *\n *     // this time we use .end() which prevents catching thrown errors\n *     var p = new Promise;\n *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--\n *     setTimeout(function () {\n *       p.fulfill(); // throws \"shucks\"\n *     }, 10);\n *\n * @api public\n * @see mpromise#end https://github.com/aheckmann/mpromise#end\n * @method end\n * @memberOf Promise\n * @deprecated\n */\n\n/*!\n * expose\n */\n\nmodule.exports = Promise;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/services/common.js":"'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar ObjectId = require('../types/objectid');\nvar utils = require('../utils');\n\nexports.flatten = flatten;\nexports.modifiedPaths = modifiedPaths;\n\n/*!\n * ignore\n */\n\nfunction flatten(update, path, options) {\n  var keys;\n  if (update && utils.isMongooseObject(update) && !Buffer.isBuffer(update)) {\n    keys = Object.keys(update.toObject({ transform: false, virtuals: false }));\n  } else {\n    keys = Object.keys(update || {});\n  }\n\n  var numKeys = keys.length;\n  var result = {};\n  path = path ? path + '.' : '';\n\n  for (var i = 0; i < numKeys; ++i) {\n    var key = keys[i];\n    var val = update[key];\n    result[path + key] = val;\n    if (shouldFlatten(val)) {\n      if (options && options.skipArrays && Array.isArray(val)) {\n        continue;\n      }\n      var flat = flatten(val, path + key);\n      for (var k in flat) {\n        result[k] = flat[k];\n      }\n      if (Array.isArray(val)) {\n        result[path + key] = val;\n      }\n    }\n  }\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction modifiedPaths(update, path, result) {\n  var keys = Object.keys(update || {});\n  var numKeys = keys.length;\n  result = result || {};\n  path = path ? path + '.' : '';\n\n  for (var i = 0; i < numKeys; ++i) {\n    var key = keys[i];\n    var val = update[key];\n\n    result[path + key] = true;\n    if (utils.isMongooseObject(val) && !Buffer.isBuffer(val)) {\n      val = val.toObject({ transform: false, virtuals: false });\n    }\n    if (shouldFlatten(val)) {\n      modifiedPaths(val, path + key, result);\n    }\n  }\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction shouldFlatten(val) {\n  return val &&\n    typeof val === 'object' &&\n    !(val instanceof Date) &&\n    !(val instanceof ObjectId) &&\n    (!Array.isArray(val) || val.length > 0) &&\n    !(val instanceof Buffer);\n}\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/browserDocument.js":"/*!\n * Module dependencies.\n */\n\nvar NodeJSDocument = require('./document');\nvar EventEmitter = require('events').EventEmitter;\nvar MongooseError = require('./error');\nvar Schema = require('./schema');\nvar ObjectId = require('./types/objectid');\nvar utils = require('./utils');\nvar ValidationError = MongooseError.ValidationError;\nvar InternalCache = require('./internal');\nvar PromiseProvider = require('./promise_provider');\nvar VersionError = require('./error').VersionError;\n\nvar Embedded;\n\n/**\n * Document constructor.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, schema, fields, skipId, skipInit) {\n  if (!(this instanceof Document)) {\n    return new Document(obj, schema, fields, skipId, skipInit);\n  }\n\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n\n  // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id\n  schema = this.schema || schema;\n\n  // Generate ObjectId if it is missing, but it requires a scheme\n  if (!this.schema && schema.options._id) {\n    obj = obj || {};\n\n    if (obj._id === undefined) {\n      obj._id = new ObjectId();\n    }\n  }\n\n  if (!schema) {\n    throw new MongooseError.MissingSchemaError();\n  }\n\n  this.$__setSchema(schema);\n\n  this.$__ = new InternalCache;\n  this.$__.emitter = new EventEmitter();\n  this.isNew = true;\n  this.errors = undefined;\n\n  if (typeof fields === 'boolean') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = this.schema.options && this.schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  var required = this.schema.requiredPaths();\n  for (var i = 0; i < required.length; ++i) {\n    this.$__.activePaths.require(required[i]);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n  this._doc = this.$__buildDoc(obj, fields, skipId);\n\n  if (!skipInit && obj) {\n    this.init(obj);\n  }\n\n  this.$__registerHooksFromSchema();\n\n  // apply methods\n  for (var m in schema.methods) {\n    this[m] = schema.methods[m];\n  }\n  // apply statics\n  for (var s in schema.statics) {\n    this[s] = schema.statics[s];\n  }\n}\n\n/*!\n * Inherit from the NodeJS document\n */\n\nDocument.prototype = Object.create(NodeJSDocument.prototype);\nDocument.prototype.constructor = Document;\n\n/*!\n * Browser doc exposes the event emitter API\n */\n\nDocument.$emitter = new EventEmitter();\n\nutils.each(\n    ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n      'removeAllListeners', 'addListener'],\n    function(emitterFn) {\n      Document[emitterFn] = function() {\n        return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);\n      };\n    });\n\n/*!\n * Executes methods queued from the Schema definition\n *\n * @api private\n * @method $__registerHooksFromSchema\n * @deprecated\n * @memberOf Document\n */\n\nDocument.prototype.$__registerHooksFromSchema = function() {\n  Embedded = Embedded || require('./types/embedded');\n  var Promise = PromiseProvider.get();\n\n  var _this = this;\n  var q = _this.schema && _this.schema.callQueue;\n  var toWrapEl;\n  var len;\n  var i;\n  var j;\n  var pointCut;\n  var keys;\n  if (!q.length) {\n    return _this;\n  }\n\n  // we are only interested in 'pre' hooks, and group by point-cut\n  var toWrap = { post: [] };\n  var pair;\n\n  for (i = 0; i < q.length; ++i) {\n    pair = q[i];\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      _this[pair[0]].apply(_this, pair[1]);\n      continue;\n    }\n    var args = [].slice.call(pair[1]);\n    pointCut = pair[0] === 'on' ? 'post' : args[0];\n    if (!(pointCut in toWrap)) {\n      toWrap[pointCut] = {post: [], pre: []};\n    }\n    if (pair[0] === 'post') {\n      toWrap[pointCut].post.push(args);\n    } else if (pair[0] === 'on') {\n      toWrap[pointCut].push(args);\n    } else {\n      toWrap[pointCut].pre.push(args);\n    }\n  }\n\n  // 'post' hooks are simpler\n  len = toWrap.post.length;\n  toWrap.post.forEach(function(args) {\n    _this.on.apply(_this, args);\n  });\n  delete toWrap.post;\n\n  // 'init' should be synchronous on subdocuments\n  if (toWrap.init && _this instanceof Embedded) {\n    if (toWrap.init.pre) {\n      toWrap.init.pre.forEach(function(args) {\n        _this.$pre.apply(_this, args);\n      });\n    }\n    if (toWrap.init.post) {\n      toWrap.init.post.forEach(function(args) {\n        _this.$post.apply(_this, args);\n      });\n    }\n    delete toWrap.init;\n  } else if (toWrap.set) {\n    // Set hooks also need to be sync re: gh-3479\n    if (toWrap.set.pre) {\n      toWrap.set.pre.forEach(function(args) {\n        _this.$pre.apply(_this, args);\n      });\n    }\n    if (toWrap.set.post) {\n      toWrap.set.post.forEach(function(args) {\n        _this.$post.apply(_this, args);\n      });\n    }\n    delete toWrap.set;\n  }\n\n  keys = Object.keys(toWrap);\n  len = keys.length;\n  for (i = 0; i < len; ++i) {\n    pointCut = keys[i];\n    // this is so we can wrap everything into a promise;\n    var newName = ('$__original_' + pointCut);\n    if (!_this[pointCut]) {\n      continue;\n    }\n    _this[newName] = _this[pointCut];\n    _this[pointCut] = (function(_newName) {\n      return function wrappedPointCut() {\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== 'function') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don't support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (_this.constructor.$wrapCallback) {\n            fn = _this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      };\n    })(newName);\n\n    toWrapEl = toWrap[pointCut];\n    var _len = toWrapEl.pre.length;\n    args;\n    for (j = 0; j < _len; ++j) {\n      args = toWrapEl.pre[j];\n      args[0] = newName;\n      _this.$pre.apply(_this, args);\n    }\n\n    _len = toWrapEl.post.length;\n    for (j = 0; j < _len; ++j) {\n      args = toWrapEl.post[j];\n      args[0] = newName;\n      _this.$post.apply(_this, args);\n    }\n  }\n  return _this;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/types/buffer.js":"/*!\n * Module dependencies.\n */\n\nvar Binary = require('../drivers').Binary,\n    utils = require('../utils');\n\n/**\n * Mongoose Buffer constructor.\n *\n * Values always have to be passed to the constructor to initialize.\n *\n * @param {Buffer} value\n * @param {String} encode\n * @param {Number} offset\n * @api private\n * @inherits Buffer\n * @see http://bit.ly/f6CnZU\n */\n\nfunction MongooseBuffer(value, encode, offset) {\n  var length = arguments.length;\n  var val;\n\n  if (length === 0 || arguments[0] === null || arguments[0] === undefined) {\n    val = 0;\n  } else {\n    val = value;\n  }\n\n  var encoding;\n  var path;\n  var doc;\n\n  if (Array.isArray(encode)) {\n    // internal casting\n    path = encode[0];\n    doc = encode[1];\n  } else {\n    encoding = encode;\n  }\n\n  var buf = new Buffer(val, encoding, offset);\n  utils.decorate(buf, MongooseBuffer.mixin);\n  buf.isMongooseBuffer = true;\n\n  // make sure these internal props don't show up in Object.keys()\n  Object.defineProperties(buf, {\n    validators: {value: []},\n    _path: {value: path},\n    _parent: {value: doc}\n  });\n\n  if (doc && typeof path === 'string') {\n    Object.defineProperty(buf, '_schema', {\n      value: doc.schema.path(path)\n    });\n  }\n\n  buf._subtype = 0;\n  return buf;\n}\n\n/*!\n * Inherit from Buffer.\n */\n\n// MongooseBuffer.prototype = new Buffer(0);\n\nMongooseBuffer.mixin = {\n\n  /**\n   * Parent owner document\n   *\n   * @api private\n   * @property _parent\n   * @receiver MongooseBuffer\n   */\n\n  _parent: undefined,\n\n  /**\n   * Default subtype for the Binary representing this Buffer\n   *\n   * @api private\n   * @property _subtype\n   * @receiver MongooseBuffer\n   */\n\n  _subtype: undefined,\n\n  /**\n   * Marks this buffer as modified.\n   *\n   * @api private\n   * @method _markModified\n   * @receiver MongooseBuffer\n   */\n\n  _markModified: function() {\n    var parent = this._parent;\n\n    if (parent) {\n      parent.markModified(this._path);\n    }\n    return this;\n  },\n\n  /**\n   * Writes the buffer.\n   *\n   * @api public\n   * @method write\n   * @receiver MongooseBuffer\n   */\n\n  write: function() {\n    var written = Buffer.prototype.write.apply(this, arguments);\n\n    if (written > 0) {\n      this._markModified();\n    }\n\n    return written;\n  },\n\n  /**\n   * Copies the buffer.\n   *\n   * ####Note:\n   *\n   * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.\n   *\n   * @return {Number} The number of bytes copied.\n   * @param {Buffer} target\n   * @method copy\n   * @receiver MongooseBuffer\n   */\n\n  copy: function(target) {\n    var ret = Buffer.prototype.copy.apply(this, arguments);\n\n    if (target && target.isMongooseBuffer) {\n      target._markModified();\n    }\n\n    return ret;\n  }\n};\n\n/*!\n * Compile other Buffer methods marking this buffer as modified.\n */\n\n(\n// node < 0.5\n    'writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 ' +\n    'writeFloat writeDouble fill ' +\n    'utf8Write binaryWrite asciiWrite set ' +\n\n// node >= 0.5\n    'writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE ' +\n    'writeInt16LE writeInt16BE writeInt32LE writeInt32BE ' +\n    'writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE'\n).split(' ').forEach(function(method) {\n  if (!Buffer.prototype[method]) {\n    return;\n  }\n  MongooseBuffer.mixin[method] = function() {\n    var ret = Buffer.prototype[method].apply(this, arguments);\n    this._markModified();\n    return ret;\n  };\n});\n\n/**\n * Converts this buffer to its Binary type representation.\n *\n * ####SubTypes:\n *\n *   var bson = require('bson')\n *   bson.BSON_BINARY_SUBTYPE_DEFAULT\n *   bson.BSON_BINARY_SUBTYPE_FUNCTION\n *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *   bson.BSON_BINARY_SUBTYPE_UUID\n *   bson.BSON_BINARY_SUBTYPE_MD5\n *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *\n *   doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);\n *\n * @see http://bsonspec.org/#/specification\n * @param {Hex} [subtype]\n * @return {Binary}\n * @api public\n * @method toObject\n * @receiver MongooseBuffer\n */\n\nMongooseBuffer.mixin.toObject = function(options) {\n  var subtype = typeof options === 'number'\n      ? options\n      : (this._subtype || 0);\n  return new Binary(this, subtype);\n};\n\n/**\n * Determines if this buffer is equals to `other` buffer\n *\n * @param {Buffer} other\n * @return {Boolean}\n * @method equals\n * @receiver MongooseBuffer\n */\n\nMongooseBuffer.mixin.equals = function(other) {\n  if (!Buffer.isBuffer(other)) {\n    return false;\n  }\n\n  if (this.length !== other.length) {\n    return false;\n  }\n\n  for (var i = 0; i < this.length; ++i) {\n    if (this[i] !== other[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Sets the subtype option and marks the buffer modified.\n *\n * ####SubTypes:\n *\n *   var bson = require('bson')\n *   bson.BSON_BINARY_SUBTYPE_DEFAULT\n *   bson.BSON_BINARY_SUBTYPE_FUNCTION\n *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *   bson.BSON_BINARY_SUBTYPE_UUID\n *   bson.BSON_BINARY_SUBTYPE_MD5\n *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *\n *   doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);\n *\n * @see http://bsonspec.org/#/specification\n * @param {Hex} subtype\n * @api public\n * @method subtype\n * @receiver MongooseBuffer\n */\n\nMongooseBuffer.mixin.subtype = function(subtype) {\n  if (typeof subtype !== 'number') {\n    throw new TypeError('Invalid subtype. Expected a number');\n  }\n\n  if (this._subtype !== subtype) {\n    this._markModified();\n  }\n\n  this._subtype = subtype;\n};\n\n/*!\n * Module exports.\n */\n\nMongooseBuffer.Binary = Binary;\n\nmodule.exports = MongooseBuffer;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/types/documentarray.js":"/*!\n * Module dependencies.\n */\n\nvar MongooseArray = require('./array'),\n    ObjectId = require('./objectid'),\n    ObjectIdSchema = require('../schema/objectid'),\n    utils = require('../utils'),\n    Document = require('../document');\n\n/**\n * DocumentArray constructor\n *\n * @param {Array} values\n * @param {String} path the path to this array\n * @param {Document} doc parent document\n * @api private\n * @return {MongooseDocumentArray}\n * @inherits MongooseArray\n * @see http://bit.ly/f6CnZU\n */\n\nfunction MongooseDocumentArray(values, path, doc) {\n  var arr = [].concat(values);\n  arr._path = path;\n\n  var props = {\n    isMongooseArray: true,\n    isMongooseDocumentArray: true,\n    validators: [],\n    _atomics: {},\n    _schema: void 0,\n    _handlers: void 0\n  };\n\n  // Values always have to be passed to the constructor to initialize, since\n  // otherwise MongooseArray#push will mark the array as modified to the parent.\n  var keysMA = Object.keys(MongooseArray.mixin);\n  var numKeys = keysMA.length;\n  for (var j = 0; j < numKeys; ++j) {\n    arr[keysMA[j]] = MongooseArray.mixin[keysMA[j]];\n  }\n\n  var keysMDA = Object.keys(MongooseDocumentArray.mixin);\n  numKeys = keysMDA.length;\n  for (var i = 0; i < numKeys; ++i) {\n    arr[keysMDA[i]] = MongooseDocumentArray.mixin[keysMDA[i]];\n  }\n\n  var keysP = Object.keys(props);\n  numKeys = keysP.length;\n  for (var k = 0; k < numKeys; ++k) {\n    arr[keysP[k]] = props[keysP[k]];\n  }\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020 && #3034)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc && doc instanceof Document) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n    arr._handlers = {\n      isNew: arr.notify('isNew'),\n      save: arr.notify('save')\n    };\n\n    doc.on('save', arr._handlers.save);\n    doc.on('isNew', arr._handlers.isNew);\n  }\n\n  return arr;\n}\n\n/*!\n * Inherits from MongooseArray\n */\n// MongooseDocumentArray.mixin = Object.create( MongooseArray.mixin );\nMongooseDocumentArray.mixin = {\n  /*!\n   * ignore\n   */\n  toBSON: function() {\n    return this.toObject({\n      transform: false,\n      virtuals: false,\n      _skipDepopulateTopLevel: true,\n      depopulate: true,\n      flattenDecimals: false\n    });\n  },\n\n  /**\n   * Overrides MongooseArray#cast\n   *\n   * @method _cast\n   * @api private\n   * @receiver MongooseDocumentArray\n   */\n\n  _cast: function(value, index) {\n    var Constructor = this._schema.casterConstructor;\n    if (value instanceof Constructor ||\n        // Hack re: #5001, see #5005\n        (value && value.constructor && value.constructor.baseCasterConstructor === Constructor)) {\n      if (!(value.__parent && value.__parentArray)) {\n        // value may have been created using array.create()\n        value.__parent = this._parent;\n        value.__parentArray = this;\n      }\n      value.__index = index;\n      return value;\n    }\n\n    if (value === undefined || value === null) {\n      return null;\n    }\n\n    // handle cast('string') or cast(ObjectId) etc.\n    // only objects are permitted so we can safely assume that\n    // non-objects are to be interpreted as _id\n    if (Buffer.isBuffer(value) ||\n        value instanceof ObjectId || !utils.isObject(value)) {\n      value = {_id: value};\n    }\n\n    if (value &&\n        Constructor.discriminators &&\n        Constructor.schema.options.discriminatorKey &&\n        typeof value[Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];\n    }\n\n    return new Constructor(value, this, undefined, undefined, index);\n  },\n\n  /**\n   * Searches array items for the first document with a matching _id.\n   *\n   * ####Example:\n   *\n   *     var embeddedDoc = m.array.id(some_id);\n   *\n   * @return {EmbeddedDocument|null} the subdocument or null if not found.\n   * @param {ObjectId|String|Number|Buffer} id\n   * @TODO cast to the _id based on schema for proper comparison\n   * @method id\n   * @api public\n   * @receiver MongooseDocumentArray\n   */\n\n  id: function(id) {\n    var casted,\n        sid,\n        _id;\n\n    try {\n      var casted_ = ObjectIdSchema.prototype.cast.call({}, id);\n      if (casted_) {\n        casted = String(casted_);\n      }\n    } catch (e) {\n      casted = null;\n    }\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      if (!this[i]) {\n        continue;\n      }\n      _id = this[i].get('_id');\n\n      if (_id === null || typeof _id === 'undefined') {\n        continue;\n      } else if (_id instanceof Document) {\n        sid || (sid = String(id));\n        if (sid == _id._id) {\n          return this[i];\n        }\n      } else if (!(id instanceof ObjectId) && !(_id instanceof ObjectId)) {\n        if (utils.deepEqual(id, _id)) {\n          return this[i];\n        }\n      } else if (casted == _id) {\n        return this[i];\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Returns a native js Array of plain js objects\n   *\n   * ####NOTE:\n   *\n   * _Each sub-document is converted to a plain object by calling its `#toObject` method._\n   *\n   * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion\n   * @return {Array}\n   * @method toObject\n   * @api public\n   * @receiver MongooseDocumentArray\n   */\n\n  toObject: function(options) {\n    return this.map(function(doc) {\n      return doc && doc.toObject(options) || null;\n    });\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @method inspect\n   * @api public\n   * @receiver MongooseDocumentArray\n   */\n\n  inspect: function() {\n    return Array.prototype.slice.call(this);\n  },\n\n  /**\n   * Creates a subdocument casted to this schema.\n   *\n   * This is the same subdocument constructor used for casting.\n   *\n   * @param {Object} obj the value to cast to this arrays SubDocument schema\n   * @method create\n   * @api public\n   * @receiver MongooseDocumentArray\n   */\n\n  create: function(obj) {\n    var Constructor = this._schema.casterConstructor;\n    if (obj &&\n        Constructor.discriminators &&\n        Constructor.schema.options.discriminatorKey &&\n        typeof obj[Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];\n    }\n\n    return new Constructor(obj);\n  },\n\n  /**\n   * Creates a fn that notifies all child docs of `event`.\n   *\n   * @param {String} event\n   * @return {Function}\n   * @method notify\n   * @api private\n   * @receiver MongooseDocumentArray\n   */\n\n  notify: function notify(event) {\n    var _this = this;\n    return function notify(val) {\n      var i = _this.length;\n      while (i--) {\n        if (!_this[i]) {\n          continue;\n        }\n        switch (event) {\n          // only swap for save event for now, we may change this to all event types later\n          case 'save':\n            val = _this[i];\n            break;\n          default:\n            // NO-OP\n            break;\n        }\n        _this[i].emit(event, val);\n      }\n    };\n  }\n\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = MongooseDocumentArray;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/types/subdocument.js":"var Document = require('../document');\nvar PromiseProvider = require('../promise_provider');\n\nmodule.exports = Subdocument;\n\n/**\n * Subdocument constructor.\n *\n * @inherits Document\n * @api private\n */\n\nfunction Subdocument(value, fields) {\n  this.$isSingleNested = true;\n  Document.call(this, value, fields);\n}\n\nSubdocument.prototype = Object.create(Document.prototype);\n\nSubdocument.prototype.toBSON = function() {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n};\n\n/**\n * Used as a stub for [hooks.js](https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3)\n *\n * ####NOTE:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @return {Promise} resolved Promise\n * @api private\n */\n\nSubdocument.prototype.save = function(fn) {\n  var Promise = PromiseProvider.get();\n  return new Promise.ES6(function(resolve) {\n    fn && fn();\n    resolve();\n  });\n};\n\nSubdocument.prototype.$isValid = function(path) {\n  if (this.$parent) {\n    return this.$parent.$isValid([this.$basePath, path].join('.'));\n  }\n};\n\nSubdocument.prototype.markModified = function(path) {\n  Document.prototype.markModified.call(this, path);\n  if (this.$parent) {\n    if (this.$parent.isDirectModified(this.$basePath)) {\n      return;\n    }\n    this.$parent.markModified([this.$basePath, path].join('.'));\n  }\n};\n\nSubdocument.prototype.$markValid = function(path) {\n  Document.prototype.$markValid.call(this, path);\n  if (this.$parent) {\n    this.$parent.$markValid([this.$basePath, path].join('.'));\n  }\n};\n\nSubdocument.prototype.invalidate = function(path, err, val) {\n  Document.prototype.invalidate.call(this, path, err, val);\n  if (this.$parent) {\n    this.$parent.invalidate([this.$basePath, path].join('.'), err, val);\n  } else if (err.kind === 'cast' || err.name === 'CastError') {\n    throw err;\n  }\n};\n\n/**\n * Returns the top level document of this sub-document.\n *\n * @return {Document}\n */\n\nSubdocument.prototype.ownerDocument = function() {\n  if (this.$__.ownerDocument) {\n    return this.$__.ownerDocument;\n  }\n\n  var parent = this.$parent;\n  if (!parent) {\n    return this;\n  }\n\n  while (parent.$parent || parent.__parent) {\n    parent = parent.$parent || parent.__parent;\n  }\n  this.$__.ownerDocument = parent;\n  return this.$__.ownerDocument;\n};\n\n/**\n * Null-out this subdoc\n *\n * @param {Object} [options]\n * @param {Function} [callback] optional callback for compatibility with Document.prototype.remove\n */\n\nSubdocument.prototype.remove = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  // If removing entire doc, no need to remove subdoc\n  if (!options || !options.noop) {\n    this.$parent.set(this.$basePath, null);\n    registerRemoveListener(this);\n  }\n\n  if (typeof callback === 'function') {\n    callback(null);\n  }\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.populate = function() {\n  throw new Error('Mongoose does not support calling populate() on nested ' +\n    'docs. Instead of `doc.nested.populate(\"path\")`, use ' +\n    '`doc.populate(\"nested.path\")`');\n};\n\n/*!\n * Registers remove event listeners for triggering\n * on subdocuments.\n *\n * @param {EmbeddedDocument} sub\n * @api private\n */\n\nfunction registerRemoveListener(sub) {\n  var owner = sub.ownerDocument();\n\n  function emitRemove() {\n    owner.removeListener('save', emitRemove);\n    owner.removeListener('remove', emitRemove);\n    sub.emit('remove', sub);\n    sub.constructor.emit('remove', sub);\n    owner = sub = null;\n  }\n\n  owner.on('save', emitRemove);\n  owner.on('remove', emitRemove);\n}\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/cast.js":"/*!\n * Module dependencies.\n */\n\nvar StrictModeError = require('./error/strict');\nvar Types = require('./schema/index');\nvar utils = require('./utils');\n\nvar ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for queries\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} options the query options\n * @api private\n */\nmodule.exports = function cast(schema, obj, options) {\n  var paths = Object.keys(obj),\n      i = paths.length,\n      _keys,\n      any$conditionals,\n      schematype,\n      nested,\n      path,\n      type,\n      val;\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      var k = val.length;\n\n      while (k--) {\n        val[k] = cast(schema, val[k]);\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        var split = path.split('.'),\n            j = split.length,\n            pathFirstHalf,\n            pathLastHalf,\n            remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            obj[path] = cast(schematype.caster.schema, remainingConds)[pathLastHalf];\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (utils.isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          var geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            var numbertype = new Types.Number('__QueryCasting__');\n            var value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(val.$maxDistance);\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(val.$minDistance);\n            }\n\n            if (geo === '$within') {\n              var withinType = value.$center\n                  || value.$centerSphere\n                  || value.$box\n                  || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within paramater: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' &&\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n                value.$geometry && typeof value.$geometry.type === 'string' &&\n                Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(value.$maxDistance);\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(value.$minDistance);\n              }\n              if (utils.isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (utils.isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\n                }\n                var geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center ||\n                  value.$centerSphere;\n                if (utils.isMongooseObject(value)) {\n                  value = value.toObject({ virtuals: false });\n                }\n              }\n            }\n\n            _cast(value, numbertype);\n          }\n        }\n\n        if (options && options.upsert && options.strict) {\n          if (options.strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema, strict mode is `true`, and upsert is `true`.');\n        }\n      } else if (val === null || val === undefined) {\n        obj[path] = null;\n        continue;\n      } else if (val.constructor.name === 'Object') {\n        any$conditionals = Object.keys(val).some(function(k) {\n          return k.charAt(0) === '$' && k !== '$id' && k !== '$ref';\n        });\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(val);\n        } else {\n          var ks = Object.keys(val),\n              $cond;\n\n          k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n\n            if ($cond === '$not') {\n              if (nested && schematype && !schematype.caster) {\n                _keys = Object.keys(nested);\n                if (_keys.length && _keys[0].charAt(0) === '$') {\n                  for (var key in nested) {\n                    nested[key] = schematype.castForQuery(key, nested[key]);\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery($cond, nested);\n                }\n                continue;\n              }\n              cast(schematype.caster ? schematype.caster.schema : schema, nested);\n            } else {\n              val[$cond] = schematype.castForQuery($cond, nested);\n            }\n          }\n        }\n      } else if (val.constructor.name === 'Array' && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        var casted = [];\n        for (var valIndex = 0; valIndex < val.length; valIndex++) {\n          casted.push(schematype.castForQuery(val[valIndex]));\n        }\n\n        obj[path] = { $in: casted };\n      } else {\n        obj[path] = schematype.castForQuery(val);\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || utils.isObject(item)) {\n        return _cast(item, numbertype);\n      }\n      val[i] = numbertype.castForQuery(item);\n    });\n  } else {\n    var nearKeys = Object.keys(val);\n    var nearLen = nearKeys.length;\n    while (nearLen--) {\n      var nkey = nearKeys[nearLen];\n      var item = val[nkey];\n      if (Array.isArray(item) || utils.isObject(item)) {\n        _cast(item, numbertype);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery(item);\n      }\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/operators/helpers.js":"'use strict';\n\n/*!\n * Module requirements.\n */\n\nvar Types = {\n  Number: require('../number')\n};\n\n/*!\n * @ignore\n */\n\nexports.castToNumber = castToNumber;\nexports.castArraysOfNumbers = castArraysOfNumbers;\n\n/*!\n * @ignore\n */\n\nfunction castToNumber(val) {\n  return Types.Number.prototype.cast.call(this, val);\n}\n\nfunction castArraysOfNumbers(arr, self) {\n  arr.forEach(function(v, i) {\n    if (Array.isArray(v)) {\n      castArraysOfNumbers(v, self);\n    } else {\n      arr[i] = castToNumber.call(self, v);\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/operators/geospatial.js":"/*!\n * Module requirements.\n */\n\nvar castArraysOfNumbers = require('./helpers').castArraysOfNumbers;\nvar castToNumber = require('./helpers').castToNumber;\n\n/*!\n * ignore\n */\n\nexports.cast$geoIntersects = cast$geoIntersects;\nexports.cast$near = cast$near;\nexports.cast$within = cast$within;\n\nfunction cast$near(val) {\n  var SchemaArray = require('../array');\n\n  if (Array.isArray(val)) {\n    castArraysOfNumbers(val, this);\n    return val;\n  }\n\n  _castMinMaxDistance(this, val);\n\n  if (val && val.$geometry) {\n    return cast$geometry(val, this);\n  }\n\n  return SchemaArray.prototype.castForQuery.call(this, val);\n}\n\nfunction cast$geometry(val, self) {\n  switch (val.$geometry.type) {\n    case 'Polygon':\n    case 'LineString':\n    case 'Point':\n      castArraysOfNumbers(val.$geometry.coordinates, self);\n      break;\n    default:\n      // ignore unknowns\n      break;\n  }\n\n  _castMinMaxDistance(this, val);\n\n  return val;\n}\n\nfunction cast$within(val) {\n  _castMinMaxDistance(this, val);\n\n  if (val.$box || val.$polygon) {\n    var type = val.$box ? '$box' : '$polygon';\n    val[type].forEach(function(arr) {\n      if (!Array.isArray(arr)) {\n        var msg = 'Invalid $within $box argument. '\n            + 'Expected an array, received ' + arr;\n        throw new TypeError(msg);\n      }\n      arr.forEach(function(v, i) {\n        arr[i] = castToNumber.call(this, v);\n      });\n    });\n  } else if (val.$center || val.$centerSphere) {\n    type = val.$center ? '$center' : '$centerSphere';\n    val[type].forEach(function(item, i) {\n      if (Array.isArray(item)) {\n        item.forEach(function(v, j) {\n          item[j] = castToNumber.call(this, v);\n        });\n      } else {\n        val[type][i] = castToNumber.call(this, item);\n      }\n    });\n  } else if (val.$geometry) {\n    cast$geometry(val, this);\n  }\n\n  return val;\n}\n\nfunction cast$geoIntersects(val) {\n  var geo = val.$geometry;\n  if (!geo) {\n    return;\n  }\n\n  cast$geometry(val, this);\n  return val;\n}\n\nfunction _castMinMaxDistance(self, val) {\n  if (val.$maxDistance) {\n    val.$maxDistance = castToNumber.call(self, val.$maxDistance);\n  }\n  if (val.$minDistance) {\n    val.$minDistance = castToNumber.call(self, val.$minDistance);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/services/model/applyHooks.js":"'use strict';\n\nvar PromiseProvider = require('../../promise_provider');\nvar VersionError = require('../../error').VersionError;\n\nmodule.exports = applyHooks;\n\n/*!\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nfunction applyHooks(model, schema) {\n  var q = schema && schema.callQueue;\n  var toWrapEl;\n  var len;\n  var i;\n  var j;\n  var pointCut;\n  var keys;\n  var newName;\n  if (!q.length) {\n    return;\n  }\n\n  // we are only interested in 'pre' hooks, and group by point-cut\n  var toWrap = { post: [] };\n  var pair;\n\n  for (i = 0; i < q.length; ++i) {\n    pair = q[i];\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      continue;\n    }\n    var args = [].slice.call(pair[1]);\n    pointCut = pair[0] === 'on' ? 'post' : args[0];\n    if (!(pointCut in toWrap)) {\n      toWrap[pointCut] = {post: [], pre: []};\n    }\n    if (pair[0] === 'post') {\n      toWrap[pointCut].post.push(args);\n    } else if (pair[0] === 'on') {\n      toWrap[pointCut].push(args);\n    } else {\n      toWrap[pointCut].pre.push(args);\n    }\n  }\n\n  // 'post' hooks are simpler\n  len = toWrap.post.length;\n  toWrap.post.forEach(function(args) {\n    model.on.apply(model, args);\n  });\n  delete toWrap.post;\n\n  // 'init' should be synchronous on subdocuments\n  if (toWrap.init && (model.$isSingleNested || model.$isArraySubdocument)) {\n    if (toWrap.init.pre) {\n      toWrap.init.pre.forEach(function(args) {\n        model.prototype.$pre.apply(model.prototype, args);\n      });\n    }\n    if (toWrap.init.post) {\n      toWrap.init.post.forEach(function(args) {\n        model.prototype.$post.apply(model.prototype, args);\n      });\n    }\n    delete toWrap.init;\n  }\n  if (toWrap.set) {\n    // Set hooks also need to be sync re: gh-3479\n    newName = '$__original_set';\n    model.prototype[newName] = model.prototype.set;\n    if (toWrap.set.pre) {\n      toWrap.set.pre.forEach(function(args) {\n        model.prototype.$pre.apply(model.prototype, args);\n      });\n    }\n    if (toWrap.set.post) {\n      toWrap.set.post.forEach(function(args) {\n        model.prototype.$post.apply(model.prototype, args);\n      });\n    }\n    delete toWrap.set;\n  }\n\n  keys = Object.keys(toWrap);\n  len = keys.length;\n  for (i = 0; i < len; ++i) {\n    pointCut = keys[i];\n    // this is so we can wrap everything into a promise;\n    newName = ('$__original_' + pointCut);\n    if (!model.prototype[pointCut]) {\n      return;\n    }\n    if (!model.prototype[pointCut].$originalFunction) {\n      model.prototype[newName] = model.prototype[pointCut];\n    }\n    model.prototype[pointCut] = (function(_newName) {\n      return function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== 'function') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don't support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      };\n    })(newName);\n    model.prototype[pointCut].$originalFunction = newName;\n\n    toWrapEl = toWrap[pointCut];\n    var _len = toWrapEl.pre.length;\n    for (j = 0; j < _len; ++j) {\n      args = toWrapEl.pre[j];\n      args[0] = newName;\n      model.prototype.$pre.apply(model.prototype, args);\n    }\n\n    _len = toWrapEl.post.length;\n    for (j = 0; j < _len; ++j) {\n      args = toWrapEl.post[j];\n      args[0] = newName;\n      model.prototype.$post.apply(model.prototype, args);\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/services/model/discriminator.js":"'use strict';\n\nvar utils = require('../../utils');\n\nvar CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true\n};\n\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  if (model.base && model.base.options.applyPluginsToDiscriminators) {\n    model.base._applyPlugins(schema);\n  }\n\n  if (model.schema.discriminatorMapping &&\n      !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name +\n        '\" can only be a discriminator of the root model');\n  }\n\n  var key = model.schema.options.discriminatorKey;\n  if (schema.path(key)) {\n    throw new Error('Discriminator \"' + name +\n        '\" cannot have field with name \"' + key + '\"');\n  }\n\n  function merge(schema, baseSchema) {\n    utils.merge(schema, baseSchema, { retainKeyOrder: true });\n\n    var obj = {};\n    obj[key] = {\n      default: name,\n      set: function(newName) {\n        if (newName === name) {\n          return name;\n        }\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      }\n    };\n    obj[key][schema.options.typeKey] = String;\n    schema.add(obj);\n    schema.discriminatorMapping = {key: key, value: name, isRoot: false};\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n\n    var toJSON = schema.options.toJSON;\n    var toObject = schema.options.toObject;\n    var _id = schema.options._id;\n    var id = schema.options.id;\n\n    var keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n\n    for (var i = 0; i < keys.length; ++i) {\n      var _key = keys[i];\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        if (!utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key +\n              ' (can only modify ' +\n              Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +\n              ')');\n        }\n      }\n    }\n\n    schema.options = utils.clone(baseSchema.options);\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n    schema.options.id = id;\n\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue.slice(schema._defaultMiddleware.length));\n    schema._requiredpaths = undefined; // reset just in case Schema#requiredPaths() was called on either schema\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = {key: key, value: null, isRoot: true};\n  }\n\n  if (model.discriminators[name]) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/embedded.js":"'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar $exists = require('./operators/exists');\nvar EventEmitter = require('events').EventEmitter;\nvar SchemaType = require('../schematype');\nvar Subdocument = require('../types/subdocument');\nvar applyHooks = require('../services/model/applyHooks');\nvar castToNumber = require('./operators/helpers').castToNumber;\nvar geospatial = require('./operators/geospatial');\n\nmodule.exports = Embedded;\n\n/**\n * Sub-schema schematype constructor\n *\n * @param {Schema} schema\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction Embedded(schema, path, options) {\n  var _embedded = function SingleNested(value, path, parent) {\n    var _this = this;\n    Subdocument.apply(this, arguments);\n    this.$parent = parent;\n    if (parent) {\n      parent.on('save', function() {\n        _this.emit('save', _this);\n        _this.constructor.emit('save', _this);\n      });\n\n      parent.on('isNew', function(val) {\n        _this.isNew = val;\n        _this.emit('isNew', val);\n        _this.constructor.emit('isNew', val);\n      });\n    }\n  };\n  _embedded.prototype = Object.create(Subdocument.prototype);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.prototype.$basePath = path;\n  _embedded.prototype.toBSON = function() {\n    return this.toObject({\n      transform: false,\n      retainKeyOrder: schema.options.retainKeyOrder,\n      virtuals: false,\n      _skipDepopulateTopLevel: true,\n      depopulate: true,\n      flattenDecimals: false\n    });\n  };\n\n  // apply methods\n  for (var i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  for (i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n\n  applyHooks(_embedded, schema);\n\n  this.caster = _embedded;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n\nEmbedded.prototype = Object.create(SchemaType.prototype);\n\n/**\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\nEmbedded.prototype.$conditionalHandlers.$geoWithin = function(val) {\n  return { $geometry: this.castForQuery(val.$geometry) };\n};\n\n/*!\n * ignore\n */\n\nEmbedded.prototype.$conditionalHandlers.$near =\nEmbedded.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\n\nEmbedded.prototype.$conditionalHandlers.$within =\nEmbedded.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\n\nEmbedded.prototype.$conditionalHandlers.$geoIntersects =\n  geospatial.cast$geoIntersects;\n\nEmbedded.prototype.$conditionalHandlers.$minDistance = castToNumber;\nEmbedded.prototype.$conditionalHandlers.$maxDistance = castToNumber;\n\nEmbedded.prototype.$conditionalHandlers.$exists = $exists;\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nEmbedded.prototype.cast = function(val, doc, init) {\n  if (val && val.$isSingleNested) {\n    return val;\n  }\n  var subdoc = new this.caster(void 0, doc ? doc.$__.selected : void 0, doc);\n  if (init) {\n    subdoc.init(val);\n  } else {\n    subdoc.set(val, undefined, true);\n  }\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nEmbedded.prototype.castForQuery = function($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  if (val == null) {\n    return val;\n  }\n\n  return new this.caster(val);\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\nEmbedded.prototype.doValidate = function(value, fn, scope) {\n  var Constructor = this.caster;\n  SchemaType.prototype.doValidate.call(this, value, function(error) {\n    if (error) {\n      return fn(error);\n    }\n    if (!value) {\n      return fn(null);\n    }\n    if (!(value instanceof Constructor)) {\n      value = new Constructor(value);\n    }\n    value.validate(fn, {__noPromise: true});\n  }, scope);\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nEmbedded.prototype.doValidateSync = function(value, scope) {\n  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n  if (schemaTypeError) {\n    return schemaTypeError;\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/schema/decimal128.js":"/* eslint no-empty: 1 */\n\n/*!\n * Module dependencies.\n */\n\nvar SchemaType = require('../schematype');\nvar CastError = SchemaType.CastError;\nvar Decimal128Type = require('../types/decimal128');\nvar utils = require('../utils');\nvar Document;\n\n/**\n * Decimal128 SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction Decimal128(key, options) {\n  SchemaType.call(this, key, options, 'Decimal128');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDecimal128.schemaName = 'Decimal128';\n\n/*!\n * Inherits from SchemaType.\n */\nDecimal128.prototype = Object.create(SchemaType.prototype);\nDecimal128.prototype.constructor = Decimal128;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nDecimal128.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return value instanceof Decimal128Type;\n};\n\n/**\n * Casts to Decimal128\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nDecimal128.prototype.cast = function(value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = require('./../document'));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (value instanceof Decimal128Type) {\n      return value;\n    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {\n      throw new CastError('Decimal128', value, this.path);\n    }\n\n    // Handle the case where user directly sets a populated\n    // path to a plain object; cast to the Model used in\n    // the population query.\n    var path = doc.$__fullPath(this.path);\n    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    var pop = owner.populated(path, true);\n    var ret = value;\n    if (!doc.$__.populated ||\n        !doc.$__.populated[path] ||\n        !doc.$__.populated[path].options ||\n        !doc.$__.populated[path].options.options ||\n        !doc.$__.populated[path].options.options.lean) {\n      ret = new pop.options.model(value);\n      ret.$__.wasPopulated = true;\n    }\n\n    return ret;\n  }\n\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (value instanceof Decimal128Type) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return Decimal128Type.fromString(value);\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return new Decimal128Type(value);\n  }\n\n  throw new CastError('Decimal128', value, this.path);\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nDecimal128.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [val]\n * @api private\n */\n\nDecimal128.prototype.castForQuery = function($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with ObjectId.');\n    }\n    return handler.call(this, val);\n  }\n  return this.cast($conditional);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Decimal128;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/connectionstate.js":"\n/*!\n * Connection states\n */\n\nvar STATES = module.exports = exports = Object.create(null);\n\nvar disconnected = 'disconnected';\nvar connected = 'connected';\nvar connecting = 'connecting';\nvar disconnecting = 'disconnecting';\nvar unauthorized = 'unauthorized';\nvar uninitialized = 'uninitialized';\n\nSTATES[0] = disconnected;\nSTATES[1] = connected;\nSTATES[2] = connecting;\nSTATES[3] = disconnecting;\nSTATES[4] = unauthorized;\nSTATES[99] = uninitialized;\n\nSTATES[disconnected] = 0;\nSTATES[connected] = 1;\nSTATES[connecting] = 2;\nSTATES[disconnecting] = 3;\nSTATES[unauthorized] = 4;\nSTATES[uninitialized] = 99;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/query.js":"/*!\n * Module dependencies.\n */\n\nvar PromiseProvider = require('./promise_provider');\nvar QueryCursor = require('./querycursor');\nvar QueryStream = require('./querystream');\nvar cast = require('./cast');\nvar castUpdate = require('./services/query/castUpdate');\nvar helpers = require('./queryhelpers');\nvar mquery = require('mquery');\nvar readPref = require('./drivers').ReadPreference;\nvar setDefaultsOnInsert = require('./services/setDefaultsOnInsert');\nvar updateValidators = require('./services/updateValidators');\nvar util = require('util');\nvar utils = require('./utils');\n\n/**\n * Query constructor used for building queries.\n *\n * ####Example:\n *\n *     var query = new Query();\n *     query.setOptions({ lean : true });\n *     query.collection(model.collection);\n *     query.where('age').gte(21).exec(callback);\n *\n * @param {Object} [options]\n * @param {Object} [model]\n * @param {Object} [conditions]\n * @param {Object} [collection] Mongoose collection\n * @api private\n */\n\nfunction Query(conditions, options, model, collection) {\n  // this stuff is for dealing with custom queries created by #toConstructor\n  if (!this._mongooseOptions) {\n    this._mongooseOptions = {};\n  }\n\n  // this is the case where we have a CustomQuery, we need to check if we got\n  // options passed in, and if we did, merge them in\n  if (options) {\n    var keys = Object.keys(options);\n    for (var i = 0; i < keys.length; ++i) {\n      var k = keys[i];\n      this._mongooseOptions[k] = options[k];\n    }\n  }\n\n  if (collection) {\n    this.mongooseCollection = collection;\n  }\n\n  if (model) {\n    this.model = model;\n    this.schema = model.schema;\n  }\n\n  // this is needed because map reduce returns a model that can be queried, but\n  // all of the queries on said model should be lean\n  if (this.model && this.model._mapreduce) {\n    this.lean();\n  }\n\n  // inherit mquery\n  mquery.call(this, this.mongooseCollection, options);\n\n  if (conditions) {\n    this.find(conditions);\n  }\n\n  if (this.schema) {\n    var kareemOptions = {\n      useErrorHandlers: true,\n      numCallbackParams: 1\n    };\n    this._count = this.model.hooks.createWrapper('count',\n        Query.prototype._count, this, kareemOptions);\n    this._execUpdate = this.model.hooks.createWrapper('update',\n        Query.prototype._execUpdate, this, kareemOptions);\n    this._find = this.model.hooks.createWrapper('find',\n        Query.prototype._find, this, kareemOptions);\n    this._findOne = this.model.hooks.createWrapper('findOne',\n        Query.prototype._findOne, this, kareemOptions);\n    this._findOneAndRemove = this.model.hooks.createWrapper('findOneAndRemove',\n        Query.prototype._findOneAndRemove, this, kareemOptions);\n    this._findOneAndUpdate = this.model.hooks.createWrapper('findOneAndUpdate',\n        Query.prototype._findOneAndUpdate, this, kareemOptions);\n    this._replaceOne = this.model.hooks.createWrapper('replaceOne',\n        Query.prototype._replaceOne, this, kareemOptions);\n    this._updateMany = this.model.hooks.createWrapper('updateMany',\n        Query.prototype._updateMany, this, kareemOptions);\n    this._updateOne = this.model.hooks.createWrapper('updateOne',\n        Query.prototype._updateOne, this, kareemOptions);\n  }\n}\n\n/*!\n * inherit mquery\n */\n\nQuery.prototype = new mquery;\nQuery.prototype.constructor = Query;\nQuery.base = mquery.prototype;\n\n/**\n * Flag to opt out of using `$geoWithin`.\n *\n *     mongoose.Query.use$geoWithin = false;\n *\n * MongoDB 2.4 deprecated the use of `$within`, replacing it with `$geoWithin`. Mongoose uses `$geoWithin` by default (which is 100% backward compatible with $within). If you are running an older version of MongoDB, set this flag to `false` so your `within()` queries continue to work.\n *\n * @see http://docs.mongodb.org/manual/reference/operator/geoWithin/\n * @default true\n * @property use$geoWithin\n * @memberOf Query\n * @receiver Query\n * @api public\n */\n\nQuery.use$geoWithin = mquery.use$geoWithin;\n\n/**\n * Converts this query to a customized, reusable query constructor with all arguments and options retained.\n *\n * ####Example\n *\n *     // Create a query for adventure movies and read from the primary\n *     // node in the replica-set unless it is down, in which case we'll\n *     // read from a secondary node.\n *     var query = Movie.find({ tags: 'adventure' }).read('primaryPreferred');\n *\n *     // create a custom Query constructor based off these settings\n *     var Adventure = query.toConstructor();\n *\n *     // Adventure is now a subclass of mongoose.Query and works the same way but with the\n *     // default query parameters and options set.\n *     Adventure().exec(callback)\n *\n *     // further narrow down our query results while still using the previous settings\n *     Adventure().where({ name: /^Life/ }).exec(callback);\n *\n *     // since Adventure is a stand-alone constructor we can also add our own\n *     // helper methods and getters without impacting global queries\n *     Adventure.prototype.startsWith = function (prefix) {\n *       this.where({ name: new RegExp('^' + prefix) })\n *       return this;\n *     }\n *     Object.defineProperty(Adventure.prototype, 'highlyRated', {\n *       get: function () {\n *         this.where({ rating: { $gt: 4.5 }});\n *         return this;\n *       }\n *     })\n *     Adventure().highlyRated.startsWith('Life').exec(callback)\n *\n * New in 3.7.3\n *\n * @return {Query} subclass-of-Query\n * @api public\n */\n\nQuery.prototype.toConstructor = function toConstructor() {\n  var model = this.model;\n  var coll = this.mongooseCollection;\n\n  var CustomQuery = function(criteria, options) {\n    if (!(this instanceof CustomQuery)) {\n      return new CustomQuery(criteria, options);\n    }\n    this._mongooseOptions = utils.clone(p._mongooseOptions);\n    Query.call(this, criteria, options || null, model, coll);\n  };\n\n  util.inherits(CustomQuery, Query);\n\n  // set inherited defaults\n  var p = CustomQuery.prototype;\n\n  p.options = {};\n\n  p.setOptions(this.options);\n\n  p.op = this.op;\n  p._conditions = utils.clone(this._conditions, { retainKeyOrder: true });\n  p._fields = utils.clone(this._fields);\n  p._update = utils.clone(this._update);\n  p._path = this._path;\n  p._distinct = this._distinct;\n  p._collection = this._collection;\n  p._mongooseOptions = this._mongooseOptions;\n\n  return CustomQuery;\n};\n\n/**\n * Specifies a javascript function or expression to pass to MongoDBs query system.\n *\n * ####Example\n *\n *     query.$where('this.comments.length === 10 || this.name.length === 5')\n *\n *     // or\n *\n *     query.$where(function () {\n *       return this.comments.length === 10 || this.name.length === 5;\n *     })\n *\n * ####NOTE:\n *\n * Only use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`.\n * **Be sure to read about all of [its caveats](http://docs.mongodb.org/manual/reference/operator/where/) before using.**\n *\n * @see $where http://docs.mongodb.org/manual/reference/operator/where/\n * @method $where\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @method $where\n * @api public\n */\n\n/**\n * Specifies a `path` for use with chaining.\n *\n * ####Example\n *\n *     // instead of writing:\n *     User.find({age: {$gte: 21, $lte: 65}}, callback);\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^vonderful/i)\n *     .where('friends').slice(10)\n *     .exec(callback)\n *\n * @method where\n * @memberOf Query\n * @param {String|Object} [path]\n * @param {any} [val]\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * ####Example\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @method equals\n * @memberOf Query\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for an `$or` condition.\n *\n * ####Example\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }])\n *\n * @see $or http://docs.mongodb.org/manual/reference/operator/or/\n * @method or\n * @memberOf Query\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * ####Example\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }])\n *\n * @see $nor http://docs.mongodb.org/manual/reference/operator/nor/\n * @method nor\n * @memberOf Query\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for a `$and` condition.\n *\n * ####Example\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @method and\n * @memberOf Query\n * @see $and http://docs.mongodb.org/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies a $gt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * ####Example\n *\n *     Thing.find().where('age').gt(21)\n *\n *     // or\n *     Thing.find().gt('age', 21)\n *\n * @method gt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @see $gt http://docs.mongodb.org/manual/reference/operator/gt/\n * @api public\n */\n\n/**\n * Specifies a $gte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @see $gte http://docs.mongodb.org/manual/reference/operator/gte/\n * @api public\n */\n\n/**\n * Specifies a $lt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @see $lt http://docs.mongodb.org/manual/reference/operator/lt/\n * @api public\n */\n\n/**\n * Specifies a $lte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @see $lte http://docs.mongodb.org/manual/reference/operator/lte/\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $ne query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $ne http://docs.mongodb.org/manual/reference/operator/ne/\n * @method ne\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $in query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $in http://docs.mongodb.org/manual/reference/operator/in/\n * @method in\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $nin query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $nin http://docs.mongodb.org/manual/reference/operator/nin/\n * @method nin\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $all query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $all http://docs.mongodb.org/manual/reference/operator/all/\n * @method all\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $size query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * ####Example\n *\n *     MyModel.where('tags').size(0).exec(function (err, docs) {\n *       if (err) return handleError(err);\n *\n *       assert(Array.isArray(docs));\n *       console.log('documents with 0 tags', docs);\n *     })\n *\n * @see $size http://docs.mongodb.org/manual/reference/operator/size/\n * @method size\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $regex query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $regex http://docs.mongodb.org/manual/reference/operator/regex/\n * @method regex\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $maxDistance query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/\n * @method maxDistance\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$mod` condition\n *\n * @method mod\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @see $mod http://docs.mongodb.org/manual/reference/operator/mod/\n * @api public\n */\n\n/**\n * Specifies an `$exists` condition\n *\n * ####Example\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @method exists\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @see $exists http://docs.mongodb.org/manual/reference/operator/exists/\n * @api public\n */\n\n/**\n * Specifies an `$elemMatch` condition\n *\n * ####Example\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @method elemMatch\n * @memberOf Query\n * @param {String|Object|Function} path\n * @param {Object|Function} criteria\n * @return {Query} this\n * @see $elemMatch http://docs.mongodb.org/manual/reference/operator/elemMatch/\n * @api public\n */\n\n/**\n * Defines a `$within` or `$geoWithin` argument for geo-spatial queries.\n *\n * ####Example\n *\n *     query.where(path).within().box()\n *     query.where(path).within().circle()\n *     query.where(path).within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * **MUST** be used after `where()`.\n *\n * ####NOTE:\n *\n * As of Mongoose 3.7, `$geoWithin` is always used for queries. To change this behavior, see [Query.use$geoWithin](#query_Query-use%2524geoWithin).\n *\n * ####NOTE:\n *\n * In Mongoose 3.7, `within` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n *\n * @method within\n * @see $polygon http://docs.mongodb.org/manual/reference/operator/polygon/\n * @see $box http://docs.mongodb.org/manual/reference/operator/box/\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @see $center http://docs.mongodb.org/manual/reference/operator/center/\n * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/\n * @memberOf Query\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies a $slice projection for an array.\n *\n * ####Example\n *\n *     query.slice('comments', 5)\n *     query.slice('comments', -5)\n *     query.slice('comments', [10, 5])\n *     query.where('comments').slice(5)\n *     query.where('comments').slice([-10, 5])\n *\n * @method slice\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val number/range of elements to slice\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements\n * @see $slice http://docs.mongodb.org/manual/reference/projection/slice/#prj._S_slice\n * @api public\n */\n\n/**\n * Specifies the maximum number of documents the query will return.\n *\n * ####Example\n *\n *     query.limit(20)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies the number of documents to skip.\n *\n * ####Example\n *\n *     query.skip(100).limit(20)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @param {Number} val\n * @see cursor.skip http://docs.mongodb.org/manual/reference/method/cursor.skip/\n * @api public\n */\n\n/**\n * Specifies the maxScan option.\n *\n * ####Example\n *\n *     query.maxScan(100)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method maxScan\n * @memberOf Query\n * @param {Number} val\n * @see maxScan http://docs.mongodb.org/manual/reference/operator/maxScan/\n * @api public\n */\n\n/**\n * Specifies the batchSize option.\n *\n * ####Example\n *\n *     query.batchSize(100)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @param {Number} val\n * @see batchSize http://docs.mongodb.org/manual/reference/method/cursor.batchSize/\n * @api public\n */\n\n/**\n * Specifies the `comment` option.\n *\n * ####Example\n *\n *     query.comment('login query')\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @param {Number} val\n * @see comment http://docs.mongodb.org/manual/reference/operator/comment/\n * @api public\n */\n\n/**\n * Specifies this query as a `snapshot` query.\n *\n * ####Example\n *\n *     query.snapshot() // true\n *     query.snapshot(true)\n *     query.snapshot(false)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method snapshot\n * @memberOf Query\n * @see snapshot http://docs.mongodb.org/manual/reference/operator/snapshot/\n * @return {Query} this\n * @api public\n */\n\n/**\n * Sets query hints.\n *\n * ####Example\n *\n *     query.hint({ indexA: 1, indexB: -1})\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method hint\n * @memberOf Query\n * @param {Object} val a hint object\n * @return {Query} this\n * @see $hint http://docs.mongodb.org/manual/reference/operator/hint/\n * @api public\n */\n\n/**\n * Specifies which document fields to include or exclude (also known as the query \"projection\")\n *\n * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](/docs/api.html#schematype_SchemaType-select).\n *\n * ####Example\n *\n *     // include a and b, exclude other fields\n *     query.select('a b');\n *\n *     // exclude c and d, include other fields\n *     query.select('-c -d');\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({ a: 1, b: 1 });\n *     query.select({ c: 0, d: 0 });\n *\n *     // force inclusion of field excluded at schema level\n *     query.select('+path')\n *\n * ####NOTE:\n *\n * Cannot be used with `distinct()`.\n *\n * _v2 had slightly different syntax such as allowing arrays of field names. This support was removed in v3._\n *\n * @method select\n * @memberOf Query\n * @param {Object|String} arg\n * @return {Query} this\n * @see SchemaType\n * @api public\n */\n\n/**\n * _DEPRECATED_ Sets the slaveOk option.\n *\n * **Deprecated** in MongoDB 2.2 in favor of [read preferences](#query_Query-read).\n *\n * ####Example:\n *\n *     query.slaveOk() // true\n *     query.slaveOk(true)\n *     query.slaveOk(false)\n *\n * @method slaveOk\n * @memberOf Query\n * @deprecated use read() preferences instead if on mongodb >= 2.2\n * @param {Boolean} v defaults to true\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see slaveOk http://docs.mongodb.org/manual/reference/method/rs.slaveOk/\n * @see read() #query_Query-read\n * @return {Query} this\n * @api public\n */\n\n/**\n * Determines the MongoDB nodes from which to read.\n *\n * ####Preferences:\n *\n *     primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n *     secondary            Read from secondary if available, otherwise error.\n *     primaryPreferred     Read from primary if available, otherwise a secondary.\n *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n *\n * Aliases\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * ####Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // read from secondaries with matching tags\n *     new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])\n *\n * Read more about how to use read preferrences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).\n *\n * @method read\n * @memberOf Query\n * @param {String} pref one of the listed preference options or aliases\n * @param {Array} [tags] optional tags for this query\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.read = function read(pref, tags) {\n  // first cast into a ReadPreference object to support tags\n  var read = readPref.call(readPref, pref, tags);\n  return Query.base.read.call(this, read);\n};\n\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * New in 3.7.0\n *\n * @method merge\n * @memberOf Query\n * @param {Query|Object} source\n * @return {Query} this\n */\n\n/**\n * Sets query options.\n *\n * ####Options:\n *\n * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *\n * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\\)%7D%7D) *\n * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *\n * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *\n * - [maxscan](https://docs.mongodb.org/v3.2/reference/operator/meta/maxScan/#metaOp._S_maxScan) *\n * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *\n * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *\n * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D) *\n * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *\n * - [readPreference](http://docs.mongodb.org/manual/applications/replication/#read-preference) **\n * - [lean](./api.html#query_Query-lean) *\n * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)\n *\n * _* denotes a query helper method is also available_\n * _** query helper method to set `readPreference` is `read()`_\n *\n * @param {Object} options\n * @api public\n */\n\nQuery.prototype.setOptions = function(options, overwrite) {\n  // overwrite is only for internal use\n  if (overwrite) {\n    // ensure that _mongooseOptions & options are two different objects\n    this._mongooseOptions = (options && utils.clone(options)) || {};\n    this.options = options || {};\n\n    if ('populate' in options) {\n      this.populate(this._mongooseOptions);\n    }\n    return this;\n  }\n\n  if (!(options && options.constructor.name === 'Object')) {\n    return this;\n  }\n\n  if (options && Array.isArray(options.populate)) {\n    var populate = options.populate;\n    delete options.populate;\n    var _numPopulate = populate.length;\n    for (var i = 0; i < _numPopulate; ++i) {\n      this.populate(populate[i]);\n    }\n  }\n\n  return Query.base.setOptions.call(this, options);\n};\n\n/**\n * Returns the current query conditions as a JSON object.\n *\n * ####Example:\n *\n *     var query = new Query();\n *     query.find({ a: 1 }).where('b').gt(2);\n *     query.getQuery(); // { a: 1, b: { $gt: 2 } }\n *\n * @return {Object} current query conditions\n * @api public\n */\n\nQuery.prototype.getQuery = function() {\n  return this._conditions;\n};\n\n/**\n * Returns the current update operations as a JSON object.\n *\n * ####Example:\n *\n *     var query = new Query();\n *     query.update({}, { $set: { a: 5 } });\n *     query.getUpdate(); // { $set: { a: 5 } }\n *\n * @return {Object} current update operations\n * @api public\n */\n\nQuery.prototype.getUpdate = function() {\n  return this._update;\n};\n\n/**\n * Returns fields selection for this query.\n *\n * @method _fieldsForExec\n * @return {Object}\n * @api private\n * @receiver Query\n */\n\n/**\n * Return an update document with corrected $set operations.\n *\n * @method _updateForExec\n * @api private\n * @receiver Query\n */\n\nQuery.prototype._updateForExec = function() {\n  var update = utils.clone(this._update, {\n    retainKeyOrder: true,\n    transform: false,\n    depopulate: true\n  });\n  var ops = Object.keys(update);\n  var i = ops.length;\n  var ret = {};\n\n  while (i--) {\n    var op = ops[i];\n\n    if (this.options.overwrite) {\n      ret[op] = update[op];\n      continue;\n    }\n\n    if ('$' !== op[0]) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (update.$set) {\n          ret.$set = update.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = update[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if ('$set' === op) {\n      if (!ret.$set) {\n        ret[op] = update[op];\n      }\n    } else {\n      ret[op] = update[op];\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Makes sure _path is set.\n *\n * @method _ensurePath\n * @param {String} method\n * @api private\n * @receiver Query\n */\n\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @method canMerge\n * @memberOf Query\n * @param {Object} conds\n * @return {Boolean}\n * @api private\n */\n\n/**\n * Returns default options for this query.\n *\n * @param {Model} model\n * @api private\n */\n\nQuery.prototype._optionsForExec = function(model) {\n  var options = Query.base._optionsForExec.call(this);\n\n  delete options.populate;\n  delete options.retainKeyOrder;\n  model = model || this.model;\n\n  if (!model) {\n    return options;\n  }\n\n  if (!('safe' in options) && model.schema.options.safe) {\n    options.safe = model.schema.options.safe;\n  }\n\n  if (!('readPreference' in options) && model.schema.options.read) {\n    options.readPreference = model.schema.options.read;\n  }\n\n  return options;\n};\n\n/**\n * Sets the lean option.\n *\n * Documents returned from queries with the `lean` option enabled are plain javascript objects, not [MongooseDocuments](#document-js). They have no `save` method, getters/setters or other Mongoose magic applied.\n *\n * ####Example:\n *\n *     new Query().lean() // true\n *     new Query().lean(true)\n *     new Query().lean(false)\n *\n *     Model.find().lean().exec(function (err, docs) {\n *       docs[0] instanceof mongoose.Document // false\n *     });\n *\n * This is a [great](https://groups.google.com/forum/#!topic/mongoose-orm/u2_DzDydcnA/discussion) option in high-performance read-only scenarios, especially when combined with [stream](#query_Query-stream).\n *\n * @param {Boolean} bool defaults to true\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.lean = function(v) {\n  this._mongooseOptions.lean = arguments.length ? !!v : true;\n  return this;\n};\n\n/**\n * Getter/setter around the current mongoose-specific options for this query\n * (populate, lean, etc.)\n *\n * @param {Object} options if specified, overwrites the current options\n * @returns {Object} the options\n * @api public\n */\n\nQuery.prototype.mongooseOptions = function(v) {\n  if (arguments.length > 0) {\n    this._mongooseOptions = v;\n  }\n  return this._mongooseOptions;\n};\n\n/**\n * Thunk around find()\n *\n * @param {Function} [callback]\n * @return {Query} this\n * @api private\n */\nQuery.prototype._find = function(callback) {\n  if (this._castError) {\n    callback(this._castError);\n    return this;\n  }\n\n  this._applyPaths();\n  this._fields = this._castFields(this._fields);\n\n  var fields = this._fieldsForExec();\n  var options = this._mongooseOptions;\n  var _this = this;\n\n  var cb = function(err, docs) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (docs.length === 0) {\n      return callback(null, docs);\n    }\n\n    if (!options.populate) {\n      return options.lean === true\n          ? callback(null, docs)\n          : completeMany(_this.model, docs, fields, null, callback);\n    }\n\n    var pop = helpers.preparePopulationOptionsMQ(_this, options);\n    pop.__noPromise = true;\n    _this.model.populate(docs, pop, function(err, docs) {\n      if (err) return callback(err);\n      return options.lean === true\n          ? callback(null, docs)\n          : completeMany(_this.model, docs, fields, pop, callback);\n    });\n  };\n\n  return Query.base.find.call(this, {}, cb);\n};\n\n/**\n * Finds documents.\n *\n * When no `callback` is passed, the query is not executed. When the query is executed, the result will be an array of documents.\n *\n * ####Example\n *\n *     query.find({ name: 'Los Pollos Hermanos' }).find(callback)\n *\n * @param {Object} [criteria] mongodb selector\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.find = function(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n\n  conditions = utils.toObject(conditions);\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  prepareDiscriminatorCriteria(this);\n\n  try {\n    this.cast(this.model);\n    this._castError = null;\n  } catch (err) {\n    this._castError = err;\n  }\n\n  // if we don't have a callback, then just return the query object\n  if (!callback) {\n    return Query.base.find.call(this);\n  }\n\n  this._find(callback);\n\n  return this;\n};\n\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */\n\nQuery.prototype.merge = function(source) {\n  if (!source) {\n    return this;\n  }\n\n  var opts = { retainKeyOrder: this.options.retainKeyOrder, overwrite: true };\n\n  if (source instanceof Query) {\n    // if source has a feature, apply it to ourselves\n\n    if (source._conditions) {\n      utils.merge(this._conditions, source._conditions, opts);\n    }\n\n    if (source._fields) {\n      this._fields || (this._fields = {});\n      utils.merge(this._fields, source._fields, opts);\n    }\n\n    if (source.options) {\n      this.options || (this.options = {});\n      utils.merge(this.options, source.options, opts);\n    }\n\n    if (source._update) {\n      this._update || (this._update = {});\n      utils.mergeClone(this._update, source._update);\n    }\n\n    if (source._distinct) {\n      this._distinct = source._distinct;\n    }\n\n    return this;\n  }\n\n  // plain object\n  utils.merge(this._conditions, source, opts);\n\n  return this;\n};\n\n/*!\n * hydrates many documents\n *\n * @param {Model} model\n * @param {Array} docs\n * @param {Object} fields\n * @param {Query} self\n * @param {Array} [pop] array of paths used in population\n * @param {Function} callback\n */\n\nfunction completeMany(model, docs, fields, pop, callback) {\n  var arr = [];\n  var count = docs.length;\n  var len = count;\n  var opts = pop ?\n  {populated: pop}\n      : undefined;\n  function init(err) {\n    if (err) return callback(err);\n    --count || callback(null, arr);\n  }\n  for (var i = 0; i < len; ++i) {\n    arr[i] = helpers.createModel(model, docs[i], fields);\n    arr[i].init(docs[i], opts, init);\n  }\n}\n\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */\n\nQuery.prototype.collation = function(value) {\n  if (this.options == null) {\n    this.options = {};\n  }\n  this.options.collation = value;\n  return this;\n};\n\n/**\n * Thunk around findOne()\n *\n * @param {Function} [callback]\n * @see findOne http://docs.mongodb.org/manual/reference/method/db.collection.findOne/\n * @api private\n */\n\nQuery.prototype._findOne = function(callback) {\n  if (this._castError) {\n    return callback(this._castError);\n  }\n\n  this._applyPaths();\n  this._fields = this._castFields(this._fields);\n\n  var options = this._mongooseOptions;\n  var projection = this._fieldsForExec();\n  var _this = this;\n\n  // don't pass in the conditions because we already merged them in\n  Query.base.findOne.call(_this, {}, function(err, doc) {\n    if (err) {\n      return callback(err);\n    }\n    if (!doc) {\n      return callback(null, null);\n    }\n\n    if (!options.populate) {\n      return options.lean === true\n          ? callback(null, doc)\n          : completeOne(_this.model, doc, null, {}, projection, null, callback);\n    }\n\n    var pop = helpers.preparePopulationOptionsMQ(_this, options);\n    pop.__noPromise = true;\n    _this.model.populate(doc, pop, function(err, doc) {\n      if (err) {\n        return callback(err);\n      }\n      return options.lean === true\n          ? callback(null, doc)\n          : completeOne(_this.model, doc, null, {}, projection, pop, callback);\n    });\n  });\n};\n\n/**\n * Declares the query a findOne operation. When executed, the first found document is passed to the callback.\n *\n * Passing a `callback` executes the query. The result of the query is a single document.\n *\n * * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `Model.findById()`\n * instead.\n *\n * ####Example\n *\n *     var query  = Kitten.where({ color: 'white' });\n *     query.findOne(function (err, kitten) {\n *       if (err) return handleError(err);\n *       if (kitten) {\n *         // doc may be null if no document matched\n *       }\n *     });\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @param {Object} [projection] optional fields to return\n * @param {Function} [callback] optional params are (error, document)\n * @return {Query} this\n * @see findOne http://docs.mongodb.org/manual/reference/method/db.collection.findOne/\n * @see Query.select #query_Query-select\n * @api public\n */\n\nQuery.prototype.findOne = function(conditions, projection, options, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = null;\n    projection = null;\n    options = null;\n  } else if (typeof projection === 'function') {\n    callback = projection;\n    options = null;\n    projection = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  // make sure we don't send in the whole Document to merge()\n  conditions = utils.toObject(conditions);\n\n  this.op = 'findOne';\n\n  if (options) {\n    this.setOptions(options);\n  }\n\n  if (projection) {\n    this.select(projection);\n  }\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  } else if (conditions != null) {\n    throw new Error('Invalid argument to findOne(): ' +\n      util.inspect(conditions));\n  }\n\n  prepareDiscriminatorCriteria(this);\n\n  try {\n    this.cast(this.model);\n    this._castError = null;\n  } catch (err) {\n    this._castError = err;\n  }\n\n  if (!callback) {\n    // already merged in the conditions, don't need to send them in.\n    return Query.base.findOne.call(this);\n  }\n\n  this._findOne(callback);\n\n  return this;\n};\n\n/**\n * Thunk around count()\n *\n * @param {Function} [callback]\n * @see count http://docs.mongodb.org/manual/reference/method/db.collection.count/\n * @api private\n */\n\nQuery.prototype._count = function(callback) {\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    process.nextTick(function() {\n      callback(err);\n    });\n    return this;\n  }\n\n  var conds = this._conditions;\n  var options = this._optionsForExec();\n\n  this._collection.count(conds, options, utils.tick(callback));\n};\n\n/**\n * Specifying this query as a `count` query.\n *\n * Passing a `callback` executes the query.\n *\n * ####Example:\n *\n *     var countQuery = model.where({ 'color': 'black' }).count();\n *\n *     query.count({ color: 'black' }).count(callback)\n *\n *     query.count({ color: 'black' }, callback)\n *\n *     query.where('color', 'black').count(function (err, count) {\n *       if (err) return handleError(err);\n *       console.log('there are %d kittens', count);\n *     })\n *\n * @param {Object} [criteria] mongodb selector\n * @param {Function} [callback] optional params are (error, count)\n * @return {Query} this\n * @see count http://docs.mongodb.org/manual/reference/method/db.collection.count/\n * @api public\n */\n\nQuery.prototype.count = function(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = undefined;\n  }\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  this.op = 'count';\n  if (!callback) {\n    return this;\n  }\n\n  this._count(callback);\n\n  return this;\n};\n\n/**\n * Declares or executes a distict() operation.\n *\n * Passing a `callback` executes the query.\n *\n * ####Example\n *\n *     distinct(field, conditions, callback)\n *     distinct(field, conditions)\n *     distinct(field, callback)\n *     distinct(field)\n *     distinct(callback)\n *     distinct()\n *\n * @param {String} [field]\n * @param {Object|Query} [criteria]\n * @param {Function} [callback] optional params are (error, arr)\n * @return {Query} this\n * @see distinct http://docs.mongodb.org/manual/reference/method/db.collection.distinct/\n * @api public\n */\n\nQuery.prototype.distinct = function(field, conditions, callback) {\n  if (!callback) {\n    if (typeof conditions === 'function') {\n      callback = conditions;\n      conditions = undefined;\n    } else if (typeof field === 'function') {\n      callback = field;\n      field = undefined;\n      conditions = undefined;\n    }\n  }\n\n  conditions = utils.toObject(conditions);\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    if (!callback) {\n      throw err;\n    }\n    callback(err);\n    return this;\n  }\n\n  return Query.base.distinct.call(this, {}, field, callback);\n};\n\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The\n * sort order of each path is ascending unless the path name is prefixed with `-`\n * which will be treated as descending.\n *\n * ####Example\n *\n *     // sort by \"field\" ascending and \"test\" descending\n *     query.sort({ field: 'asc', test: -1 });\n *\n *     // equivalent\n *     query.sort('field -test');\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String} arg\n * @return {Query} this\n * @see cursor.sort http://docs.mongodb.org/manual/reference/method/cursor.sort/\n * @api public\n */\n\nQuery.prototype.sort = function(arg) {\n  if (arguments.length > 1) {\n    throw new Error('sort() only takes 1 Argument');\n  }\n\n  return Query.base.sort.call(this, arg);\n};\n\n/**\n * Declare and/or execute this query as a remove() operation.\n *\n * ####Example\n *\n *     Model.remove({ artist: 'Anne Murray' }, callback)\n *\n * ####Note\n *\n * The operation is only executed when a callback is passed. To force execution without a callback, you must first call `remove()` and then execute it by using the `exec()` method.\n *\n *     // not executed\n *     var query = Model.find().remove({ name: 'Anne Murray' })\n *\n *     // executed\n *     query.remove({ name: 'Anne Murray' }, callback)\n *     query.remove({ name: 'Anne Murray' }).remove(callback)\n *\n *     // executed without a callback\n *     query.exec()\n *\n *     // summary\n *     query.remove(conds, fn); // executes\n *     query.remove(conds)\n *     query.remove(fn) // executes\n *     query.remove()\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @param {Function} [callback] optional params are (error, writeOpResult)\n * @return {Query} this\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @see remove http://docs.mongodb.org/manual/reference/method/db.collection.remove/\n * @api public\n */\n\nQuery.prototype.remove = function(cond, callback) {\n  if (typeof cond === 'function') {\n    callback = cond;\n    cond = null;\n  }\n\n  var cb = typeof callback === 'function';\n\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    if (cb) return process.nextTick(callback.bind(null, err));\n    return this;\n  }\n\n  return Query.base.remove.call(this, cond, callback);\n};\n\n/**\n * Declare and/or execute this query as a `deleteOne()` operation. Works like\n * remove, except it deletes at most one document regardless of the `justOne`\n * option.\n *\n * ####Example\n *\n *     Character.deleteOne({ name: 'Eddard Stark' }, callback)\n *     Character.deleteOne({ name: 'Eddard Stark' }).then(next)\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @param {Function} [callback] optional params are (error, writeOpResult)\n * @return {Query} this\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @see remove http://docs.mongodb.org/manual/reference/method/db.collection.remove/\n * @api public\n */\n\nQuery.prototype.deleteOne = function(cond, callback) {\n  if (typeof cond === 'function') {\n    callback = cond;\n    cond = null;\n  }\n\n  var cb = typeof callback === 'function';\n\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    if (cb) return process.nextTick(callback.bind(null, err));\n    return this;\n  }\n\n  return Query.base.deleteOne.call(this, cond, callback);\n};\n\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Works like\n * remove, except it deletes _every_ document that matches `criteria` in the\n * collection, regardless of the value of `justOne`.\n *\n * ####Example\n *\n *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }, callback)\n *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }).then(next)\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @param {Function} [callback] optional params are (error, writeOpResult)\n * @return {Query} this\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @see remove http://docs.mongodb.org/manual/reference/method/db.collection.remove/\n * @api public\n */\n\nQuery.prototype.deleteMany = function(cond, callback) {\n  if (typeof cond === 'function') {\n    callback = cond;\n    cond = null;\n  }\n\n  var cb = typeof callback === 'function';\n\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    if (cb) return process.nextTick(callback.bind(null, err));\n    return this;\n  }\n\n  return Query.base.deleteMany.call(this, cond, callback);\n};\n\n/*!\n * hydrates a document\n *\n * @param {Model} model\n * @param {Document} doc\n * @param {Object} res 3rd parameter to callback\n * @param {Object} fields\n * @param {Query} self\n * @param {Array} [pop] array of paths used in population\n * @param {Function} callback\n */\n\nfunction completeOne(model, doc, res, options, fields, pop, callback) {\n  var opts = pop ?\n  {populated: pop}\n      : undefined;\n\n  var casted = helpers.createModel(model, doc, fields);\n  casted.init(doc, opts, function(err) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (options.rawResult) {\n      res.value = casted;\n      return callback(null, res);\n    }\n    if (options.passRawResult) {\n      return callback(null, casted, decorateResult(res));\n    }\n    callback(null, casted);\n  });\n}\n\n/*!\n * If the model is a discriminator type and not root, then add the key & value to the criteria.\n */\n\nfunction prepareDiscriminatorCriteria(query) {\n  if (!query || !query.model || !query.model.schema) {\n    return;\n  }\n\n  var schema = query.model.schema;\n\n  if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {\n    query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;\n  }\n}\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed.\n *\n * ####Available options\n *\n * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n * - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).\n * - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * - `context` (string) if set to 'query' and `runValidators` is on, `this` will refer to the query in custom validator functions that update validation runs. Does nothing if `runValidators` is false.\n *\n * ####Callback Signature\n *     function(error, doc) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *     }\n *\n * ####Examples\n *\n *     query.findOneAndUpdate(conditions, update, options, callback) // executes\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     query.findOneAndUpdate(conditions, update, callback) // executes\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     query.findOneAndUpdate(update, callback)             // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     query.findOneAndUpdate(callback)                     // executes\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @method findOneAndUpdate\n * @memberOf Query\n * @param {Object|Query} [query]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @param {Boolean} [options.passRawResult] if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)\n * @param {Function} [callback] optional params are (error, doc), _unless_ `passRawResult` is used, in which case params are (error, doc, writeOpResult)\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndUpdate = function(criteria, doc, options, callback) {\n  this.op = 'findOneAndUpdate';\n  this._validate();\n\n  switch (arguments.length) {\n    case 3:\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      break;\n    case 2:\n      if (typeof doc === 'function') {\n        callback = doc;\n        doc = criteria;\n        criteria = undefined;\n      }\n      options = undefined;\n      break;\n    case 1:\n      if (typeof criteria === 'function') {\n        callback = criteria;\n        criteria = options = doc = undefined;\n      } else {\n        doc = criteria;\n        criteria = options = undefined;\n      }\n  }\n\n  if (mquery.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  // apply doc\n  if (doc) {\n    this._mergeUpdate(doc);\n  }\n\n  if (options) {\n    options = utils.clone(options, { retainKeyOrder: true });\n    if (options.projection) {\n      this.select(options.projection);\n      delete options.projection;\n    }\n    if (options.fields) {\n      this.select(options.fields);\n      delete options.fields;\n    }\n\n    this.setOptions(options);\n  }\n\n  if (!callback) {\n    return this;\n  }\n\n  return this._findOneAndUpdate(callback);\n};\n\n/*!\n * Thunk around findOneAndUpdate()\n *\n * @param {Function} [callback]\n * @api private\n */\n\nQuery.prototype._findOneAndUpdate = function(callback) {\n  this._findAndModify('update', callback);\n  return this;\n};\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.\n *\n * Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback` is passed.\n *\n * ####Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n *\n * ####Callback Signature\n *     function(error, doc, result) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *       // result: [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n *     }\n *\n * ####Examples\n *\n *     A.where().findOneAndRemove(conditions, options, callback) // executes\n *     A.where().findOneAndRemove(conditions, options)  // return Query\n *     A.where().findOneAndRemove(conditions, callback) // executes\n *     A.where().findOneAndRemove(conditions) // returns Query\n *     A.where().findOneAndRemove(callback)   // executes\n *     A.where().findOneAndRemove()           // returns Query\n *\n * @method findOneAndRemove\n * @memberOf Query\n * @param {Object} [conditions]\n * @param {Object} [options]\n * @param {Boolean} [options.passRawResult] if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)\n * @param {Function} [callback] optional params are (error, document)\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nQuery.prototype.findOneAndRemove = function(conditions, options, callback) {\n  this.op = 'findOneAndRemove';\n  this._validate();\n\n  switch (arguments.length) {\n    case 2:\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      break;\n    case 1:\n      if (typeof conditions === 'function') {\n        callback = conditions;\n        conditions = undefined;\n        options = undefined;\n      }\n      break;\n  }\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  options && this.setOptions(options);\n\n  if (!callback) {\n    return this;\n  }\n\n  this._findOneAndRemove(callback);\n\n  return this;\n};\n\n/*!\n * Thunk around findOneAndRemove()\n *\n * @param {Function} [callback]\n * @return {Query} this\n * @api private\n */\nQuery.prototype._findOneAndRemove = function(callback) {\n  Query.base.findOneAndRemove.call(this, callback);\n};\n\n/*!\n * ignore\n */\n\nfunction decorateResult(res) {\n  if (res) {\n    res._kareemIgnore = true;\n  }\n  return res;\n}\n\n/*!\n * Override mquery.prototype._findAndModify to provide casting etc.\n *\n * @param {String} type - either \"remove\" or \"update\"\n * @param {Function} callback\n * @api private\n */\n\nQuery.prototype._findAndModify = function(type, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('Expected callback in _findAndModify');\n  }\n\n  var model = this.model;\n  var schema = model.schema;\n  var _this = this;\n  var castedQuery;\n  var castedDoc;\n  var fields;\n  var opts;\n  var doValidate;\n\n  castedQuery = castQuery(this);\n  if (castedQuery instanceof Error) {\n    return callback(castedQuery);\n  }\n\n  opts = this._optionsForExec(model);\n\n  if ('strict' in opts) {\n    this._mongooseOptions.strict = opts.strict;\n  }\n\n  if (type === 'remove') {\n    opts.remove = true;\n  } else {\n    if (!('new' in opts)) {\n      opts.new = false;\n    }\n    if (!('upsert' in opts)) {\n      opts.upsert = false;\n    }\n    if (opts.upsert || opts['new']) {\n      opts.remove = false;\n    }\n\n    castedDoc = castDoc(this, opts.overwrite);\n    castedDoc = setDefaultsOnInsert(this, schema, castedDoc, opts);\n    if (!castedDoc) {\n      if (opts.upsert) {\n        // still need to do the upsert to empty doc\n        var doc = utils.clone(castedQuery);\n        delete doc._id;\n        castedDoc = {$set: doc};\n      } else {\n        return this.findOne(callback);\n      }\n    } else if (castedDoc instanceof Error) {\n      return callback(castedDoc);\n    } else {\n      // In order to make MongoDB 2.6 happy (see\n      // https://jira.mongodb.org/browse/SERVER-12266 and related issues)\n      // if we have an actual update document but $set is empty, junk the $set.\n      if (castedDoc.$set && Object.keys(castedDoc.$set).length === 0) {\n        delete castedDoc.$set;\n      }\n    }\n\n    doValidate = updateValidators(this, schema, castedDoc, opts);\n  }\n\n  this._applyPaths();\n\n  var options = this._mongooseOptions;\n\n  if (this._fields) {\n    fields = utils.clone(this._fields);\n    opts.fields = this._castFields(fields);\n    if (opts.fields instanceof Error) {\n      return callback(opts.fields);\n    }\n  }\n\n  if (opts.sort) convertSortToArray(opts);\n\n  var cb = function(err, doc, res) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!doc || (utils.isObject(doc) && Object.keys(doc).length === 0)) {\n      if (opts.rawResult) {\n        return callback(null, res);\n      }\n      // opts.passRawResult will be deprecated soon\n      if (opts.passRawResult) {\n        return callback(null, null, decorateResult(res));\n      }\n      return callback(null, null);\n    }\n\n    if (!options.populate) {\n      if (options.lean === true) {\n        return _completeOneLean(doc, res, opts, callback);\n      }\n      return completeOne(_this.model, doc, res, opts, fields, null, callback);\n    }\n\n    var pop = helpers.preparePopulationOptionsMQ(_this, options);\n    pop.__noPromise = true;\n    _this.model.populate(doc, pop, function(err, doc) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (options.lean === true) {\n        return _completeOneLean(doc, res, opts, callback);\n      }\n      return completeOne(_this.model, doc, res, opts, fields, pop, callback);\n    });\n  };\n\n  if (opts.runValidators && doValidate) {\n    var _callback = function(error) {\n      if (error) {\n        return callback(error);\n      }\n      _this._collection.findAndModify(castedQuery, castedDoc, opts, utils.tick(function(error, res) {\n        return cb(error, res ? res.value : res, res);\n      }));\n    };\n\n    try {\n      doValidate(_callback);\n    } catch (error) {\n      callback(error);\n    }\n  } else {\n    this._collection.findAndModify(castedQuery, castedDoc, opts, utils.tick(function(error, res) {\n      return cb(error, res ? res.value : res, res);\n    }));\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _completeOneLean(doc, res, opts, callback) {\n  if (opts.rawResult) {\n    return callback(null, res);\n  }\n  if (opts.passRawResult) {\n    return callback(null, doc, decorateResult(res));\n  }\n  return callback(null, doc);\n}\n\n/*!\n * Override mquery.prototype._mergeUpdate to handle mongoose objects in\n * updates.\n *\n * @param {Object} doc\n * @api private\n */\n\nQuery.prototype._mergeUpdate = function(doc) {\n  if (!this._update) this._update = {};\n  if (doc instanceof Query) {\n    if (doc._update) {\n      utils.mergeClone(this._update, doc._update);\n    }\n  } else {\n    utils.mergeClone(this._update, doc);\n  }\n};\n\n/*!\n * The mongodb driver 1.3.23 only supports the nested array sort\n * syntax. We must convert it or sorting findAndModify will not work.\n */\n\nfunction convertSortToArray(opts) {\n  if (Array.isArray(opts.sort)) {\n    return;\n  }\n  if (!utils.isObject(opts.sort)) {\n    return;\n  }\n\n  var sort = [];\n\n  for (var key in opts.sort) {\n    if (utils.object.hasOwnProperty(opts.sort, key)) {\n      sort.push([key, opts.sort[key]]);\n    }\n  }\n\n  opts.sort = sort;\n}\n\n/*!\n * Internal thunk for .update()\n *\n * @param {Function} callback\n * @see Model.update #model_Model.update\n * @api private\n */\nQuery.prototype._execUpdate = function(callback) {\n  var schema = this.model.schema;\n  var doValidate;\n  var _this;\n\n  var castedQuery = this._conditions;\n  var castedDoc = this._update;\n  var options = this.options;\n\n  if (this._castError) {\n    callback(this._castError);\n    return this;\n  }\n\n  if (this.options.runValidators) {\n    _this = this;\n    doValidate = updateValidators(this, schema, castedDoc, options);\n    var _callback = function(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      Query.base.update.call(_this, castedQuery, castedDoc, options, callback);\n    };\n    try {\n      doValidate(_callback);\n    } catch (err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    }\n    return this;\n  }\n\n  Query.base.update.call(this, castedQuery, castedDoc, options, callback);\n  return this;\n};\n\n/*!\n * Internal thunk for .updateMany()\n *\n * @param {Function} callback\n * @see Model.update #model_Model.update\n * @api private\n */\nQuery.prototype._updateMany = function(callback) {\n  var schema = this.model.schema;\n  var doValidate;\n  var _this;\n\n  var castedQuery = this._conditions;\n  var castedDoc = this._update;\n  var options = this.options;\n\n  if (this._castError) {\n    callback(this._castError);\n    return this;\n  }\n\n  if (this.options.runValidators) {\n    _this = this;\n    doValidate = updateValidators(this, schema, castedDoc, options);\n    var _callback = function(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      Query.base.updateMany.call(_this, castedQuery, castedDoc, options, callback);\n    };\n    try {\n      doValidate(_callback);\n    } catch (err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    }\n    return this;\n  }\n\n  Query.base.updateMany.call(this, castedQuery, castedDoc, options, callback);\n  return this;\n};\n\n/*!\n * Internal thunk for .updateOne()\n *\n * @param {Function} callback\n * @see Model.update #model_Model.update\n * @api private\n */\nQuery.prototype._updateOne = function(callback) {\n  var schema = this.model.schema;\n  var doValidate;\n  var _this;\n\n  var castedQuery = this._conditions;\n  var castedDoc = this._update;\n  var options = this.options;\n\n  if (this._castError) {\n    callback(this._castError);\n    return this;\n  }\n\n  if (this.options.runValidators) {\n    _this = this;\n    doValidate = updateValidators(this, schema, castedDoc, options);\n    var _callback = function(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      Query.base.updateOne.call(_this, castedQuery, castedDoc, options, callback);\n    };\n    try {\n      doValidate(_callback);\n    } catch (err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    }\n    return this;\n  }\n\n  Query.base.updateOne.call(this, castedQuery, castedDoc, options, callback);\n  return this;\n};\n\n/*!\n * Internal thunk for .replaceOne()\n *\n * @param {Function} callback\n * @see Model.replaceOne #model_Model.replaceOne\n * @api private\n */\nQuery.prototype._replaceOne = function(callback) {\n  var schema = this.model.schema;\n  var doValidate;\n  var _this;\n\n  var castedQuery = this._conditions;\n  var castedDoc = this._update;\n  var options = this.options;\n\n  if (this._castError) {\n    callback(this._castError);\n    return this;\n  }\n\n  if (this.options.runValidators) {\n    _this = this;\n    doValidate = updateValidators(this, schema, castedDoc, options);\n    var _callback = function(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      Query.base.updateMany.call(_this, castedQuery, castedDoc, options, callback);\n    };\n    try {\n      doValidate(_callback);\n    } catch (err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    }\n    return this;\n  }\n\n  Query.base.replaceOne.call(this, castedQuery, castedDoc, options, callback);\n  return this;\n};\n\n/**\n * Declare and/or execute this query as an update() operation.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * ####Example\n *\n *     Model.where({ _id: id }).update({ title: 'words' })\n *\n *     // becomes\n *\n *     Model.where({ _id: id }).update({ $set: { title: 'words' }})\n *\n * ####Valid options:\n *\n *  - `safe` (boolean) safe mode (defaults to value set in schema (true))\n *  - `upsert` (boolean) whether to create the doc if it doesn't match (false)\n *  - `multi` (boolean) whether multiple documents should be updated (false)\n *  - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n *  - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).\n *  - `strict` (boolean) overrides the `strict` option for this update\n *  - `overwrite` (boolean) disables update-only mode, allowing you to overwrite the doc (false)\n *  - `context` (string) if set to 'query' and `runValidators` is on, `this` will refer to the query in custom validator functions that update validation runs. Does nothing if `runValidators` is false.\n *\n * ####Note\n *\n * Passing an empty object `{}` as the doc will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.\n *\n * ####Note\n *\n * The operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the `exec()` method.\n *\n *     var q = Model.where({ _id: id });\n *     q.update({ $set: { name: 'bob' }}).update(); // not executed\n *\n *     q.update({ $set: { name: 'bob' }}).exec(); // executed\n *\n *     // keys that are not $atomic ops become $set.\n *     // this executes the same command as the previous example.\n *     q.update({ name: 'bob' }).exec();\n *\n *     // overwriting with empty docs\n *     var q = Model.where({ _id: id }).setOptions({ overwrite: true })\n *     q.update({ }, callback); // executes\n *\n *     // multi update with overwrite to empty doc\n *     var q = Model.where({ _id: id });\n *     q.setOptions({ multi: true, overwrite: true })\n *     q.update({ });\n *     q.update(callback); // executed\n *\n *     // multi updates\n *     Model.where()\n *          .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)\n *\n *     // more multi updates\n *     Model.where()\n *          .setOptions({ multi: true })\n *          .update({ $set: { arr: [] }}, callback)\n *\n *     // single update by default\n *     Model.where({ email: 'address@example.com' })\n *          .update({ $inc: { counter: 1 }}, callback)\n *\n * API summary\n *\n *     update(criteria, doc, options, cb) // executes\n *     update(criteria, doc, options)\n *     update(criteria, doc, cb) // executes\n *     update(criteria, doc)\n *     update(doc, cb) // executes\n *     update(doc)\n *     update(cb) // executes\n *     update(true) // executes\n *     update()\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Function} [callback] optional, params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update #model_Model.update\n * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @api public\n */\n\nQuery.prototype.update = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'update', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as an updateMany() operation. Same as\n * `update()`, except MongoDB will update _all_ documents that match\n * `criteria` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Function} [callback] optional params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update #model_Model.update\n * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @api public\n */\n\nQuery.prototype.updateMany = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'updateMany', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as an updateOne() operation. Same as\n * `update()`, except MongoDB will update _only_ the first document that\n * matches `criteria` regardless of the value of the `multi` option.\n *\n * **Note** updateOne will _not_ fire update middleware. Use `pre('updateOne')`\n * and `post('updateOne')` instead.\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update #model_Model.update\n * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @api public\n */\n\nQuery.prototype.updateOne = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'updateOne', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as a replaceOne() operation. Same as\n * `update()`, except MongoDB will replace the existing document and will\n * not accept any atomic operators (`$set`, etc.)\n *\n * **Note** replaceOne will _not_ fire update middleware. Use `pre('replaceOne')`\n * and `post('replaceOne')` instead.\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Function} [callback] optional params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update #model_Model.update\n * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @api public\n */\n\nQuery.prototype.replaceOne = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  this.setOptions({ overwrite: true });\n  return _update(this, 'replaceOne', conditions, doc, options, callback);\n};\n\n/*!\n * Internal helper for update, updateMany, updateOne, replaceOne\n */\n\nfunction _update(query, op, conditions, doc, options, callback) {\n  // make sure we don't send in the whole Document to merge()\n  query.op = op;\n  conditions = utils.toObject(conditions);\n\n  var oldCb = callback;\n  if (oldCb) {\n    if (typeof oldCb === 'function') {\n      callback = function(error, result) {\n        oldCb(error, result ? result.result : {ok: 0, n: 0, nModified: 0});\n      };\n    } else {\n      throw new Error('Invalid callback() argument.');\n    }\n  }\n\n  // strict is an option used in the update checking, make sure it gets set\n  if (options) {\n    if ('strict' in options) {\n      query._mongooseOptions.strict = options.strict;\n    }\n  }\n\n  // if doc is undefined at this point, this means this function is being\n  // executed by exec(not always see below). Grab the update doc from here in\n  // order to validate\n  // This could also be somebody calling update() or update({}). Probably not a\n  // common use case, check for _update to make sure we don't do anything bad\n  if (!doc && query._update) {\n    doc = query._updateForExec();\n  }\n\n  if (mquery.canMerge(conditions)) {\n    query.merge(conditions);\n  }\n\n  // validate the selector part of the query\n  var castedQuery = castQuery(query);\n  if (castedQuery instanceof Error) {\n    query._castError = castedQuery;\n    if (callback) {\n      callback(castedQuery);\n      return query;\n    } else if (!options || !options.dontThrowCastError) {\n      throw castedQuery;\n    }\n  }\n\n  // validate the update part of the query\n  var castedDoc;\n  try {\n    var $options = {retainKeyOrder: true};\n    if (options && options.minimize) {\n      $options.minimize = true;\n    }\n    castedDoc = query._castUpdate(utils.clone(doc, $options),\n      (options && options.overwrite) || op === 'replaceOne');\n  } catch (err) {\n    query._castError = castedQuery;\n    if (callback) {\n      callback(err);\n      return query;\n    } else if (!options || !options.dontThrowCastError) {\n      throw err;\n    }\n  }\n\n  castedDoc = setDefaultsOnInsert(query, query.schema, castedDoc, options);\n  if (!castedDoc) {\n    // Make sure promises know that this is still an update, see gh-2796\n    query.op = op;\n    callback && callback(null);\n    return query;\n  }\n\n  if (utils.isObject(options)) {\n    query.setOptions(options);\n  }\n\n  if (!query._update) {\n    query._update = castedDoc;\n  }\n\n  // Hooks\n  if (callback) {\n    if (op === 'update') {\n      return query._execUpdate(callback);\n    }\n    return query['_' + op](callback);\n  }\n\n  return Query.base[op].call(query, castedQuery, castedDoc, options, callback);\n}\n\n/**\n * Executes the query\n *\n * ####Examples:\n *\n *     var promise = query.exec();\n *     var promise = query.exec('update');\n *\n *     query.exec(callback);\n *     query.exec('find', callback);\n *\n * @param {String|Function} [operation]\n * @param {Function} [callback] optional params depend on the function being called\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.exec = function exec(op, callback) {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n\n  if (typeof op === 'function') {\n    callback = op;\n    op = null;\n  } else if (typeof op === 'string') {\n    this.op = op;\n  }\n\n  var _results;\n  var promise = new Promise.ES6(function(resolve, reject) {\n    if (!_this.op) {\n      resolve();\n      return;\n    }\n\n    _this[_this.op].call(_this, function(error, res) {\n      if (error) {\n        reject(error);\n        return;\n      }\n      _results = arguments;\n      resolve(res);\n    });\n  });\n\n  if (callback) {\n    promise.then(\n      function() {\n        callback.apply(null, _results);\n        return null;\n      },\n      function(error) {\n        callback(error);\n      }).\n      catch(function(error) {\n        // If we made it here, we must have an error in the callback re:\n        // gh-4500, so we need to emit.\n        setImmediate(function() {\n          _this.model.emit('error', error);\n        });\n      });\n  }\n\n  return promise;\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n * Like `.then()`, but only takes a rejection handler.\n *\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.catch = function(reject) {\n  return this.exec().then(null, reject);\n};\n\n/*!\n * Casts obj for an update command.\n *\n * @param {Object} obj\n * @return {Object} obj after casting its values\n * @api private\n */\n\nQuery.prototype._castUpdate = function _castUpdate(obj, overwrite) {\n  var strict;\n  if ('strict' in this._mongooseOptions) {\n    strict = this._mongooseOptions.strict;\n  } else if (this.schema && this.schema.options) {\n    strict = this.schema.options.strict;\n  } else {\n    strict = true;\n  }\n  return castUpdate(this.schema, obj, {\n    overwrite: overwrite,\n    strict: strict\n  });\n};\n\n/*!\n * castQuery\n * @api private\n */\n\nfunction castQuery(query) {\n  try {\n    return query.cast(query.model);\n  } catch (err) {\n    return err;\n  }\n}\n\n/*!\n * castDoc\n * @api private\n */\n\nfunction castDoc(query, overwrite) {\n  try {\n    return query._castUpdate(query._update, overwrite);\n  } catch (err) {\n    return err;\n  }\n}\n\n/**\n * Specifies paths which should be populated with other documents.\n *\n * ####Example:\n *\n *     Kitten.findOne().populate('owner').exec(function (err, kitten) {\n *       console.log(kitten.owner.name) // Max\n *     })\n *\n *     Kitten.find().populate({\n *         path: 'owner'\n *       , select: 'name'\n *       , match: { color: 'black' }\n *       , options: { sort: { name: -1 }}\n *     }).exec(function (err, kittens) {\n *       console.log(kittens[0].owner.name) // Zoopa\n *     })\n *\n *     // alternatively\n *     Kitten.find().populate('owner', 'name', null, {sort: { name: -1 }}).exec(function (err, kittens) {\n *       console.log(kittens[0].owner.name) // Zoopa\n *     })\n *\n * Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.\n *\n * @param {Object|String} path either the path to populate or an object specifying all parameters\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @see population ./populate.html\n * @see Query#select #query_Query-select\n * @see Model.populate #model_Model.populate\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.populate = function() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var res = utils.populate.apply(null, arguments);\n  var opts = this._mongooseOptions;\n\n  if (!utils.isObject(opts.populate)) {\n    opts.populate = {};\n  }\n\n  var pop = opts.populate;\n\n  for (var i = 0; i < res.length; ++i) {\n    var path = res[i].path;\n    if (pop[path] && pop[path].populate && res[i].populate) {\n      res[i].populate = pop[path].populate.concat(res[i].populate);\n    }\n    pop[res[i].path] = res[i];\n  }\n\n  return this;\n};\n\n/**\n * Casts this query to the schema of `model`\n *\n * ####Note\n *\n * If `obj` is present, it is cast instead of this query.\n *\n * @param {Model} model\n * @param {Object} [obj]\n * @return {Object}\n * @api public\n */\n\nQuery.prototype.cast = function(model, obj) {\n  obj || (obj = this._conditions);\n\n  try {\n    return cast(model.schema, obj, {\n      upsert: this.options && this.options.upsert,\n      strict: (this.options && this.options.strict) ||\n        (model.schema.options && model.schema.options.strict)\n    });\n  } catch (err) {\n    // CastError, assign model\n    if (typeof err.setModel === 'function') {\n      err.setModel(model);\n    }\n    throw err;\n  }\n};\n\n/**\n * Casts selected field arguments for field selection with mongo 2.2\n *\n *     query.select({ ids: { $elemMatch: { $in: [hexString] }})\n *\n * @param {Object} fields\n * @see https://github.com/Automattic/mongoose/issues/1091\n * @see http://docs.mongodb.org/manual/reference/projection/elemMatch/\n * @api private\n */\n\nQuery.prototype._castFields = function _castFields(fields) {\n  var selected,\n      elemMatchKeys,\n      keys,\n      key,\n      out,\n      i;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    elemMatchKeys = [];\n    i = keys.length;\n\n    // collect $elemMatch args\n    while (i--) {\n      key = keys[i];\n      if (fields[key].$elemMatch) {\n        selected || (selected = {});\n        selected[key] = fields[key];\n        elemMatchKeys.push(key);\n      }\n    }\n  }\n\n  if (selected) {\n    // they passed $elemMatch, cast em\n    try {\n      out = this.cast(this.model, selected);\n    } catch (err) {\n      return err;\n    }\n\n    // apply the casted field args\n    i = elemMatchKeys.length;\n    while (i--) {\n      key = elemMatchKeys[i];\n      fields[key] = out[key];\n    }\n  }\n\n  return fields;\n};\n\n/**\n * Applies schematype selected options to this query.\n * @api private\n */\n\nQuery.prototype._applyPaths = function applyPaths() {\n  this._fields = this._fields || {};\n  helpers.applyPaths(this._fields, this.model.schema);\n};\n\n/**\n * Returns a Node.js 0.8 style [read stream](http://nodejs.org/docs/v0.8.21/api/stream.html#stream_readable_stream) interface.\n *\n * ####Example\n *\n *     // follows the nodejs 0.8 stream api\n *     Thing.find({ name: /^hello/ }).stream().pipe(res)\n *\n *     // manual streaming\n *     var stream = Thing.find({ name: /^hello/ }).stream();\n *\n *     stream.on('data', function (doc) {\n *       // do something with the mongoose document\n *     }).on('error', function (err) {\n *       // handle the error\n *     }).on('close', function () {\n *       // the stream is closed\n *     });\n *\n * ####Valid options\n *\n *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data`.\n *\n * ####Example\n *\n *     // JSON.stringify all documents before emitting\n *     var stream = Thing.find().stream({ transform: JSON.stringify });\n *     stream.pipe(writeStream);\n *\n * @return {QueryStream}\n * @param {Object} [options]\n * @see QueryStream\n * @api public\n */\n\nQuery.prototype.stream = function stream(opts) {\n  this._applyPaths();\n  this._fields = this._castFields(this._fields);\n  return new QueryStream(this, opts);\n};\nQuery.prototype.stream = util.deprecate(Query.prototype.stream, 'Mongoose: ' +\n  'Query.prototype.stream() is deprecated in mongoose >= 4.5.0, ' +\n  'use Query.prototype.cursor() instead');\n\n/**\n * Returns a wrapper around a [mongodb driver cursor](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html).\n * A QueryCursor exposes a [Streams3](https://strongloop.com/strongblog/whats-new-io-js-beta-streams3/)-compatible\n * interface, as well as a `.next()` function.\n *\n * The `.cursor()` function triggers pre find hooks, but **not** post find hooks.\n *\n * ####Example\n *\n *     // There are 2 ways to use a cursor. First, as a stream:\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       on('data', function(doc) { console.log(doc); }).\n *       on('end', function() { console.log('Done!'); });\n *\n *     // Or you can use `.next()` to manually get the next doc in the stream.\n *     // `.next()` returns a promise, so you can use promises or callbacks.\n *     var cursor = Thing.find({ name: /^hello/ }).cursor();\n *     cursor.next(function(error, doc) {\n *       console.log(doc);\n *     });\n *\n *     // Because `.next()` returns a promise, you can use co\n *     // to easily iterate through all documents without loading them\n *     // all into memory.\n *     co(function*() {\n *       const cursor = Thing.find({ name: /^hello/ }).cursor();\n *       for (let doc = yield cursor.next(); doc != null; doc = yield cursor.next()) {\n *         console.log(doc);\n *       }\n *     });\n *\n * ####Valid options\n *\n *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data` and returned by `.next()`.\n *\n * @return {QueryCursor}\n * @param {Object} [options]\n * @see QueryCursor\n * @api public\n */\n\nQuery.prototype.cursor = function cursor(opts) {\n  this._applyPaths();\n  this._fields = this._castFields(this._fields);\n  this.setOptions({ fields: this._fieldsForExec() });\n  if (opts) {\n    this.setOptions(opts);\n  }\n\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    return (new QueryCursor(this, this.options))._markError(err);\n  }\n\n  return new QueryCursor(this, this.options);\n};\n\n// the rest of these are basically to support older Mongoose syntax with mquery\n\n/**\n * _DEPRECATED_ Alias of `maxScan`\n *\n * @deprecated\n * @see maxScan #query_Query-maxScan\n * @method maxscan\n * @memberOf Query\n */\n\nQuery.prototype.maxscan = Query.base.maxScan;\n\n/**\n * Sets the tailable option (for use with capped collections).\n *\n * ####Example\n *\n *     query.tailable() // true\n *     query.tailable(true)\n *     query.tailable(false)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} bool defaults to true\n * @param {Object} [opts] options to set\n * @param {Number} [opts.numberOfRetries] if cursor is exhausted, retry this many times before giving up\n * @param {Number} [opts.tailableRetryInterval] if cursor is exhausted, wait this many milliseconds before retrying\n * @see tailable http://docs.mongodb.org/manual/tutorial/create-tailable-cursor/\n * @api public\n */\n\nQuery.prototype.tailable = function(val, opts) {\n  // we need to support the tailable({ awaitdata : true }) as well as the\n  // tailable(true, {awaitdata :true}) syntax that mquery does not support\n  if (val && val.constructor.name === 'Object') {\n    opts = val;\n    val = true;\n  }\n\n  if (val === undefined) {\n    val = true;\n  }\n\n  if (opts && typeof opts === 'object') {\n    for (var key in opts) {\n      if (key === 'awaitdata') {\n        // For backwards compatibility\n        this.options[key] = !!opts[key];\n      } else {\n        this.options[key] = opts[key];\n      }\n    }\n  }\n\n  return Query.base.tailable.call(this, val);\n};\n\n/**\n * Declares an intersects query for `geometry()`.\n *\n * ####Example\n *\n *     query.where('path').intersects().geometry({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n *     query.where('path').intersects({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n * ####NOTE:\n *\n * **MUST** be used after `where()`.\n *\n * ####NOTE:\n *\n * In Mongoose 3.7, `intersects` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n *\n * @method intersects\n * @memberOf Query\n * @param {Object} [arg]\n * @return {Query} this\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @see geoIntersects http://docs.mongodb.org/manual/reference/operator/geoIntersects/\n * @api public\n */\n\n/**\n * Specifies a `$geometry` condition\n *\n * ####Example\n *\n *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     var polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     var polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * The argument is assigned to the most recent path passed to `where()`.\n *\n * ####NOTE:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * @method geometry\n * @memberOf Query\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * ####Example\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *\n * @method near\n * @memberOf Query\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see $near http://docs.mongodb.org/manual/reference/operator/near/\n * @see $nearSphere http://docs.mongodb.org/manual/reference/operator/nearSphere/\n * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\n/*!\n * Overwriting mquery is needed to support a couple different near() forms found in older\n * versions of mongoose\n * near([1,1])\n * near(1,1)\n * near(field, [1,2])\n * near(field, 1, 2)\n * In addition to all of the normal forms supported by mquery\n */\n\nQuery.prototype.near = function() {\n  var params = [];\n  var sphere = this._mongooseOptions.nearSphere;\n\n  // TODO refactor\n\n  if (arguments.length === 1) {\n    if (Array.isArray(arguments[0])) {\n      params.push({center: arguments[0], spherical: sphere});\n    } else if (typeof arguments[0] === 'string') {\n      // just passing a path\n      params.push(arguments[0]);\n    } else if (utils.isObject(arguments[0])) {\n      if (typeof arguments[0].spherical !== 'boolean') {\n        arguments[0].spherical = sphere;\n      }\n      params.push(arguments[0]);\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      params.push({center: [arguments[0], arguments[1]], spherical: sphere});\n    } else if (typeof arguments[0] === 'string' && Array.isArray(arguments[1])) {\n      params.push(arguments[0]);\n      params.push({center: arguments[1], spherical: sphere});\n    } else if (typeof arguments[0] === 'string' && utils.isObject(arguments[1])) {\n      params.push(arguments[0]);\n      if (typeof arguments[1].spherical !== 'boolean') {\n        arguments[1].spherical = sphere;\n      }\n      params.push(arguments[1]);\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else if (arguments.length === 3) {\n    if (typeof arguments[0] === 'string' && typeof arguments[1] === 'number'\n        && typeof arguments[2] === 'number') {\n      params.push(arguments[0]);\n      params.push({center: [arguments[1], arguments[2]], spherical: sphere});\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else {\n    throw new TypeError('invalid argument');\n  }\n\n  return Query.base.near.apply(this, params);\n};\n\n/**\n * _DEPRECATED_ Specifies a `$nearSphere` condition\n *\n * ####Example\n *\n *     query.where('loc').nearSphere({ center: [10, 10], maxDistance: 5 });\n *\n * **Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.\n *\n * ####Example\n *\n *     query.where('loc').near({ center: [10, 10], spherical: true });\n *\n * @deprecated\n * @see near() #query_Query-near\n * @see $near http://docs.mongodb.org/manual/reference/operator/near/\n * @see $nearSphere http://docs.mongodb.org/manual/reference/operator/nearSphere/\n * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/\n */\n\nQuery.prototype.nearSphere = function() {\n  this._mongooseOptions.nearSphere = true;\n  this.near.apply(this, arguments);\n  return this;\n};\n\n/**\n * Specifies a $polygon condition\n *\n * ####Example\n *\n *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])\n *     query.polygon('loc', [10,20], [13, 25], [7,15])\n *\n * @method polygon\n * @memberOf Query\n * @param {String|Array} [path]\n * @param {Array|Object} [coordinatePairs...]\n * @return {Query} this\n * @see $polygon http://docs.mongodb.org/manual/reference/operator/polygon/\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\n/**\n * Specifies a $box condition\n *\n * ####Example\n *\n *     var lowerLeft = [40.73083, -73.99756]\n *     var upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box({ ll : lowerLeft, ur : upperRight })\n *\n * @method box\n * @memberOf Query\n * @see $box http://docs.mongodb.org/manual/reference/operator/box/\n * @see within() Query#within #query_Query-within\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @param {Object} val\n * @param [Array] Upper Right Coords\n * @return {Query} this\n * @api public\n */\n\n/*!\n * this is needed to support the mongoose syntax of:\n * box(field, { ll : [x,y], ur : [x2,y2] })\n * box({ ll : [x,y], ur : [x2,y2] })\n */\n\nQuery.prototype.box = function(ll, ur) {\n  if (!Array.isArray(ll) && utils.isObject(ll)) {\n    ur = ll.ur;\n    ll = ll.ll;\n  }\n  return Query.base.box.call(this, ll, ur);\n};\n\n/**\n * Specifies a $center or $centerSphere condition.\n *\n * ####Example\n *\n *     var area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     // alternatively\n *     query.circle('loc', area);\n *\n *     // spherical calculations\n *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     // alternatively\n *     query.circle('loc', area);\n *\n * New in 3.7.0\n *\n * @method circle\n * @memberOf Query\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see $center http://docs.mongodb.org/manual/reference/operator/center/\n * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/\n * @see $geoWithin http://docs.mongodb.org/manual/reference/operator/geoWithin/\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\n/**\n * _DEPRECATED_ Alias for [circle](#query_Query-circle)\n *\n * **Deprecated.** Use [circle](#query_Query-circle) instead.\n *\n * @deprecated\n * @method center\n * @memberOf Query\n * @api public\n */\n\nQuery.prototype.center = Query.base.circle;\n\n/**\n * _DEPRECATED_ Specifies a $centerSphere condition\n *\n * **Deprecated.** Use [circle](#query_Query-circle) instead.\n *\n * ####Example\n *\n *     var area = { center: [50, 50], radius: 10 };\n *     query.where('loc').within().centerSphere(area);\n *\n * @deprecated\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/\n * @api public\n */\n\nQuery.prototype.centerSphere = function() {\n  if (arguments[0] && arguments[0].constructor.name === 'Object') {\n    arguments[0].spherical = true;\n  }\n\n  if (arguments[1] && arguments[1].constructor.name === 'Object') {\n    arguments[1].spherical = true;\n  }\n\n  Query.base.circle.apply(this, arguments);\n};\n\n/**\n * Determines if field selection has been made.\n *\n * @method selected\n * @memberOf Query\n * @return {Boolean}\n * @api public\n */\n\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively() // false\n *     query.select('name')\n *     query.selectedInclusively() // true\n *\n * @method selectedInclusively\n * @memberOf Query\n * @return {Boolean}\n * @api public\n */\n\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExclusively() // false\n *     query.select('-name')\n *     query.selectedExclusively() // true\n *     query.selectedInclusively() // false\n *\n * @method selectedExclusively\n * @memberOf Query\n * @return {Boolean}\n * @api public\n */\n\n/*!\n * Export\n */\n\nmodule.exports = Query;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/querycursor.js":"/*!\n * Module dependencies.\n */\n\nvar PromiseProvider = require('./promise_provider');\nvar Readable = require('stream').Readable;\nvar helpers = require('./queryhelpers');\nvar util = require('util');\n\n/**\n * A QueryCursor is a concurrency primitive for processing query results\n * one document at a time. A QueryCursor fulfills the [Node.js streams3 API](https://strongloop.com/strongblog/whats-new-io-js-beta-streams3/),\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * QueryCursors execute the model's pre find hooks, but **not** the model's\n * post find hooks.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Query#cursor()`](/docs/api.html#query_Query-cursor) instead.\n *\n * @param {Query} query\n * @param {Object} options query options passed to `.find()`\n * @inherits Readable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction QueryCursor(query, options) {\n  Readable.call(this, { objectMode: true });\n\n  this.cursor = null;\n  this.query = query;\n  this._transforms = options.transform ? [options.transform] : [];\n  var _this = this;\n  var model = query.model;\n  model.hooks.execPre('find', query, function() {\n    model.collection.find(query._conditions, options, function(err, cursor) {\n      if (_this._error) {\n        cursor.close(function() {});\n        _this.listeners('error').length > 0 && _this.emit('error', _this._error);\n      }\n      if (err) {\n        return _this.emit('error', err);\n      }\n      _this.cursor = cursor;\n      _this.emit('cursor', cursor);\n    });\n  });\n}\n\nutil.inherits(QueryCursor, Readable);\n\n/*!\n * Necessary to satisfy the Readable API\n */\n\nQueryCursor.prototype._read = function() {\n  var _this = this;\n  _next(this, function(error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function(error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n        setTimeout(function() {\n          _this.emit('close');\n        }, 0);\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * ####Example\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     var cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {QueryCursor}\n * @api public\n * @method map\n */\n\nQueryCursor.prototype.map = function(fn) {\n  this._transforms.push(fn);\n  return this;\n};\n\n/*!\n * Marks this cursor as errored\n */\n\nQueryCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see MongoDB driver cursor#close http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#close\n */\n\nQueryCursor.prototype.close = function(callback) {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.cursor.close(function(error) {\n      if (error) {\n        callback && callback(error);\n        reject(error);\n        return _this.listeners('error').length > 0 &&\n          _this.emit('error', error);\n      }\n      _this.emit('close');\n      resolve();\n      callback && callback();\n    });\n  });\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method next\n */\n\nQueryCursor.prototype.next = function(callback) {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _next(_this, function(error, doc) {\n      if (error) {\n        callback && callback(error);\n        return reject(error);\n      }\n      callback && callback(null, doc);\n      resolve(doc);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} fn\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nQueryCursor.prototype.eachAsync = function(fn, callback) {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n\n  var handleNextResult = function(doc, callback) {\n    var promise = fn(doc);\n    if (promise && typeof promise.then === 'function') {\n      promise.then(\n        function() { callback(null); },\n        function(error) { callback(error); });\n    } else {\n      callback(null);\n    }\n  };\n\n  var iterate = function(callback) {\n    return _next(_this, function(error, doc) {\n      if (error) {\n        return callback(error);\n      }\n      if (!doc) {\n        return callback(null);\n      }\n      handleNextResult(doc, function(error) {\n        if (error) {\n          return callback(error);\n        }\n        // Make sure to clear the stack re: gh-4697\n        setTimeout(function() {\n          iterate(callback);\n        }, 0);\n      });\n    });\n  };\n\n  return new Promise.ES6(function(resolve, reject) {\n    iterate(function(error) {\n      if (error) {\n        callback && callback(error);\n        return reject(error);\n      }\n      callback && callback(null);\n      return resolve();\n    });\n  });\n};\n\n/*!\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n */\n\nfunction _next(ctx, cb) {\n  var callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || doc === null) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn(doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return process.nextTick(function() {\n      callback(ctx._error);\n    });\n  }\n\n  if (ctx.cursor) {\n    return ctx.cursor.next(function(error, doc) {\n      if (error) {\n        return callback(error);\n      }\n      if (!doc) {\n        return callback(null, null);\n      }\n\n      var opts = ctx.query._mongooseOptions;\n      if (!opts.populate) {\n        return opts.lean === true ?\n                callback(null, doc) :\n                _create(ctx, doc, null, callback);\n      }\n\n      var pop = helpers.preparePopulationOptionsMQ(ctx.query,\n        ctx.query._mongooseOptions);\n      pop.forEach(function(option) {\n        delete option.model;\n      });\n      pop.__noPromise = true;\n      ctx.query.model.populate(doc, pop, function(err, doc) {\n        if (err) {\n          return callback(err);\n        }\n        return opts.lean === true ?\n          callback(null, doc) :\n          _create(ctx, doc, pop, callback);\n      });\n    });\n  } else {\n    ctx.once('cursor', function() {\n      _next(ctx, cb);\n    });\n  }\n}\n\n/*!\n * Convert a raw doc into a full mongoose doc.\n */\n\nfunction _create(ctx, doc, populatedIds, cb) {\n  var instance = helpers.createModel(ctx.query.model, doc, ctx.query._fields);\n  var opts = populatedIds ?\n    { populated: populatedIds } :\n    undefined;\n\n  instance.init(doc, opts, function(err) {\n    if (err) {\n      return cb(err);\n    }\n    cb(null, instance);\n  });\n}\n\nmodule.exports = QueryCursor;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/queryhelpers.js":"\n/*!\n * Module dependencies\n */\n\nvar utils = require('./utils');\n\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  var pop = utils.object.vals(query.options.populate);\n\n  // lean options should trickle through all queries\n  if (options.lean) pop.forEach(makeLean);\n\n  return pop;\n};\n\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  var pop = utils.object.vals(query._mongooseOptions.populate);\n\n  // lean options should trickle through all queries\n  if (options.lean) pop.forEach(makeLean);\n\n  return pop;\n};\n\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Model}\n */\nexports.createModel = function createModel(model, doc, fields) {\n  var discriminatorMapping = model.schema\n    ? model.schema.discriminatorMapping\n    : null;\n\n  var key = discriminatorMapping && discriminatorMapping.isRoot\n    ? discriminatorMapping.key\n    : null;\n\n  if (key && doc[key] && model.discriminators && model.discriminators[doc[key]]) {\n    var discriminator = model.discriminators[doc[key]];\n    var _fields = utils.clone(fields);\n    exports.applyPaths(_fields, discriminator.schema);\n    return new model.discriminators[doc[key]](undefined, _fields, true);\n  }\n\n  return new model(undefined, fields, true);\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n\n  var exclude;\n  var keys;\n  var ki;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    while (ki--) {\n      if (keys[ki][0] === '+') continue;\n      exclude = fields[keys[ki]] === 0;\n      break;\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n  var selected = [],\n      excluded = [],\n      seen = [];\n\n  var analyzePath = function(path, type) {\n    if (typeof type.selected !== 'boolean') return;\n\n    var plusPath = '+' + path;\n    if (fields && plusPath in fields) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    var root = path.split('.')[0];\n    if (~excluded.indexOf(root)) return;\n\n    (type.selected ? selected : excluded).push(path);\n  };\n\n  var analyzeSchema = function(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (~seen.indexOf(schema)) return;\n    seen.push(schema);\n\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n\n      analyzePath(path, type);\n\n      // array of subdocs?\n      if (type.schema) {\n        analyzeSchema(type.schema, path);\n      }\n    });\n  };\n\n  analyzeSchema(schema);\n\n  var i;\n  switch (exclude) {\n    case true:\n      for (i = 0; i < excluded.length; ++i) {\n        fields[excluded[i]] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n      for (i = 0; i < selected.length; ++i) {\n        fields[selected[i]] = 1;\n      }\n      break;\n    case undefined:\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields\n      for (i = 0; i < excluded.length; ++i) {\n        fields[excluded[i]] = 0;\n      }\n      break;\n  }\n};\n\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(option) {\n  option.options || (option.options = {});\n  option.options.lean = true;\n}\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/querystream.js":"/* eslint no-empty: 1 */\n\n/*!\n * Module dependencies.\n */\n\nvar Stream = require('stream').Stream;\nvar utils = require('./utils');\nvar helpers = require('./queryhelpers');\nvar K = function(k) {\n  return k;\n};\n\n/**\n * Provides a Node.js 0.8 style [ReadStream](http://nodejs.org/docs/v0.8.21/api/stream.html#stream_readable_stream) interface for Queries.\n *\n *     var stream = Model.find().stream();\n *\n *     stream.on('data', function (doc) {\n *       // do something with the mongoose document\n *     }).on('error', function (err) {\n *       // handle the error\n *     }).on('close', function () {\n *       // the stream is closed\n *     });\n *\n *\n * The stream interface allows us to simply \"plug-in\" to other _Node.js 0.8_ style write streams.\n *\n *     Model.where('created').gte(twoWeeksAgo).stream().pipe(writeStream);\n *\n * ####Valid options\n *\n *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data`.\n *\n * ####Example\n *\n *     // JSON.stringify all documents before emitting\n *     var stream = Thing.find().stream({ transform: JSON.stringify });\n *     stream.pipe(writeStream);\n *\n * _NOTE: plugging into an HTTP response will *not* work out of the box. Those streams expect only strings or buffers to be emitted, so first formatting our documents as strings/buffers is necessary._\n *\n * _NOTE: these streams are Node.js 0.8 style read streams which differ from Node.js 0.10 style. Node.js 0.10 streams are not well tested yet and are not guaranteed to work._\n *\n * @param {Query} query\n * @param {Object} [options]\n * @inherits NodeJS Stream http://nodejs.org/docs/v0.8.21/api/stream.html#stream_readable_stream\n * @event `data`: emits a single Mongoose document\n * @event `error`: emits when an error occurs during streaming. This will emit _before_ the `close` event.\n * @event `close`: emits when the stream reaches the end of the cursor or an error occurs, or the stream is manually `destroy`ed. After this event, no more events are emitted.\n * @api public\n */\n\nfunction QueryStream(query, options) {\n  Stream.call(this);\n\n  this.query = query;\n  this.readable = true;\n  this.paused = false;\n  this._cursor = null;\n  this._destroyed = null;\n  this._fields = null;\n  this._buffer = null;\n  this._inline = T_INIT;\n  this._running = false;\n  this._transform = options && typeof options.transform === 'function'\n      ? options.transform\n      : K;\n\n  // give time to hook up events\n  var _this = this;\n  process.nextTick(function() {\n    _this._init();\n  });\n}\n\n/*!\n * Inherit from Stream\n */\n\nQueryStream.prototype.__proto__ = Stream.prototype;\n\n/**\n * Flag stating whether or not this stream is readable.\n *\n * @property readable\n * @api public\n */\n\nQueryStream.prototype.readable;\n\n/**\n * Flag stating whether or not this stream is paused.\n *\n * @property paused\n * @api public\n */\n\nQueryStream.prototype.paused;\n\n// trampoline flags\nvar T_INIT = 0;\nvar T_IDLE = 1;\nvar T_CONT = 2;\n\n/**\n * Initializes the query.\n *\n * @api private\n */\n\nQueryStream.prototype._init = function() {\n  if (this._destroyed) {\n    return;\n  }\n\n  var query = this.query,\n      model = query.model,\n      options = query._optionsForExec(model),\n      _this = this;\n\n  try {\n    query.cast(model);\n  } catch (err) {\n    return _this.destroy(err);\n  }\n\n  _this._fields = utils.clone(query._fields);\n  options.fields = query._castFields(_this._fields);\n\n  model.collection.find(query._conditions, options, function(err, cursor) {\n    if (err) {\n      return _this.destroy(err);\n    }\n    _this._cursor = cursor;\n    _this._next();\n  });\n};\n\n/**\n * Trampoline for pulling the next doc from cursor.\n *\n * @see QueryStream#__next #querystream_QueryStream-__next\n * @api private\n */\n\nQueryStream.prototype._next = function _next() {\n  if (this.paused || this._destroyed) {\n    this._running = false;\n    return this._running;\n  }\n\n  this._running = true;\n\n  if (this._buffer && this._buffer.length) {\n    var arg;\n    while (!this.paused && !this._destroyed && (arg = this._buffer.shift())) { // eslint-disable-line no-cond-assign\n      this._onNextObject.apply(this, arg);\n    }\n  }\n\n  // avoid stack overflows with large result sets.\n  // trampoline instead of recursion.\n  while (this.__next()) {\n  }\n};\n\n/**\n * Pulls the next doc from the cursor.\n *\n * @see QueryStream#_next #querystream_QueryStream-_next\n * @api private\n */\n\nQueryStream.prototype.__next = function() {\n  if (this.paused || this._destroyed) {\n    this._running = false;\n    return this._running;\n  }\n\n  var _this = this;\n  _this._inline = T_INIT;\n\n  _this._cursor.nextObject(function cursorcb(err, doc) {\n    _this._onNextObject(err, doc);\n  });\n\n  // if onNextObject() was already called in this tick\n  // return ourselves to the trampoline.\n  if (T_CONT === this._inline) {\n    return true;\n  }\n  // onNextObject() hasn't fired yet. tell onNextObject\n  // that its ok to call _next b/c we are not within\n  // the trampoline anymore.\n  this._inline = T_IDLE;\n};\n\n/**\n * Transforms raw `doc`s returned from the cursor into a model instance.\n *\n * @param {Error|null} err\n * @param {Object} doc\n * @api private\n */\n\nQueryStream.prototype._onNextObject = function _onNextObject(err, doc) {\n  if (this._destroyed) {\n    return;\n  }\n\n  if (this.paused) {\n    this._buffer || (this._buffer = []);\n    this._buffer.push([err, doc]);\n    this._running = false;\n    return this._running;\n  }\n\n  if (err) {\n    return this.destroy(err);\n  }\n\n  // when doc is null we hit the end of the cursor\n  if (!doc) {\n    this.emit('end');\n    return this.destroy();\n  }\n\n  var opts = this.query._mongooseOptions;\n\n  if (!opts.populate) {\n    return opts.lean === true ?\n        emit(this, doc) :\n        createAndEmit(this, null, doc);\n  }\n\n  var _this = this;\n  var pop = helpers.preparePopulationOptionsMQ(_this.query, _this.query._mongooseOptions);\n\n  // Hack to work around gh-3108\n  pop.forEach(function(option) {\n    delete option.model;\n  });\n\n  pop.__noPromise = true;\n  _this.query.model.populate(doc, pop, function(err, doc) {\n    if (err) {\n      return _this.destroy(err);\n    }\n    return opts.lean === true ?\n        emit(_this, doc) :\n        createAndEmit(_this, pop, doc);\n  });\n};\n\nfunction createAndEmit(self, populatedIds, doc) {\n  var instance = helpers.createModel(self.query.model, doc, self._fields);\n  var opts = populatedIds ?\n    {populated: populatedIds} :\n    undefined;\n\n  instance.init(doc, opts, function(err) {\n    if (err) {\n      return self.destroy(err);\n    }\n    emit(self, instance);\n  });\n}\n\n/*!\n * Emit a data event and manage the trampoline state\n */\n\nfunction emit(self, doc) {\n  self.emit('data', self._transform(doc));\n\n  // trampoline management\n  if (T_IDLE === self._inline) {\n    // no longer in trampoline. restart it.\n    self._next();\n  } else {\n    // in a trampoline. tell __next that its\n    // ok to continue jumping.\n    self._inline = T_CONT;\n  }\n}\n\n/**\n * Pauses this stream.\n *\n * @api public\n */\n\nQueryStream.prototype.pause = function() {\n  this.paused = true;\n};\n\n/**\n * Resumes this stream.\n *\n * @api public\n */\n\nQueryStream.prototype.resume = function() {\n  this.paused = false;\n\n  if (!this._cursor) {\n    // cannot start if not initialized\n    return;\n  }\n\n  // are we within the trampoline?\n  if (T_INIT === this._inline) {\n    return;\n  }\n\n  if (!this._running) {\n    // outside QueryStream control, need manual restart\n    return this._next();\n  }\n};\n\n/**\n * Destroys the stream, closing the underlying cursor, which emits the close event. No more events will be emitted after the close event.\n *\n * @param {Error} [err]\n * @api public\n */\n\nQueryStream.prototype.destroy = function(err) {\n  if (this._destroyed) {\n    return;\n  }\n  this._destroyed = true;\n  this._running = false;\n  this.readable = false;\n\n  if (this._cursor) {\n    this._cursor.close();\n  }\n\n  if (err) {\n    this.emit('error', err);\n  }\n\n  this.emit('close');\n};\n\n/**\n * Pipes this query stream into another stream. This method is inherited from NodeJS Streams.\n *\n * ####Example:\n *\n *     query.stream().pipe(writeStream [, options])\n *\n * @method pipe\n * @memberOf QueryStream\n * @see NodeJS http://nodejs.org/api/stream.html\n * @api public\n */\n\n/*!\n * Module exports\n */\n\nmodule.exports = exports = QueryStream;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/services/query/castUpdate.js":"'use strict';\n\nvar StrictModeError = require('../../error/strict');\nvar utils = require('../../utils');\n\n/*!\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} options\n * @param {Boolean} [options.overwrite] defaults to false\n * @param {Boolean|String} [options.strict] defaults to true\n * @return {Boolean} true iff the update is non-empty\n */\n\nmodule.exports = function castUpdate(schema, obj, options) {\n  if (!obj) {\n    return undefined;\n  }\n\n  var ops = Object.keys(obj);\n  var i = ops.length;\n  var ret = {};\n  var hasKeys;\n  var val;\n  var hasDollarKey = false;\n  var overwrite = options.overwrite;\n\n  while (i--) {\n    var op = ops[i];\n    // if overwrite is set, don't do any of the special $set stuff\n    if (op[0] !== '$' && !overwrite) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n\n  // cast each value\n  i = ops.length;\n\n  // if we get passed {} for the update, we still need to respect that when it\n  // is an overwrite scenario\n  if (overwrite) {\n    hasKeys = true;\n  }\n\n  while (i--) {\n    op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.charAt(0) === '$';\n    if (val &&\n        typeof val === 'object' &&\n        (!overwrite || hasDollarKey)) {\n      hasKeys |= walkUpdatePath(schema, val, op, options.strict);\n    } else if (overwrite && ret && typeof ret === 'object') {\n      // if we are just using overwrite, cast the query and then we will\n      // *always* return the value, even if it is an empty object. We need to\n      // set hasKeys above because we need to account for the case where the\n      // user passes {} and wants to clobber the whole document\n      // Also, _walkUpdatePath expects an operation, so give it $set since that\n      // is basically what we're doing\n      walkUpdatePath(schema, ret, '$set', options.strict);\n    } else {\n      var msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n  }\n\n  return hasKeys && ret;\n};\n\n/*!\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj - part of a query\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {Boolean|String} strict\n * @param {String} pref - path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, strict, pref) {\n  var prefix = pref ? pref + '.' : '',\n      keys = Object.keys(obj),\n      i = keys.length,\n      hasKeys = false,\n      schematype,\n      key,\n      val;\n\n  var useNestedStrict = schema.options.useNestedStrict;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (val && val.constructor.name === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        hasKeys = true;\n\n        if ('$each' in val) {\n          obj[key] = {\n            $each: castUpdateVal(schematype, val.$each, op)\n          };\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (!!val.$position || val.$position === 0) {\n            obj[key].$position = val.$position;\n          }\n        } else {\n          obj[key] = castUpdateVal(schematype, val, op);\n        }\n      } else if (op === '$currentDate') {\n        // $currentDate can take an object\n        obj[key] = castUpdateVal(schematype, val, op);\n        hasKeys = true;\n      } else if (op in castOps && schematype) {\n        obj[key] = castUpdateVal(schematype, val, op);\n        hasKeys = true;\n      } else {\n        var pathToCheck = (prefix + key);\n        var v = schema._getPathType(pathToCheck);\n        var _strict = strict;\n        if (useNestedStrict &&\n            v &&\n            v.schema &&\n            'strict' in v.schema.options) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, strict, prefix + key) ||\n          (utils.isObject(val) && Object.keys(val).length === 0);\n      }\n    } else {\n      var checkPath = (key === '$each' || key === '$or' || key === '$and') ?\n        pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      var pathDetails = schema._getPathType(checkPath);\n      var isStrict = strict;\n      if (useNestedStrict &&\n          pathDetails &&\n          pathDetails.schema &&\n          'strict' in pathDetails.schema.options) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      var skip = isStrict &&\n          !schematype &&\n          !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        if (isStrict === 'throw') {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n\n        hasKeys = true;\n        obj[key] = castUpdateVal(schematype, val, op, key);\n      }\n    }\n  }\n  return hasKeys;\n}\n\n/*!\n * These operators should be cast to numbers instead\n * of their path schema type.\n */\n\nvar numberOps = {\n  $pop: 1,\n  $unset: 1,\n  $inc: 1\n};\n\n/*!\n * These operators require casting docs\n * to real Documents for Update operations.\n */\n\nvar castOps = {\n  $push: 1,\n  $pushAll: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {String} [$conditional]\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional) {\n  if (!schema) {\n    // non-existing schema path\n    return op in numberOps\n        ? Number(val)\n        : val;\n  }\n\n  var cond = schema.caster && op in castOps &&\n      (utils.isObject(val) || Array.isArray(val));\n  if (cond) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    var tmp = schema.cast(val);\n    if (Array.isArray(val)) {\n      val = tmp;\n    } else if (Array.isArray(tmp)) {\n      val = tmp[0];\n    } else {\n      val = tmp;\n    }\n    return val;\n  }\n\n  if (op in numberOps) {\n    if (op === '$inc') {\n      return schema.castForQuery(val);\n    }\n    return Number(val);\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return {$type: val.$type};\n    }\n    return Boolean(val);\n  }\n  if (/^\\$/.test($conditional)) {\n    return schema.castForQuery($conditional, val);\n  }\n\n  return schema.castForQuery(val);\n}\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/services/setDefaultsOnInsert.js":"'use strict';\n\nvar modifiedPaths = require('./common').modifiedPaths;\n\n/**\n * Applies defaults to update and findOneAndUpdate operations.\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method setDefaultsOnInsert\n * @api private\n */\n\nmodule.exports = function(query, schema, castedDoc, options) {\n  var keys = Object.keys(castedDoc || {});\n  var updatedKeys = {};\n  var updatedValues = {};\n  var numKeys = keys.length;\n  var hasDollarUpdate = false;\n  var modified = {};\n\n  if (options && options.upsert) {\n    for (var i = 0; i < numKeys; ++i) {\n      if (keys[i].charAt(0) === '$') {\n        modifiedPaths(castedDoc[keys[i]], '', modified);\n        hasDollarUpdate = true;\n      }\n    }\n\n    if (!hasDollarUpdate) {\n      modifiedPaths(castedDoc, '', modified);\n    }\n\n    var paths = Object.keys(query._conditions);\n    var numPaths = keys.length;\n    for (i = 0; i < numPaths; ++i) {\n      var path = paths[i];\n      var condition = query._conditions[path];\n      if (condition && typeof condition === 'object') {\n        var conditionKeys = Object.keys(condition);\n        var numConditionKeys = conditionKeys.length;\n        var hasDollarKey = false;\n        for (var j = 0; j < numConditionKeys; ++j) {\n          if (conditionKeys[j].charAt(0) === '$') {\n            hasDollarKey = true;\n            break;\n          }\n        }\n        if (hasDollarKey) {\n          continue;\n        }\n      }\n      updatedKeys[path] = true;\n      modified[path] = true;\n    }\n\n    if (options.setDefaultsOnInsert) {\n      schema.eachPath(function(path, schemaType) {\n        if (path === '_id') {\n          // Ignore _id for now because it causes bugs in 2.4\n          return;\n        }\n        if (schemaType.$isSingleNested) {\n          // Only handle nested schemas 1-level deep to avoid infinite\n          // recursion re: https://github.com/mongodb-js/mongoose-autopopulate/issues/11\n          schemaType.schema.eachPath(function(_path, _schemaType) {\n            if (path === '_id') {\n              // Ignore _id for now because it causes bugs in 2.4\n              return;\n            }\n\n            var def = _schemaType.getDefault(null, true);\n            if (!isModified(modified, path + '.' + _path) &&\n                typeof def !== 'undefined') {\n              castedDoc = castedDoc || {};\n              castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n              castedDoc.$setOnInsert[path + '.' + _path] = def;\n              updatedValues[path + '.' + _path] = def;\n            }\n          });\n        } else {\n          var def = schemaType.getDefault(null, true);\n          if (!isModified(modified, path) && typeof def !== 'undefined') {\n            castedDoc = castedDoc || {};\n            castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n            castedDoc.$setOnInsert[path] = def;\n            updatedValues[path] = def;\n          }\n        }\n      });\n    }\n  }\n\n  return castedDoc;\n};\n\nfunction isModified(modified, path) {\n  if (modified[path]) {\n    return true;\n  }\n  var sp = path.split('.');\n  var cur = sp[0];\n  for (var i = 0; i < sp.length; ++i) {\n    if (modified[cur]) {\n      return true;\n    }\n    cur += '.' + sp[i];\n  }\n  return false;\n}\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/services/updateValidators.js":"/*!\n * Module dependencies.\n */\n\nvar Mixed = require('../schema/mixed');\nvar ValidationError = require('../error/validation');\nvar parallel = require('async/parallel');\nvar flatten = require('./common').flatten;\nvar modifiedPaths = require('./common').modifiedPaths;\n\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\nmodule.exports = function(query, schema, castedDoc, options) {\n  var _keys;\n  var keys = Object.keys(castedDoc || {});\n  var updatedKeys = {};\n  var updatedValues = {};\n  var arrayAtomicUpdates = {};\n  var numKeys = keys.length;\n  var hasDollarUpdate = false;\n  var modified = {};\n\n  for (var i = 0; i < numKeys; ++i) {\n    if (keys[i].charAt(0) === '$') {\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        _keys = Object.keys(castedDoc[keys[i]]);\n        for (var ii = 0; ii < _keys.length; ++ii) {\n          if (castedDoc[keys[i]][_keys[ii]].$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat(castedDoc[keys[i]][_keys[ii]].$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat([castedDoc[keys[i]][_keys[ii]]]);\n          }\n        }\n        continue;\n      }\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      var flat = flatten(castedDoc[keys[i]]);\n      var paths = Object.keys(flat);\n      var numPaths = paths.length;\n      for (var j = 0; j < numPaths; ++j) {\n        var updatedPath = paths[j].replace('.$.', '.0.');\n        updatedPath = updatedPath.replace(/\\.\\$$/, '.0');\n        if (keys[i] === '$set' || keys[i] === '$setOnInsert') {\n          updatedValues[updatedPath] = flat[paths[j]];\n        } else if (keys[i] === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n      hasDollarUpdate = true;\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n    updatedValues = flatten(castedDoc);\n    updatedKeys = Object.keys(updatedValues);\n  }\n\n  var updates = Object.keys(updatedValues);\n  var numUpdates = updates.length;\n  var validatorsToExecute = [];\n  var validationErrors = [];\n  function iter(i, v) {\n    var schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath) {\n      // gh-4305: `_getSchema()` will report all sub-fields of a 'Mixed' path\n      // as 'Mixed', so avoid double validating them.\n      if (schemaPath instanceof Mixed && schemaPath.$fullPath !== updates[i]) {\n        return;\n      }\n      validatorsToExecute.push(function(callback) {\n        schemaPath.doValidate(\n            v,\n            function(err) {\n              if (err) {\n                err.path = updates[i];\n                validationErrors.push(err);\n              }\n              callback(null);\n            },\n            options && options.context === 'query' ? query : null,\n            {updateValidator: true});\n      });\n    }\n  }\n  for (i = 0; i < numUpdates; ++i) {\n    iter(i, updatedValues[updates[i]]);\n  }\n\n  var arrayUpdates = Object.keys(arrayAtomicUpdates);\n  var numArrayUpdates = arrayUpdates.length;\n  for (i = 0; i < numArrayUpdates; ++i) {\n    (function(i) {\n      var schemaPath = schema._getSchema(arrayUpdates[i]);\n      if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n              arrayAtomicUpdates[arrayUpdates[i]],\n              function(err) {\n                if (err) {\n                  err.path = arrayUpdates[i];\n                  validationErrors.push(err);\n                }\n                callback(null);\n              },\n              options && options.context === 'query' ? query : null);\n        });\n      } else {\n        schemaPath = schema._getSchema(arrayUpdates[i] + '.0');\n        for (var j = 0; j < arrayAtomicUpdates[arrayUpdates[i]].length; ++j) {\n          (function(j) {\n            validatorsToExecute.push(function(callback) {\n              schemaPath.doValidate(\n                arrayAtomicUpdates[arrayUpdates[i]][j],\n                function(err) {\n                  if (err) {\n                    err.path = arrayUpdates[i];\n                    validationErrors.push(err);\n                  }\n                  callback(null);\n                },\n                options && options.context === 'query' ? query : null,\n                { updateValidator: true });\n            });\n          })(j);\n        }\n      }\n    })(i);\n  }\n\n  return function(callback) {\n    parallel(validatorsToExecute, function() {\n      if (validationErrors.length) {\n        var err = new ValidationError(null);\n        for (var i = 0; i < validationErrors.length; ++i) {\n          err.errors[validationErrors[i].path] = validationErrors[i];\n        }\n        return callback(err);\n      }\n      callback(null);\n    });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/model.js":"/*!\n * Module dependencies.\n */\n\nvar Aggregate = require('./aggregate');\nvar Document = require('./document');\nvar DocumentNotFoundError = require('./error/notFound');\nvar DivergentArrayError = require('./error').DivergentArrayError;\nvar EventEmitter = require('events').EventEmitter;\nvar OverwriteModelError = require('./error').OverwriteModelError;\nvar PromiseProvider = require('./promise_provider');\nvar Query = require('./query');\nvar Schema = require('./schema');\nvar VersionError = require('./error').VersionError;\nvar applyHooks = require('./services/model/applyHooks');\nvar applyMethods = require('./services/model/applyMethods');\nvar applyStatics = require('./services/model/applyStatics');\nvar cast = require('./cast');\nvar castUpdate = require('./services/query/castUpdate');\nvar discriminator = require('./services/model/discriminator');\nvar isPathSelectedInclusive = require('./services/projection/isPathSelectedInclusive');\nvar parallel = require('async/parallel');\nvar util = require('util');\nvar utils = require('./utils');\n\nvar VERSION_WHERE = 1,\n    VERSION_INC = 2,\n    VERSION_ALL = VERSION_WHERE | VERSION_INC;\n\nvar POJO_TO_OBJECT_OPTIONS = {\n  depopulate: true,\n  transform: false,\n  _skipDepopulateTopLevel: true\n};\n\n/**\n * Model constructor\n *\n * Provides the interface to MongoDB collections as well as creates document instances.\n *\n * @param {Object} doc values with which to create the document\n * @inherits Document http://mongoosejs.com/docs/api.html#document-js\n * @event `error`: If listening to this event, it is emitted when a document was saved without passing a callback and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.\n * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.\n * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.\n * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.\n * @api public\n */\n\nfunction Model(doc, fields, skipId) {\n  Document.call(this, doc, fields, skipId, true);\n}\n\n/*!\n * Inherits from Document.\n *\n * All Model.prototype features are available on\n * top level (non-sub) documents.\n */\n\nModel.prototype.__proto__ = Document.prototype;\nModel.prototype.$isMongooseModelPrototype = true;\n\n/**\n * Connection the model uses.\n *\n * @api public\n * @property db\n */\n\nModel.prototype.db;\n\n/**\n * Collection the model uses.\n *\n * @api public\n * @property collection\n */\n\nModel.prototype.collection;\n\n/**\n * The name of the model\n *\n * @api public\n * @property modelName\n */\n\nModel.prototype.modelName;\n\n/**\n * Additional properties to attach to the query when calling `save()` and\n * `isNew` is false.\n *\n * @api public\n * @property $where\n */\n\nModel.prototype.$where;\n\n/**\n * If this is a discriminator model, `baseModelName` is the name of\n * the base model.\n *\n * @api public\n * @property baseModelName\n */\n\nModel.prototype.baseModelName;\n\nModel.prototype.$__handleSave = function(options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === 'boolean') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, '_id')) {\n      // documents must have an _id else mongoose won't know\n      // what to update later if more changes are made. the user\n      // wouldn't know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error('document must have an _id before saving'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit('isNew', true);\n        _this.constructor.emit('isNew', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit('isNew', false);\n    this.constructor.emit('isNew', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don't treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit('isNew', false);\n    this.constructor.emit('isNew', false);\n  }\n};\n\n/*!\n * ignore\n */\n\nModel.prototype.$__save = function(options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit('save', _this, numAffected);\n    _this.constructor.emit('save', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n};\n\n/**\n * Saves this document.\n *\n * ####Example:\n *\n *     product.sold = Date.now();\n *     product.save(function (err, product, numAffected) {\n *       if (err) ..\n *     })\n *\n * The callback will receive three parameters\n *\n * 1. `err` if an error occurred\n * 2. `product` which is the saved `product`\n * 3. `numAffected` will be 1 when the document was successfully persisted to MongoDB, otherwise 0. Unless you tweak mongoose's internals, you don't need to worry about checking this parameter for errors - checking `err` is sufficient to make sure your document was properly saved.\n *\n * As an extra measure of flow control, save will return a Promise.\n * ####Example:\n *     product.save().then(function(product) {\n *        ...\n *     });\n *\n * For legacy reasons, mongoose stores object keys in reverse order on initial\n * save. That is, `{ a: 1, b: 2 }` will be saved as `{ b: 2, a: 1 }` in\n * MongoDB. To override this behavior, set\n * [the `toObject.retainKeyOrder` option](http://mongoosejs.com/docs/api.html#document_Document-toObject)\n * to true on your schema.\n *\n * @param {Object} [options] options optional options\n * @param {Object} [options.safe] overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe)\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Function} [fn] optional callback\n * @return {Promise} Promise\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\n\nModel.prototype.save = function(options, fn) {\n  if (typeof options === 'function') {\n    fn = options;\n    options = undefined;\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (fn) {\n    fn = this.constructor.$wrapCallback(fn);\n  }\n\n  return this.$__save(options, fn);\n};\n\n/*!\n * Determines whether versioning should be skipped for the given path\n *\n * @param {Document} self\n * @param {String} path\n * @return {Boolean} true if versioning should be skipped for the given path\n */\nfunction shouldSkipVersioning(self, path) {\n  var skipVersioning = self.schema.options.skipVersioning;\n  if (!skipVersioning) return false;\n\n  // Remove any array indexes from the path\n  path = path.replace(/\\.\\d+\\./, '.');\n\n  return skipVersioning[path];\n}\n\n/*!\n * Apply the operation to the delta (update) clause as\n * well as track versioning for our where clause.\n *\n * @param {Document} self\n * @param {Object} where\n * @param {Object} delta\n * @param {Object} data\n * @param {Mixed} val\n * @param {String} [operation]\n */\n\nfunction operand(self, where, delta, data, val, op) {\n  // delta\n  op || (op = '$set');\n  if (!delta[op]) delta[op] = {};\n  delta[op][data.path] = val;\n\n  // disabled versioning?\n  if (self.schema.options.versionKey === false) return;\n\n  // path excluded from versioning?\n  if (shouldSkipVersioning(self, data.path)) return;\n\n  // already marked for versioning?\n  if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;\n\n  switch (op) {\n    case '$set':\n    case '$unset':\n    case '$pop':\n    case '$pull':\n    case '$pullAll':\n    case '$push':\n    case '$pushAll':\n    case '$addToSet':\n      break;\n    default:\n      // nothing to do\n      return;\n  }\n\n  // ensure updates sent with positional notation are\n  // editing the correct array element.\n  // only increment the version if an array position changes.\n  // modifying elements of an array is ok if position does not change.\n\n  if (op === '$push' || op === '$pushAll' || op === '$addToSet') {\n    self.$__.version = VERSION_INC;\n  } else if (/^\\$p/.test(op)) {\n    // potentially changing array positions\n    self.increment();\n  } else if (Array.isArray(val)) {\n    // $set an array\n    self.increment();\n  } else if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n    // now handling $set, $unset\n    // subpath of array\n    self.$__.version = VERSION_WHERE;\n  }\n}\n\n/*!\n * Compiles an update and where clause for a `val` with _atomics.\n *\n * @param {Document} self\n * @param {Object} where\n * @param {Object} delta\n * @param {Object} data\n * @param {Array} value\n */\n\nfunction handleAtomics(self, where, delta, data, value) {\n  if (delta.$set && delta.$set[data.path]) {\n    // $set has precedence over other atomics\n    return;\n  }\n\n  if (typeof value.$__getAtomics === 'function') {\n    value.$__getAtomics().forEach(function(atomic) {\n      var op = atomic[0];\n      var val = atomic[1];\n      if (self.schema.options.usePushEach && op === '$pushAll') {\n        op = '$push';\n        val = { $each: val };\n      }\n      operand(self, where, delta, data, val, op);\n    });\n    return;\n  }\n\n  // legacy support for plugins\n\n  var atomics = value._atomics,\n      ops = Object.keys(atomics),\n      i = ops.length,\n      val,\n      op;\n\n  if (i === 0) {\n    // $set\n\n    if (utils.isMongooseObject(value)) {\n      value = value.toObject({depopulate: 1, _isNested: true});\n    } else if (value.valueOf) {\n      value = value.valueOf();\n    }\n\n    return operand(self, where, delta, data, value);\n  }\n\n  function iter(mem) {\n    return utils.isMongooseObject(mem)\n        ? mem.toObject({depopulate: 1, _isNested: true})\n        : mem;\n  }\n\n  while (i--) {\n    op = ops[i];\n    val = atomics[op];\n\n    if (utils.isMongooseObject(val)) {\n      val = val.toObject({depopulate: true, transform: false, _isNested: true});\n    } else if (Array.isArray(val)) {\n      val = val.map(iter);\n    } else if (val.valueOf) {\n      val = val.valueOf();\n    }\n\n    if (op === '$addToSet') {\n      val = {$each: val};\n    }\n\n    operand(self, where, delta, data, val, op);\n  }\n}\n\n/**\n * Produces a special query document of the modified properties used in updates.\n *\n * @api private\n * @method $__delta\n * @memberOf Model\n */\n\nModel.prototype.$__delta = function() {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split('.');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === 'undefined') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = '$';\n          data.path = pathSplit.join('.');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, '$unset');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n};\n\n/*!\n * Determine if array was populated with some form of filter and is now\n * being updated in a manner which could overwrite data unintentionally.\n *\n * @see https://github.com/Automattic/mongoose/issues/1334\n * @param {Document} doc\n * @param {String} path\n * @return {String|undefined}\n */\n\nfunction checkDivergentArray(doc, path, array) {\n  // see if we populated this path\n  var pop = doc.populated(path, true);\n\n  if (!pop && doc.$__.selected) {\n    // If any array was selected using an $elemMatch projection, we deny the update.\n    // NOTE: MongoDB only supports projected $elemMatch on top level array.\n    var top = path.split('.')[0];\n    if (doc.$__.selected[top + '.$']) {\n      return top;\n    }\n  }\n\n  if (!(pop && array && array.isMongooseArray)) return;\n\n  // If the array was populated using options that prevented all\n  // documents from being returned (match, skip, limit) or they\n  // deselected the _id field, $pop and $set of the array are\n  // not safe operations. If _id was deselected, we do not know\n  // how to remove elements. $pop will pop off the _id from the end\n  // of the array in the db which is not guaranteed to be the\n  // same as the last element we have here. $set of the entire array\n  // would be similarily destructive as we never received all\n  // elements of the array and potentially would overwrite data.\n  var check = pop.options.match ||\n      pop.options.options && utils.object.hasOwnProperty(pop.options.options, 'limit') || // 0 is not permitted\n      pop.options.options && pop.options.options.skip || // 0 is permitted\n      pop.options.select && // deselected _id?\n      (pop.options.select._id === 0 ||\n      /\\s?-_id\\s?/.test(pop.options.select));\n\n  if (check) {\n    var atomics = array._atomics;\n    if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {\n      return path;\n    }\n  }\n}\n\n/**\n * Appends versioning to the where and update clauses.\n *\n * @api private\n * @method $__version\n * @memberOf Model\n */\n\nModel.prototype.$__version = function(where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === 'undefined') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n};\n\n/**\n * Signal that we desire an increment of this documents version.\n *\n * ####Example:\n *\n *     Model.findById(id, function (err, doc) {\n *       doc.increment();\n *       doc.save(function (err) { .. })\n *     })\n *\n * @see versionKeys http://mongoosejs.com/docs/guide.html#versionKey\n * @api public\n */\n\nModel.prototype.increment = function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n};\n\n/**\n * Returns a query object which applies shardkeys if they exist.\n *\n * @api private\n * @method $__where\n * @memberOf Model\n */\n\nModel.prototype.$__where = function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error('No _id found on document!');\n  }\n\n  return where;\n};\n\n/**\n * Removes this document from the db.\n *\n * ####Example:\n *     product.remove(function (err, product) {\n *       if (err) return handleError(err);\n *       Product.findById(product._id, function (err, product) {\n *         console.log(product) // null\n *       })\n *     })\n *\n *\n * As an extra measure of flow control, remove will return a Promise (bound to `fn` if passed) so it could be chained, or hooked to recive errors\n *\n * ####Example:\n *     product.remove().then(function (product) {\n *        ...\n *     }).onRejected(function (err) {\n *        assert.ok(err)\n *     })\n *\n * @param {function(err,product)} [fn] optional callback\n * @return {Promise} Promise\n * @api public\n */\n\nModel.prototype.remove = function remove(options, fn) {\n  if (typeof options === 'function') {\n    fn = options;\n    options = undefined;\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (this.$__.removing) {\n    if (fn) {\n      this.$__.removing.then(\n          function(res) { fn(null, res); },\n          function(err) { fn(err); });\n    }\n    return this;\n  }\n\n  var _this = this;\n  var Promise = PromiseProvider.get();\n\n  if (fn) {\n    fn = this.constructor.$wrapCallback(fn);\n  }\n\n  this.$__.removing = new Promise.ES6(function(resolve, reject) {\n    var where = _this.$__where();\n    if (where instanceof Error) {\n      reject(where);\n      fn && fn(where);\n      return;\n    }\n\n    if (!options.safe && _this.schema.options.safe) {\n      options.safe = _this.schema.options.safe;\n    }\n\n    _this.collection.remove(where, options, function(err) {\n      if (!err) {\n        _this.emit('remove', _this);\n        _this.constructor.emit('remove', _this);\n        resolve(_this);\n        fn && fn(null, _this);\n        return;\n      }\n      reject(err);\n      fn && fn(err);\n    });\n  });\n  return this.$__.removing;\n};\n\n/**\n * Returns another Model instance.\n *\n * ####Example:\n *\n *     var doc = new Tank;\n *     doc.model('User').findById(id, callback);\n *\n * @param {String} name model name\n * @api public\n */\n\nModel.prototype.model = function model(name) {\n  return this.db.model(name);\n};\n\n/**\n * Adds a discriminator type.\n *\n * ####Example:\n *\n *     function BaseSchema() {\n *       Schema.apply(this, arguments);\n *\n *       this.add({\n *         name: String,\n *         createdAt: Date\n *       });\n *     }\n *     util.inherits(BaseSchema, Schema);\n *\n *     var PersonSchema = new BaseSchema();\n *     var BossSchema = new BaseSchema({ department: String });\n *\n *     var Person = mongoose.model('Person', PersonSchema);\n *     var Boss = Person.discriminator('Boss', BossSchema);\n *\n * @param {String} name   discriminator model name\n * @param {Schema} schema discriminator model schema\n * @api public\n */\n\nModel.discriminator = function(name, schema) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  schema = discriminator(this, name, schema);\n  if (this.db.models[name]) {\n    throw new OverwriteModelError(name);\n  }\n\n  schema.$isRootDiscriminator = true;\n\n  this.discriminators[name] = this.db.model(name, schema, this.collection.name);\n  var d = this.discriminators[name];\n  d.prototype.__proto__ = this.prototype;\n  Object.defineProperty(d, 'baseModelName', {\n    value: this.modelName,\n    configurable: true,\n    writable: false\n  });\n\n  // apply methods and statics\n  applyMethods(d, schema);\n  applyStatics(d, schema);\n\n  return d;\n};\n\n// Model (class) features\n\n/*!\n * Give the constructor the ability to emit events.\n */\n\nfor (var i in EventEmitter.prototype) {\n  Model[i] = EventEmitter.prototype[i];\n}\n\n/**\n * Called when the model compiles.\n *\n * @api private\n */\n\nModel.init = function init() {\n  if ((this.schema.options.autoIndex) ||\n      (this.schema.options.autoIndex === null && this.db.config.autoIndex)) {\n    this.ensureIndexes({ __noPromise: true, _automatic: true });\n  }\n\n  this.schema.emit('init', this);\n};\n\n/**\n * Sends `ensureIndex` commands to mongo for each index declared in the schema.\n *\n * ####Example:\n *\n *     Event.ensureIndexes(function (err) {\n *       if (err) return handleError(err);\n *     });\n *\n * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n *\n * ####Example:\n *\n *     var eventSchema = new Schema({ thing: { type: 'string', unique: true }})\n *     var Event = mongoose.model('Event', eventSchema);\n *\n *     Event.on('index', function (err) {\n *       if (err) console.error(err); // error occurred during index creation\n *     })\n *\n * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._\n *\n * The `ensureIndex` commands are not sent in parallel. This is to avoid the `MongoError: cannot add index with a background operation in progress` error. See [this ticket](https://github.com/Automattic/mongoose/issues/1365) for more information.\n *\n * @param {Object} [options] internal options\n * @param {Function} [cb] optional callback\n * @return {Promise}\n * @api public\n */\n\nModel.ensureIndexes = function ensureIndexes(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  if (options && options.__noPromise) {\n    _ensureIndexes(this, options, callback);\n    return;\n  }\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  var _this = this;\n  var Promise = PromiseProvider.get();\n  return new Promise.ES6(function(resolve, reject) {\n    _ensureIndexes(_this, options || {}, function(error) {\n      if (error) {\n        callback && callback(error);\n        reject(error);\n      }\n      callback && callback();\n      resolve();\n    });\n  });\n};\n\nfunction _ensureIndexes(model, options, callback) {\n  var indexes = model.schema.indexes();\n  if (!indexes.length) {\n    setImmediate(function() {\n      callback && callback();\n    });\n    return;\n  }\n  // Indexes are created one-by-one to support how MongoDB < 2.4 deals\n  // with background indexes.\n\n  var done = function(err) {\n    if (err && model.schema.options.emitIndexErrors) {\n      model.emit('error', err);\n    }\n    model.emit('index', err);\n    callback && callback(err);\n  };\n\n  var indexSingleDone = function(err, fields, options, name) {\n    model.emit('index-single-done', err, fields, options, name);\n  };\n  var indexSingleStart = function(fields, options) {\n    model.emit('index-single-start', fields, options);\n  };\n\n  var create = function() {\n    var index = indexes.shift();\n    if (!index) return done();\n\n    var indexFields = index[0];\n    var options = index[1];\n    _handleSafe(options);\n\n    indexSingleStart(indexFields, options);\n\n    model.collection.ensureIndex(indexFields, options, utils.tick(function(err, name) {\n      indexSingleDone(err, indexFields, options, name);\n      if (err) {\n        return done(err);\n      }\n      create();\n    }));\n  };\n\n  setImmediate(function() {\n    // If buffering is off, do this manually.\n    if (options._automatic && !model.collection.collection) {\n      model.collection.addQueue(create, []);\n    } else {\n      create();\n    }\n  });\n}\n\nfunction _handleSafe(options) {\n  if (options.safe) {\n    if (typeof options.safe === 'boolean') {\n      options.w = options.safe;\n      delete options.safe;\n    }\n    if (typeof options.safe === 'object') {\n      options.w = options.safe.w;\n      options.j = options.safe.j;\n      options.wtimeout = options.safe.wtimeout;\n      delete options.safe;\n    }\n  }\n}\n\n/**\n * Schema the model uses.\n *\n * @property schema\n * @receiver Model\n * @api public\n */\n\nModel.schema;\n\n/*!\n * Connection instance the model uses.\n *\n * @property db\n * @receiver Model\n * @api public\n */\n\nModel.db;\n\n/*!\n * Collection the model uses.\n *\n * @property collection\n * @receiver Model\n * @api public\n */\n\nModel.collection;\n\n/**\n * Base Mongoose instance the model uses.\n *\n * @property base\n * @receiver Model\n * @api public\n */\n\nModel.base;\n\n/**\n * Registered discriminators for this model.\n *\n * @property discriminators\n * @receiver Model\n * @api public\n */\n\nModel.discriminators;\n\n/**\n * Removes the first document that matches `conditions` from the collection.\n * To remove all documents that match `conditions`, set the `justOne` option\n * to false.\n *\n * ####Example:\n *\n *     Character.remove({ name: 'Eddard Stark' }, function (err) {});\n *\n * ####Note:\n *\n * This method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved, _no middleware (hooks) are executed_.\n *\n * @param {Object} conditions\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.remove = function remove(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n\n  // get the mongodb collection object\n  var mq = new this.Query(conditions, {}, this, this.collection);\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return mq.remove(callback);\n};\n\n/**\n * Deletes the first document that matches `conditions` from the collection.\n * Behaves like `remove()`, but deletes at most one document regardless of the\n * `justOne` option.\n *\n * ####Example:\n *\n *     Character.deleteOne({ name: 'Eddard Stark' }, function (err) {});\n *\n * ####Note:\n *\n * Like `Model.remove()`, this function does **not** trigger `pre('remove')` or `post('remove')` hooks.\n *\n * @param {Object} conditions\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.deleteOne = function deleteOne(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n\n  // get the mongodb collection object\n  var mq = new this.Query(conditions, {}, this, this.collection);\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return mq.deleteOne(callback);\n};\n\n/**\n * Deletes the first document that matches `conditions` from the collection.\n * Behaves like `remove()`, but deletes all documents that match `conditions`\n * regardless of the `justOne` option.\n *\n * ####Example:\n *\n *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }, function (err) {});\n *\n * ####Note:\n *\n * Like `Model.remove()`, this function does **not** trigger `pre('remove')` or `post('remove')` hooks.\n *\n * @param {Object} conditions\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.deleteMany = function deleteMany(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n\n  // get the mongodb collection object\n  var mq = new this.Query(conditions, {}, this, this.collection);\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return mq.deleteMany(callback);\n};\n\n/**\n * Finds documents\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * ####Examples:\n *\n *     // named john and at least 18\n *     MyModel.find({ name: 'john', age: { $gte: 18 }});\n *\n *     // executes immediately, passing results to callback\n *     MyModel.find({ name: 'john', age: { $gte: 18 }}, function (err, docs) {});\n *\n *     // name LIKE john and only selecting the \"name\" and \"friends\" fields, executing immediately\n *     MyModel.find({ name: /john/i }, 'name friends', function (err, docs) { })\n *\n *     // passing options\n *     MyModel.find({ name: /john/i }, null, { skip: 10 })\n *\n *     // passing options and executing immediately\n *     MyModel.find({ name: /john/i }, null, { skip: 10 }, function (err, docs) {});\n *\n *     // executing a query explicitly\n *     var query = MyModel.find({ name: /john/i }, null, { skip: 10 })\n *     query.exec(function (err, docs) {});\n *\n *     // using the promise returned from executing a query\n *     var query = MyModel.find({ name: /john/i }, null, { skip: 10 });\n *     var promise = query.exec();\n *     promise.addBack(function (err, docs) {});\n *\n * @param {Object} conditions\n * @param {Object} [projection] optional fields to return (http://bit.ly/1HotzBo)\n * @param {Object} [options] optional\n * @param {Function} [callback]\n * @return {Query}\n * @see field selection #query_Query-select\n * @see promise #promise-js\n * @api public\n */\n\nModel.find = function find(conditions, projection, options, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n    projection = null;\n    options = null;\n  } else if (typeof projection === 'function') {\n    callback = projection;\n    projection = null;\n    options = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  var mq = new this.Query({}, {}, this, this.collection);\n  mq.select(projection);\n  mq.setOptions(options);\n  if (this.schema.discriminatorMapping && mq.selectedInclusively()) {\n    mq.select(this.schema.options.discriminatorKey);\n  }\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return mq.find(conditions, callback);\n};\n\n/**\n * Finds a single document by its _id field. `findById(id)` is almost*\n * equivalent to `findOne({ _id: id })`. If you want to query by a document's\n * `_id`, use `findById()` instead of `findOne()`.\n *\n * The `id` is cast based on the Schema before sending the command.\n *\n * Note: `findById()` triggers `findOne` hooks.\n *\n * * Except for how it treats `undefined`. If you use `findOne()`, you'll see\n * that `findOne(undefined)` and `findOne({ _id: undefined })` are equivalent\n * to `findOne({})` and return arbitrary documents. However, mongoose\n * translates `findById(undefined)` into `findOne({ _id: null })`.\n *\n * ####Example:\n *\n *     // find adventure by id and execute immediately\n *     Adventure.findById(id, function (err, adventure) {});\n *\n *     // same as above\n *     Adventure.findById(id).exec(callback);\n *\n *     // select only the adventures name and length\n *     Adventure.findById(id, 'name length', function (err, adventure) {});\n *\n *     // same as above\n *     Adventure.findById(id, 'name length').exec(callback);\n *\n *     // include all properties except for `length`\n *     Adventure.findById(id, '-length').exec(function (err, adventure) {});\n *\n *     // passing options (in this case return the raw js objects, not mongoose documents by passing `lean`\n *     Adventure.findById(id, 'name', { lean: true }, function (err, doc) {});\n *\n *     // same as above\n *     Adventure.findById(id, 'name').lean().exec(function (err, doc) {});\n *\n * @param {Object|String|Number} id value of `_id` to query by\n * @param {Object} [projection] optional fields to return (http://bit.ly/1HotzBo)\n * @param {Object} [options] optional\n * @param {Function} [callback]\n * @return {Query}\n * @see field selection #query_Query-select\n * @see lean queries #query_Query-lean\n * @api public\n */\n\nModel.findById = function findById(id, projection, options, callback) {\n  if (typeof id === 'undefined') {\n    id = null;\n  }\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return this.findOne({_id: id}, projection, options, callback);\n};\n\n/**\n * Finds one document.\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `findById()` instead.\n *\n * ####Example:\n *\n *     // find one iphone adventures - iphone adventures??\n *     Adventure.findOne({ type: 'iphone' }, function (err, adventure) {});\n *\n *     // same as above\n *     Adventure.findOne({ type: 'iphone' }).exec(function (err, adventure) {});\n *\n *     // select only the adventures name\n *     Adventure.findOne({ type: 'iphone' }, 'name', function (err, adventure) {});\n *\n *     // same as above\n *     Adventure.findOne({ type: 'iphone' }, 'name').exec(function (err, adventure) {});\n *\n *     // specify options, in this case lean\n *     Adventure.findOne({ type: 'iphone' }, 'name', { lean: true }, callback);\n *\n *     // same as above\n *     Adventure.findOne({ type: 'iphone' }, 'name', { lean: true }).exec(callback);\n *\n *     // chaining findOne queries (same as above)\n *     Adventure.findOne({ type: 'iphone' }).select('name').lean().exec(callback);\n *\n * @param {Object} [conditions]\n * @param {Object} [projection] optional fields to return (http://bit.ly/1HotzBo)\n * @param {Object} [options] optional\n * @param {Function} [callback]\n * @return {Query}\n * @see field selection #query_Query-select\n * @see lean queries #query_Query-lean\n * @api public\n */\n\nModel.findOne = function findOne(conditions, projection, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  } else if (typeof projection === 'function') {\n    callback = projection;\n    projection = null;\n    options = null;\n  } else if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n    projection = null;\n    options = null;\n  }\n\n  // get the mongodb collection object\n  var mq = new this.Query({}, {}, this, this.collection);\n  mq.select(projection);\n  mq.setOptions(options);\n  if (this.schema.discriminatorMapping && mq.selectedInclusively()) {\n    mq.select(this.schema.options.discriminatorKey);\n  }\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return mq.findOne(conditions, callback);\n};\n\n/**\n * Counts number of matching documents in a database collection.\n *\n * ####Example:\n *\n *     Adventure.count({ type: 'jungle' }, function (err, count) {\n *       if (err) ..\n *       console.log('there are %d jungle adventures', count);\n *     });\n *\n * @param {Object} conditions\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.count = function count(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n\n  // get the mongodb collection object\n  var mq = new this.Query({}, {}, this, this.collection);\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return mq.count(conditions, callback);\n};\n\n/**\n * Creates a Query for a `distinct` operation.\n *\n * Passing a `callback` immediately executes the query.\n *\n * ####Example\n *\n *     Link.distinct('url', { clicks: {$gt: 100}}, function (err, result) {\n *       if (err) return handleError(err);\n *\n *       assert(Array.isArray(result));\n *       console.log('unique urls with more than 100 clicks', result);\n *     })\n *\n *     var query = Link.distinct('url');\n *     query.exec(callback);\n *\n * @param {String} field\n * @param {Object} [conditions] optional\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.distinct = function distinct(field, conditions, callback) {\n  // get the mongodb collection object\n  var mq = new this.Query({}, {}, this, this.collection);\n\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return mq.distinct(field, conditions, callback);\n};\n\n/**\n * Creates a Query, applies the passed conditions, and returns the Query.\n *\n * For example, instead of writing:\n *\n *     User.find({age: {$gte: 21, $lte: 65}}, callback);\n *\n * we can instead write:\n *\n *     User.where('age').gte(21).lte(65).exec(callback);\n *\n * Since the Query class also supports `where` you can continue chaining\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     ... etc\n *\n * @param {String} path\n * @param {Object} [val] optional value\n * @return {Query}\n * @api public\n */\n\nModel.where = function where(path, val) {\n  void val; // eslint\n  // get the mongodb collection object\n  var mq = new this.Query({}, {}, this, this.collection).find({});\n  return mq.where.apply(mq, arguments);\n};\n\n/**\n * Creates a `Query` and specifies a `$where` condition.\n *\n * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n *\n *     Blog.$where('this.username.indexOf(\"val\") !== -1').exec(function (err, docs) {});\n *\n * @param {String|Function} argument is a javascript string or anonymous function\n * @method $where\n * @memberOf Model\n * @return {Query}\n * @see Query.$where #query_Query-%24where\n * @api public\n */\n\nModel.$where = function $where() {\n  var mq = new this.Query({}, {}, this, this.collection).find({});\n  return mq.$where.apply(mq, arguments);\n};\n\n/**\n * Issues a mongodb findAndModify update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed else a Query object is returned.\n *\n * ####Options:\n *\n * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n * - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).\n * - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update\n *\n *\n * ####Examples:\n *\n *     A.findOneAndUpdate(conditions, update, options, callback) // executes\n *     A.findOneAndUpdate(conditions, update, options)  // returns Query\n *     A.findOneAndUpdate(conditions, update, callback) // executes\n *     A.findOneAndUpdate(conditions, update)           // returns Query\n *     A.findOneAndUpdate()                             // returns Query\n *\n * ####Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * ####Example:\n *\n *     var query = { name: 'borne' };\n *     Model.findOneAndUpdate(query, { name: 'jason borne' }, options, callback)\n *\n *     // is sent as\n *     Model.findOneAndUpdate(query, { $set: { name: 'jason borne' }}, options, callback)\n *\n * This helps prevent accidentally overwriting your document with `{ name: 'jason borne' }`.\n *\n * ####Note:\n *\n * Values are cast to their appropriate types when using the findAndModify helpers.\n * However, the below are never executed.\n *\n * - defaults\n * - setters\n *\n * `findAndModify` helpers support limited defaults and validation. You can\n * enable these by setting the `setDefaultsOnInsert` and `runValidators` options,\n * respectively.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     Model.findById(id, function (err, doc) {\n *       if (err) ..\n *       doc.name = 'jason borne';\n *       doc.save(callback);\n *     });\n *\n * @param {Object} [conditions]\n * @param {Object} [update]\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nModel.findOneAndUpdate = function(conditions, update, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  } else if (arguments.length === 1) {\n    if (typeof conditions === 'function') {\n      var msg = 'Model.findOneAndUpdate(): First argument must not be a function.\\n\\n'\n          + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options, callback)\\n'\n          + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options)\\n'\n          + '  ' + this.modelName + '.findOneAndUpdate(conditions, update)\\n'\n          + '  ' + this.modelName + '.findOneAndUpdate(update)\\n'\n          + '  ' + this.modelName + '.findOneAndUpdate()\\n';\n      throw new TypeError(msg);\n    }\n    update = conditions;\n    conditions = undefined;\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  var fields;\n  if (options && options.fields) {\n    fields = options.fields;\n  }\n\n  update = utils.clone(update, {depopulate: 1, _isNested: true});\n  if (this.schema.options.versionKey && options && options.upsert) {\n    if (!update.$setOnInsert) {\n      update.$setOnInsert = {};\n    }\n    update.$setOnInsert[this.schema.options.versionKey] = 0;\n  }\n\n  var mq = new this.Query({}, {}, this, this.collection);\n  mq.select(fields);\n\n  return mq.findOneAndUpdate(conditions, update, options, callback);\n};\n\n/**\n * Issues a mongodb findAndModify update command by a document's _id field.\n * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.\n *\n * Finds a matching document, updates it according to the `update` arg,\n * passing any `options`, and returns the found document (if any) to the\n * callback. The query executes immediately if `callback` is passed else a\n * Query object is returned.\n *\n * This function triggers `findOneAndUpdate` middleware.\n *\n * ####Options:\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to false\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n * - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `select`: sets the document fields to return\n * - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update\n *\n * ####Examples:\n *\n *     A.findByIdAndUpdate(id, update, options, callback) // executes\n *     A.findByIdAndUpdate(id, update, options)  // returns Query\n *     A.findByIdAndUpdate(id, update, callback) // executes\n *     A.findByIdAndUpdate(id, update)           // returns Query\n *     A.findByIdAndUpdate()                     // returns Query\n *\n * ####Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * ####Example:\n *\n *     Model.findByIdAndUpdate(id, { name: 'jason borne' }, options, callback)\n *\n *     // is sent as\n *     Model.findByIdAndUpdate(id, { $set: { name: 'jason borne' }}, options, callback)\n *\n * This helps prevent accidentally overwriting your document with `{ name: 'jason borne' }`.\n *\n * ####Note:\n *\n * Values are cast to their appropriate types when using the findAndModify helpers.\n * However, the below are never executed.\n *\n * - defaults\n * - setters\n *\n * `findAndModify` helpers support limited defaults and validation. You can\n * enable these by setting the `setDefaultsOnInsert` and `runValidators` options,\n * respectively.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     Model.findById(id, function (err, doc) {\n *       if (err) ..\n *       doc.name = 'jason borne';\n *       doc.save(callback);\n *     });\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [update]\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @see Model.findOneAndUpdate #model_Model.findOneAndUpdate\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nModel.findByIdAndUpdate = function(id, update, options, callback) {\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n  if (arguments.length === 1) {\n    if (typeof id === 'function') {\n      var msg = 'Model.findByIdAndUpdate(): First argument must not be a function.\\n\\n'\n          + '  ' + this.modelName + '.findByIdAndUpdate(id, callback)\\n'\n          + '  ' + this.modelName + '.findByIdAndUpdate(id)\\n'\n          + '  ' + this.modelName + '.findByIdAndUpdate()\\n';\n      throw new TypeError(msg);\n    }\n    return this.findOneAndUpdate({_id: id}, undefined);\n  }\n\n  // if a model is passed in instead of an id\n  if (id instanceof Document) {\n    id = id._id;\n  }\n\n  return this.findOneAndUpdate.call(this, {_id: id}, update, options, callback);\n};\n\n/**\n * Issue a mongodb findAndModify remove command.\n *\n * Finds a matching document, removes it, passing the found document (if any) to the callback.\n *\n * Executes immediately if `callback` is passed else a Query object is returned.\n *\n * ####Options:\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `select`: sets the document fields to return\n * - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update\n *\n * ####Examples:\n *\n *     A.findOneAndRemove(conditions, options, callback) // executes\n *     A.findOneAndRemove(conditions, options)  // return Query\n *     A.findOneAndRemove(conditions, callback) // executes\n *     A.findOneAndRemove(conditions) // returns Query\n *     A.findOneAndRemove()           // returns Query\n *\n * Values are cast to their appropriate types when using the findAndModify helpers.\n * However, the below are never executed.\n *\n * - defaults\n * - setters\n *\n * `findAndModify` helpers support limited defaults and validation. You can\n * enable these by setting the `setDefaultsOnInsert` and `runValidators` options,\n * respectively.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     Model.findById(id, function (err, doc) {\n *       if (err) ..\n *       doc.name = 'jason borne';\n *       doc.save(callback);\n *     });\n *\n * @param {Object} conditions\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nModel.findOneAndRemove = function(conditions, options, callback) {\n  if (arguments.length === 1 && typeof conditions === 'function') {\n    var msg = 'Model.findOneAndRemove(): First argument must not be a function.\\n\\n'\n        + '  ' + this.modelName + '.findOneAndRemove(conditions, callback)\\n'\n        + '  ' + this.modelName + '.findOneAndRemove(conditions)\\n'\n        + '  ' + this.modelName + '.findOneAndRemove()\\n';\n    throw new TypeError(msg);\n  }\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  var fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  var mq = new this.Query({}, {}, this, this.collection);\n  mq.select(fields);\n\n  return mq.findOneAndRemove(conditions, options, callback);\n};\n\n/**\n * Issue a mongodb findAndModify remove command by a document's _id field. `findByIdAndRemove(id, ...)` is equivalent to `findOneAndRemove({ _id: id }, ...)`.\n *\n * Finds a matching document, removes it, passing the found document (if any) to the callback.\n *\n * Executes immediately if `callback` is passed, else a `Query` object is returned.\n *\n * ####Options:\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `select`: sets the document fields to return\n * - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update\n *\n * ####Examples:\n *\n *     A.findByIdAndRemove(id, options, callback) // executes\n *     A.findByIdAndRemove(id, options)  // return Query\n *     A.findByIdAndRemove(id, callback) // executes\n *     A.findByIdAndRemove(id) // returns Query\n *     A.findByIdAndRemove()           // returns Query\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @see Model.findOneAndRemove #model_Model.findOneAndRemove\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n */\n\nModel.findByIdAndRemove = function(id, options, callback) {\n  if (arguments.length === 1 && typeof id === 'function') {\n    var msg = 'Model.findByIdAndRemove(): First argument must not be a function.\\n\\n'\n        + '  ' + this.modelName + '.findByIdAndRemove(id, callback)\\n'\n        + '  ' + this.modelName + '.findByIdAndRemove(id)\\n'\n        + '  ' + this.modelName + '.findByIdAndRemove()\\n';\n    throw new TypeError(msg);\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return this.findOneAndRemove({_id: id}, options, callback);\n};\n\n/**\n * Shortcut for saving one or more documents to the database.\n * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in\n * docs.\n *\n * Hooks Triggered:\n * - `save()`\n *\n * ####Example:\n *\n *     // pass individual docs\n *     Candy.create({ type: 'jelly bean' }, { type: 'snickers' }, function (err, jellybean, snickers) {\n *       if (err) // ...\n *     });\n *\n *     // pass an array\n *     var array = [{ type: 'jelly bean' }, { type: 'snickers' }];\n *     Candy.create(array, function (err, candies) {\n *       if (err) // ...\n *\n *       var jellybean = candies[0];\n *       var snickers = candies[1];\n *       // ...\n *     });\n *\n *     // callback is optional; use the returned promise if you like:\n *     var promise = Candy.create({ type: 'jawbreaker' });\n *     promise.then(function (jawbreaker) {\n *       // ...\n *     })\n *\n * @param {Array|Object|*} doc(s)\n * @param {Function} [callback] callback\n * @return {Promise}\n * @api public\n */\n\nModel.create = function create(doc, callback) {\n  var args;\n  var cb;\n  var discriminatorKey = this.schema.options.discriminatorKey;\n\n  if (Array.isArray(doc)) {\n    args = doc;\n    cb = callback;\n  } else {\n    var last = arguments[arguments.length - 1];\n    // Handle falsy callbacks re: #5061\n    if (typeof last === 'function' || !last) {\n      cb = last;\n      args = utils.args(arguments, 0, arguments.length - 1);\n    } else {\n      args = utils.args(arguments);\n    }\n  }\n\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  if (cb) {\n    cb = this.$wrapCallback(cb);\n  }\n\n  var promise = new Promise.ES6(function(resolve, reject) {\n    if (args.length === 0) {\n      setImmediate(function() {\n        cb && cb(null);\n        resolve(null);\n      });\n      return;\n    }\n\n    var toExecute = [];\n    args.forEach(function(doc) {\n      toExecute.push(function(callback) {\n        var Model = _this.discriminators && doc[discriminatorKey] ?\n          _this.discriminators[doc[discriminatorKey]] :\n          _this;\n        var toSave = doc instanceof Model ? doc : new Model(doc);\n        var callbackWrapper = function(error, doc) {\n          if (error) {\n            return callback(error);\n          }\n          callback(null, doc);\n        };\n\n        // Hack to avoid getting a promise because of\n        // $__registerHooksFromSchema\n        if (toSave.$__original_save) {\n          toSave.$__original_save({ __noPromise: true }, callbackWrapper);\n        } else {\n          toSave.save({ __noPromise: true }, callbackWrapper);\n        }\n      });\n    });\n\n    parallel(toExecute, function(error, savedDocs) {\n      if (error) {\n        if (cb) {\n          cb(error);\n        } else {\n          reject(error);\n        }\n        return;\n      }\n\n      if (doc instanceof Array) {\n        resolve(savedDocs);\n        cb && cb.call(_this, null, savedDocs);\n      } else {\n        resolve.apply(promise, savedDocs);\n        if (cb) {\n          savedDocs.unshift(null);\n          cb.apply(_this, savedDocs);\n        }\n      }\n    });\n  });\n\n  return promise;\n};\n\n/**\n * Shortcut for validating an array of documents and inserting them into\n * MongoDB if they're all valid. This function is faster than `.create()`\n * because it only sends one operation to the server, rather than one for each\n * document.\n *\n * This function does **not** trigger save middleware.\n *\n * ####Example:\n *\n *     var arr = [{ name: 'Star Wars' }, { name: 'The Empire Strikes Back' }];\n *     Movies.insertMany(arr, function(error, docs) {});\n *\n * @param {Array|Object|*} doc(s)\n * @param {Object} [options] see the [mongodb driver options](http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#insertMany)\n * @param {Function} [callback] callback\n * @return {Promise}\n * @api public\n */\n\nModel.insertMany = function(arr, options, callback) {\n  var _this = this;\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n\n  var toExecute = [];\n  arr.forEach(function(doc) {\n    toExecute.push(function(callback) {\n      doc = new _this(doc);\n      doc.validate({ __noPromise: true }, function(error) {\n        if (error) {\n          // Option `ordered` signals that insert should be continued after reaching\n          // a failing insert. Therefore we delegate \"null\", meaning the validation\n          // failed. It's up to the next function to filter out all failed models\n          if (options != null && typeof options === 'object' && options['ordered'] === false) {\n            return callback(null, null);\n          }\n          return callback(error);\n        }\n        callback(null, doc);\n      });\n    });\n  });\n\n  parallel(toExecute, function(error, docs) {\n    if (error) {\n      callback && callback(error);\n      return;\n    }\n    // We filter all failed pre-validations by removing nulls\n    var docAttributes = docs.filter(function(doc) {\n      return doc != null;\n    });\n    // Quickly escape while there aren't any valid docAttributes\n    if (docAttributes.length < 1) {\n      callback && callback(null, []);\n      return;\n    }\n    var docObjects = docAttributes.map(function(doc) {\n      if (doc.schema.options.versionKey) {\n        doc[doc.schema.options.versionKey] = 0;\n      }\n      if (doc.initializeTimestamps) {\n        return doc.initializeTimestamps().toObject(POJO_TO_OBJECT_OPTIONS);\n      }\n      return doc.toObject(POJO_TO_OBJECT_OPTIONS);\n    });\n    _this.collection.insertMany(docObjects, options, function(error) {\n      if (error) {\n        callback && callback(error);\n        return;\n      }\n      for (var i = 0; i < docAttributes.length; ++i) {\n        docAttributes[i].isNew = false;\n        docAttributes[i].emit('isNew', false);\n        docAttributes[i].constructor.emit('isNew', false);\n      }\n      callback && callback(null, docAttributes);\n    });\n  });\n};\n\n/**\n * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,\n * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one\n * command. This is faster than sending multiple independent operations because\n * with `bulkWrite()` there is only one round trip to the server.\n *\n * Mongoose will perform casting on all operations you provide.\n *\n * This function does **not** trigger any middleware.\n *\n * ####Example:\n *\n *     Character.bulkWrite([\n *       {\n *         insertOne: {\n *           document: {\n *             name: 'Eddard Stark',\n *             title: 'Warden of the North'\n *           }\n *         }\n *       },\n *       {\n *         updateOne: {\n *           filter: { name: 'Eddard Stark' },\n *           // Mongoose inserts `$set` for you in the update below\n *           update: { title: 'Hand of the King' }\n *         }\n *       },\n *       {\n *         deleteOne: {\n *           { name: 'Eddard Stark' }\n *         }\n *       }\n *     ]).then(handleResult);\n *\n * @param {Array} ops\n * @param {Object} [options]\n * @param {Function} [callback] callback `function(error, bulkWriteOpResult) {}`\n * @return {Promise} resolves to a `BulkWriteOpResult` if the operation succeeds\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~BulkWriteOpResult\n * @api public\n */\n\nModel.bulkWrite = function(ops, options, callback) {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n  options = options || {};\n\n  var validations = ops.map(function(op) {\n    if (op['insertOne']) {\n      return function(callback) {\n        op['insertOne']['document'] = new _this(op['insertOne']['document']);\n        op['insertOne']['document'].validate({ __noPromise: true }, function(error) {\n          if (error) {\n            return callback(error);\n          }\n          callback(null);\n        });\n      };\n    } else if (op['updateOne']) {\n      return function(callback) {\n        try {\n          op['updateOne']['filter'] = cast(_this.schema,\n            op['updateOne']['filter']);\n          op['updateOne']['update'] = castUpdate(_this.schema,\n            op['updateOne']['update'], _this.schema.options.strict);\n        } catch (error) {\n          return callback(error);\n        }\n\n        callback(null);\n      };\n    } else if (op['updateMany']) {\n      return function(callback) {\n        try {\n          op['updateMany']['filter'] = cast(_this.schema,\n            op['updateMany']['filter']);\n          op['updateMany']['update'] = castUpdate(_this.schema, op['updateMany']['filter'], {\n            strict: _this.schema.options.strict,\n            overwrite: false\n          });\n        } catch (error) {\n          return callback(error);\n        }\n\n        callback(null);\n      };\n    } else if (op['replaceOne']) {\n      return function(callback) {\n        try {\n          op['replaceOne']['filter'] = cast(_this.schema,\n            op['replaceOne']['filter']);\n        } catch (error) {\n          return callback(error);\n        }\n\n        // set `skipId`, otherwise we get \"_id field cannot be changed\"\n        op['replaceOne']['replacement'] =\n          new _this(op['replaceOne']['replacement'], null, true);\n        op['replaceOne']['replacement'].validate({ __noPromise: true }, function(error) {\n          if (error) {\n            return callback(error);\n          }\n          callback(null);\n        });\n      };\n    } else if (op['deleteOne']) {\n      return function(callback) {\n        try {\n          op['deleteOne']['filter'] = cast(_this.schema,\n            op['deleteOne']['filter']);\n        } catch (error) {\n          return callback(error);\n        }\n\n        callback(null);\n      };\n    } else if (op['deleteMany']) {\n      return function(callback) {\n        try {\n          op['deleteMany']['filter'] = cast(_this.schema,\n            op['deleteMany']['filter']);\n        } catch (error) {\n          return callback(error);\n        }\n\n        callback(null);\n      };\n    } else {\n      return function(callback) {\n        callback(new Error('Invalid op passed to `bulkWrite()`'));\n      };\n    }\n  });\n\n  var promise = new Promise.ES6(function(resolve, reject) {\n    parallel(validations, function(error) {\n      if (error) {\n        callback && callback(error);\n        return reject(error);\n      }\n\n      _this.collection.bulkWrite(ops, options, function(error, res) {\n        if (error) {\n          callback && callback(error);\n          return reject(error);\n        }\n\n        callback && callback(null, res);\n        resolve(res);\n      });\n    });\n  });\n\n  return promise;\n};\n\n/**\n * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.\n * The document returned has no paths marked as modified initially.\n *\n * ####Example:\n *\n *     // hydrate previous data into a Mongoose document\n *     var mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });\n *\n * @param {Object} obj\n * @return {Document}\n * @api public\n */\n\nModel.hydrate = function(obj) {\n  var model = require('./queryhelpers').createModel(this, obj);\n  model.init(obj);\n  return model;\n};\n\n/**\n * Updates one document in the database without returning it.\n *\n * ####Examples:\n *\n *     MyModel.update({ age: { $gt: 18 } }, { oldEnough: true }, fn);\n *     MyModel.update({ name: 'Tobi' }, { ferret: true }, { multi: true }, function (err, raw) {\n *       if (err) return handleError(err);\n *       console.log('The raw response from Mongo was ', raw);\n *     });\n *\n * ####Valid options:\n *\n *  - `safe` (boolean) safe mode (defaults to value set in schema (true))\n *  - `upsert` (boolean) whether to create the doc if it doesn't match (false)\n *  - `multi` (boolean) whether multiple documents should be updated (false)\n *  - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n *  - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).\n *  - `strict` (boolean) overrides the `strict` option for this update\n *  - `overwrite` (boolean) disables update-only mode, allowing you to overwrite the doc (false)\n *\n * All `update` values are cast to their appropriate SchemaTypes before being sent.\n *\n * The `callback` function receives `(err, rawResponse)`.\n *\n * - `err` is the error if any occurred\n * - `rawResponse` is the full response from Mongo\n *\n * ####Note:\n *\n * All top level keys which are not `atomic` operation names are treated as set operations:\n *\n * ####Example:\n *\n *     var query = { name: 'borne' };\n *     Model.update(query, { name: 'jason borne' }, options, callback)\n *\n *     // is sent as\n *     Model.update(query, { $set: { name: 'jason borne' }}, options, callback)\n *     // if overwrite option is false. If overwrite is true, sent without the $set wrapper.\n *\n * This helps prevent accidentally overwriting all documents in your collection with `{ name: 'jason borne' }`.\n *\n * ####Note:\n *\n * Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a \"Mod on _id not allowed\" error.\n *\n * ####Note:\n *\n * To update documents without waiting for a response from MongoDB, do not pass a `callback`, then call `exec` on the returned [Query](#query-js):\n *\n *     Comment.update({ _id: id }, { $set: { text: 'changed' }}).exec();\n *\n * ####Note:\n *\n * Although values are casted to their appropriate types when using update, the following are *not* applied:\n *\n * - defaults\n * - setters\n * - validators\n * - middleware\n *\n * If you need those features, use the traditional approach of first retrieving the document.\n *\n *     Model.findOne({ name: 'borne' }, function (err, doc) {\n *       if (err) ..\n *       doc.name = 'jason borne';\n *       doc.save(callback);\n *     })\n *\n * @see strict http://mongoosejs.com/docs/guide.html#strict\n * @see response http://docs.mongodb.org/v2.6/reference/command/update/#output\n * @param {Object} conditions\n * @param {Object} doc\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.update = function update(conditions, doc, options, callback) {\n  return _update(this, 'update', conditions, doc, options, callback);\n};\n\n/**\n * Same as `update()`, except MongoDB will update _all_ documents that match\n * `criteria` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * @param {Object} conditions\n * @param {Object} doc\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.updateMany = function updateMany(conditions, doc, options, callback) {\n  return _update(this, 'updateMany', conditions, doc, options, callback);\n};\n\n/**\n * Same as `update()`, except MongoDB will update _only_ the first document that\n * matches `criteria` regardless of the value of the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * @param {Object} conditions\n * @param {Object} doc\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.updateOne = function updateOne(conditions, doc, options, callback) {\n  return _update(this, 'updateOne', conditions, doc, options, callback);\n};\n\n/**\n * Same as `update()`, except MongoDB replace the existing document with the\n * given document (no atomic operators like `$set`).\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * @param {Object} conditions\n * @param {Object} doc\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.replaceOne = function replaceOne(conditions, doc, options, callback) {\n  return _update(this, 'replaceOne', conditions, doc, options, callback);\n};\n\n/*!\n * ignore\n */\n\nfunction _update(model, op, conditions, doc, options, callback) {\n  var mq = new model.Query({}, {}, model, model.collection);\n  if (callback) {\n    callback = model.$wrapCallback(callback);\n  }\n  // gh-2406\n  // make local deep copy of conditions\n  if (conditions instanceof Document) {\n    conditions = conditions.toObject();\n  } else {\n    conditions = utils.clone(conditions, {retainKeyOrder: true});\n  }\n  options = typeof options === 'function' ? options : utils.clone(options);\n\n  if (model.schema.options.versionKey && options && options.upsert) {\n    if (options.overwrite) {\n      doc[model.schema.options.versionKey] = 0;\n    } else {\n      if (!doc.$setOnInsert) {\n        doc.$setOnInsert = {};\n      }\n      doc.$setOnInsert[model.schema.options.versionKey] = 0;\n    }\n  }\n\n  return mq[op](conditions, doc, options, callback);\n}\n\n/**\n * Executes a mapReduce command.\n *\n * `o` is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See [node-mongodb-native mapReduce() documentation](http://mongodb.github.io/node-mongodb-native/api-generated/collection.html#mapreduce) for more detail about options.\n *\n * ####Example:\n *\n *     var o = {};\n *     o.map = function () { emit(this.name, 1) }\n *     o.reduce = function (k, vals) { return vals.length }\n *     User.mapReduce(o, function (err, results) {\n *       console.log(results)\n *     })\n *\n * ####Other options:\n *\n * - `query` {Object} query filter object.\n * - `sort` {Object} sort input objects using this key\n * - `limit` {Number} max number of documents\n * - `keeptemp` {Boolean, default:false} keep temporary data\n * - `finalize` {Function} finalize function\n * - `scope` {Object} scope variables exposed to map/reduce/finalize during execution\n * - `jsMode` {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X\n * - `verbose` {Boolean, default:false} provide statistics on job execution time.\n * - `readPreference` {String}\n * - `out*` {Object, default: {inline:1}} sets the output target for the map reduce job.\n *\n * ####* out options:\n *\n * - `{inline:1}` the results are returned in an array\n * - `{replace: 'collectionName'}` add the results to collectionName: the results replace the collection\n * - `{reduce: 'collectionName'}` add the results to collectionName: if dups are detected, uses the reducer / finalize functions\n * - `{merge: 'collectionName'}` add the results to collectionName: if dups exist the new docs overwrite the old\n *\n * If `options.out` is set to `replace`, `merge`, or `reduce`, a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the `lean` option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).\n *\n * ####Example:\n *\n *     var o = {};\n *     o.map = function () { emit(this.name, 1) }\n *     o.reduce = function (k, vals) { return vals.length }\n *     o.out = { replace: 'createdCollectionNameForResults' }\n *     o.verbose = true;\n *\n *     User.mapReduce(o, function (err, model, stats) {\n *       console.log('map reduce took %d ms', stats.processtime)\n *       model.find().where('value').gt(10).exec(function (err, docs) {\n *         console.log(docs);\n *       });\n *     })\n *\n *     // a promise is returned so you may instead write\n *     var promise = User.mapReduce(o);\n *     promise.then(function (model, stats) {\n *       console.log('map reduce took %d ms', stats.processtime)\n *       return model.find().where('value').gt(10).exec();\n *     }).then(function (docs) {\n *        console.log(docs);\n *     }).then(null, handleError).end()\n *\n * @param {Object} o an object specifying map-reduce options\n * @param {Function} [callback] optional callback\n * @see http://www.mongodb.org/display/DOCS/MapReduce\n * @return {Promise}\n * @api public\n */\n\nModel.mapReduce = function mapReduce(o, callback) {\n  var _this = this;\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n  var Promise = PromiseProvider.get();\n  return new Promise.ES6(function(resolve, reject) {\n    if (!Model.mapReduce.schema) {\n      var opts = {noId: true, noVirtualId: true, strict: false};\n      Model.mapReduce.schema = new Schema({}, opts);\n    }\n\n    if (!o.out) o.out = {inline: 1};\n    if (o.verbose !== false) o.verbose = true;\n\n    o.map = String(o.map);\n    o.reduce = String(o.reduce);\n\n    if (o.query) {\n      var q = new _this.Query(o.query);\n      q.cast(_this);\n      o.query = q._conditions;\n      q = undefined;\n    }\n\n    _this.collection.mapReduce(null, null, o, function(err, ret, stats) {\n      if (err) {\n        callback && callback(err);\n        reject(err);\n        return;\n      }\n\n      if (ret.findOne && ret.mapReduce) {\n        // returned a collection, convert to Model\n        var model = Model.compile(\n            '_mapreduce_' + ret.collectionName\n            , Model.mapReduce.schema\n            , ret.collectionName\n            , _this.db\n            , _this.base);\n\n        model._mapreduce = true;\n\n        callback && callback(null, model, stats);\n        return resolve(model, stats);\n      }\n\n      callback && callback(null, ret, stats);\n      resolve(ret, stats);\n    });\n  });\n};\n\n/**\n * geoNear support for Mongoose\n *\n * ####Options:\n * - `lean` {Boolean} return the raw object\n * - All options supported by the driver are also supported\n *\n * ####Example:\n *\n *     // Legacy point\n *     Model.geoNear([1,3], { maxDistance : 5, spherical : true }, function(err, results, stats) {\n *        console.log(results);\n *     });\n *\n *     // geoJson\n *     var point = { type : \"Point\", coordinates : [9,9] };\n *     Model.geoNear(point, { maxDistance : 5, spherical : true }, function(err, results, stats) {\n *        console.log(results);\n *     });\n *\n * @param {Object|Array} GeoJSON point or legacy coordinate pair [x,y] to search near\n * @param {Object} options for the query\n * @param {Function} [callback] optional callback for the query\n * @return {Promise}\n * @see http://docs.mongodb.org/manual/core/2dsphere/\n * @see http://mongodb.github.io/node-mongodb-native/api-generated/collection.html?highlight=geonear#geoNear\n * @api public\n */\n\nModel.geoNear = function(near, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  var _this = this;\n  var Promise = PromiseProvider.get();\n  if (!near) {\n    return new Promise.ES6(function(resolve, reject) {\n      var error = new Error('Must pass a near option to geoNear');\n      reject(error);\n      callback && callback(error);\n    });\n  }\n\n  var x, y;\n\n  return new Promise.ES6(function(resolve, reject) {\n    var handler = function(err, res) {\n      if (err) {\n        reject(err);\n        callback && callback(err);\n        return;\n      }\n      if (options.lean) {\n        resolve(res.results, res.stats);\n        callback && callback(null, res.results, res.stats);\n        return;\n      }\n\n      var count = res.results.length;\n      // if there are no results, fulfill the promise now\n      if (count === 0) {\n        resolve(res.results, res.stats);\n        callback && callback(null, res.results, res.stats);\n        return;\n      }\n\n      var errSeen = false;\n\n      function init(err) {\n        if (err && !errSeen) {\n          errSeen = true;\n          reject(err);\n          callback && callback(err);\n          return;\n        }\n        if (--count <= 0) {\n          resolve(res.results, res.stats);\n          callback && callback(null, res.results, res.stats);\n        }\n      }\n\n      for (var i = 0; i < res.results.length; i++) {\n        var temp = res.results[i].obj;\n        res.results[i].obj = new _this();\n        res.results[i].obj.init(temp, init);\n      }\n    };\n\n    if (Array.isArray(near)) {\n      if (near.length !== 2) {\n        var error = new Error('If using legacy coordinates, must be an array ' +\n            'of size 2 for geoNear');\n        reject(error);\n        callback && callback(error);\n        return;\n      }\n      x = near[0];\n      y = near[1];\n      _this.collection.geoNear(x, y, options, handler);\n    } else {\n      if (near.type !== 'Point' || !Array.isArray(near.coordinates)) {\n        error = new Error('Must pass either a legacy coordinate array or ' +\n            'GeoJSON Point to geoNear');\n        reject(error);\n        callback && callback(error);\n        return;\n      }\n\n      _this.collection.geoNear(near, options, handler);\n    }\n  });\n};\n\n/**\n * Performs [aggregations](http://docs.mongodb.org/manual/applications/aggregation/) on the models collection.\n *\n * If a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.\n *\n * ####Example:\n *\n *     // Find the max balance of all accounts\n *     Users.aggregate(\n *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},\n *       { $project: { _id: 0, maxBalance: 1 }},\n *       function (err, res) {\n *         if (err) return handleError(err);\n *         console.log(res); // [ { maxBalance: 98000 } ]\n *       });\n *\n *     // Or use the aggregation pipeline builder.\n *     Users.aggregate()\n *       .group({ _id: null, maxBalance: { $max: '$balance' } })\n *       .select('-id maxBalance')\n *       .exec(function (err, res) {\n *         if (err) return handleError(err);\n *         console.log(res); // [ { maxBalance: 98 } ]\n *     });\n *\n * ####NOTE:\n *\n * - Arguments are not cast to the model's schema because `$project` operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format.\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n * - Requires MongoDB >= 2.1\n *\n * @see Aggregate #aggregate_Aggregate\n * @see MongoDB http://docs.mongodb.org/manual/applications/aggregation/\n * @param {Object|Array} [...] aggregation pipeline operator(s) or operator array\n * @param {Function} [callback]\n * @return {Aggregate|Promise}\n * @api public\n */\n\nModel.aggregate = function aggregate() {\n  var args = [].slice.call(arguments),\n      aggregate,\n      callback;\n\n  if (typeof args[args.length - 1] === 'function') {\n    callback = args.pop();\n  }\n\n  if (args.length === 1 && util.isArray(args[0])) {\n    aggregate = new Aggregate(args[0]);\n  } else {\n    aggregate = new Aggregate(args);\n  }\n\n  aggregate.model(this);\n\n  if (typeof callback === 'undefined') {\n    return aggregate;\n  }\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  aggregate.exec(callback);\n};\n\n/**\n * Implements `$geoSearch` functionality for Mongoose\n *\n * ####Example:\n *\n *     var options = { near: [10, 10], maxDistance: 5 };\n *     Locations.geoSearch({ type : \"house\" }, options, function(err, res) {\n *       console.log(res);\n *     });\n *\n * ####Options:\n * - `near` {Array} x,y point to search for\n * - `maxDistance` {Number} the maximum distance from the point near that a result can be\n * - `limit` {Number} The maximum number of results to return\n * - `lean` {Boolean} return the raw object instead of the Mongoose Model\n *\n * @param {Object} conditions an object that specifies the match condition (required)\n * @param {Object} options for the geoSearch, some (near, maxDistance) are required\n * @param {Function} [callback] optional callback\n * @return {Promise}\n * @see http://docs.mongodb.org/manual/reference/command/geoSearch/\n * @see http://docs.mongodb.org/manual/core/geohaystack/\n * @api public\n */\n\nModel.geoSearch = function(conditions, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  var _this = this;\n  var Promise = PromiseProvider.get();\n  return new Promise.ES6(function(resolve, reject) {\n    var error;\n    if (conditions === undefined || !utils.isObject(conditions)) {\n      error = new Error('Must pass conditions to geoSearch');\n    } else if (!options.near) {\n      error = new Error('Must specify the near option in geoSearch');\n    } else if (!Array.isArray(options.near)) {\n      error = new Error('near option must be an array [x, y]');\n    }\n\n    if (error) {\n      callback && callback(error);\n      reject(error);\n      return;\n    }\n\n    // send the conditions in the options object\n    options.search = conditions;\n\n    _this.collection.geoHaystackSearch(options.near[0], options.near[1], options, function(err, res) {\n      // have to deal with driver problem. Should be fixed in a soon-ish release\n      // (7/8/2013)\n      if (err) {\n        callback && callback(err);\n        reject(err);\n        return;\n      }\n\n      var count = res.results.length;\n      if (options.lean || count === 0) {\n        callback && callback(null, res.results, res.stats);\n        resolve(res.results, res.stats);\n        return;\n      }\n\n      var errSeen = false;\n\n      function init(err) {\n        if (err && !errSeen) {\n          callback && callback(err);\n          reject(err);\n          return;\n        }\n\n        if (!--count && !errSeen) {\n          callback && callback(null, res.results, res.stats);\n          resolve(res.results, res.stats);\n        }\n      }\n\n      for (var i = 0; i < res.results.length; i++) {\n        var temp = res.results[i];\n        res.results[i] = new _this();\n        res.results[i].init(temp, {}, init);\n      }\n    });\n  });\n};\n\n/**\n * Populates document references.\n *\n * ####Available options:\n *\n * - path: space delimited path(s) to populate\n * - select: optional fields to select\n * - match: optional query conditions to match\n * - model: optional name of the model to use for population\n * - options: optional query options like sort, limit, etc\n *\n * ####Examples:\n *\n *     // populates a single object\n *     User.findById(id, function (err, user) {\n *       var opts = [\n *           { path: 'company', match: { x: 1 }, select: 'name' }\n *         , { path: 'notes', options: { limit: 10 }, model: 'override' }\n *       ]\n *\n *       User.populate(user, opts, function (err, user) {\n *         console.log(user);\n *       });\n *     });\n *\n *     // populates an array of objects\n *     User.find(match, function (err, users) {\n *       var opts = [{ path: 'company', match: { x: 1 }, select: 'name' }]\n *\n *       var promise = User.populate(users, opts);\n *       promise.then(console.log).end();\n *     })\n *\n *     // imagine a Weapon model exists with two saved documents:\n *     //   { _id: 389, name: 'whip' }\n *     //   { _id: 8921, name: 'boomerang' }\n *     // and this schema:\n *     // new Schema({\n *     //   name: String,\n *     //   weapon: { type: ObjectId, ref: 'Weapon' }\n *     // });\n *\n *     var user = { name: 'Indiana Jones', weapon: 389 }\n *     Weapon.populate(user, { path: 'weapon', model: 'Weapon' }, function (err, user) {\n *       console.log(user.weapon.name) // whip\n *     })\n *\n *     // populate many plain objects\n *     var users = [{ name: 'Indiana Jones', weapon: 389 }]\n *     users.push({ name: 'Batman', weapon: 8921 })\n *     Weapon.populate(users, { path: 'weapon' }, function (err, users) {\n *       users.forEach(function (user) {\n *         console.log('%s uses a %s', users.name, user.weapon.name)\n *         // Indiana Jones uses a whip\n *         // Batman uses a boomerang\n *       });\n *     });\n *     // Note that we didn't need to specify the Weapon model because\n *     // it is in the schema's ref\n *\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object} options A hash of key/val (path, options) used for population.\n * @param {Function} [callback(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Promise}\n * @api public\n */\n\nModel.populate = function(docs, paths, callback) {\n  var _this = this;\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  // normalized paths\n  var noPromise = paths && !!paths.__noPromise;\n  paths = utils.populate(paths);\n\n  // data that should persist across subPopulate calls\n  var cache = {};\n\n  if (noPromise) {\n    _populate(this, docs, paths, cache, callback);\n  } else {\n    var Promise = PromiseProvider.get();\n    return new Promise.ES6(function(resolve, reject) {\n      _populate(_this, docs, paths, cache, function(error, docs) {\n        if (error) {\n          callback && callback(error);\n          reject(error);\n        } else {\n          callback && callback(null, docs);\n          resolve(docs);\n        }\n      });\n    });\n  }\n};\n\n/*!\n * Populate helper\n *\n * @param {Model} model the model to use\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object} paths\n * @param {Function} [cb(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Function}\n * @api private\n */\n\nfunction _populate(model, docs, paths, cache, callback) {\n  var pending = paths.length;\n\n  if (pending === 0) {\n    return callback(null, docs);\n  }\n\n  // each path has its own query options and must be executed separately\n  var i = pending;\n  var path;\n  while (i--) {\n    path = paths[i];\n    populate(model, docs, path, next);\n  }\n\n  function next(err) {\n    if (err) {\n      return callback(err);\n    }\n    if (--pending) {\n      return;\n    }\n    callback(null, docs);\n  }\n}\n\n/*!\n * Populates `docs`\n */\nvar excludeIdReg = /\\s?-_id\\s?/,\n    excludeIdRegGlobal = /\\s?-_id\\s?/g;\n\nfunction populate(model, docs, options, callback) {\n  var modelsMap;\n\n  // normalize single / multiple docs passed\n  if (!Array.isArray(docs)) {\n    docs = [docs];\n  }\n\n  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {\n    return callback();\n  }\n\n  modelsMap = getModelsMapForPopulate(model, docs, options);\n  if (modelsMap instanceof Error) {\n    return setImmediate(function() {\n      callback(modelsMap);\n    });\n  }\n\n  var i, len = modelsMap.length,\n      mod, match, select, vals = [];\n\n  function flatten(item) {\n    // no need to include undefined values in our query\n    return undefined !== item;\n  }\n\n  var _remaining = len;\n  var hasOne = false;\n  for (i = 0; i < len; i++) {\n    mod = modelsMap[i];\n    select = mod.options.select;\n\n    if (mod.options.match) {\n      match = utils.object.shallowCopy(mod.options.match);\n    } else {\n      match = {};\n    }\n\n    var ids = utils.array.flatten(mod.ids, flatten);\n    ids = utils.array.unique(ids);\n\n    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {\n      --_remaining;\n      continue;\n    }\n\n    hasOne = true;\n    if (mod.foreignField !== '_id' || !match['_id']) {\n      match[mod.foreignField] = { $in: ids };\n    }\n\n    var assignmentOpts = {};\n    assignmentOpts.sort = mod.options.options && mod.options.options.sort || undefined;\n    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && select._id === 0);\n\n    if (assignmentOpts.excludeId) {\n      // override the exclusion from the query so we can use the _id\n      // for document matching during assignment. we'll delete the\n      // _id back off before returning the result.\n      if (typeof select === 'string') {\n        select = select.replace(excludeIdRegGlobal, ' ');\n      } else {\n        // preserve original select conditions by copying\n        select = utils.object.shallowCopy(select);\n        delete select._id;\n      }\n    }\n\n    if (mod.options.options && mod.options.options.limit) {\n      assignmentOpts.originalLimit = mod.options.options.limit;\n      mod.options.options.limit = mod.options.options.limit * ids.length;\n    }\n\n    var subPopulate = mod.options.populate;\n    var query = mod.Model.find(match, select, mod.options.options);\n\n    /* If we're doing virtual populate and projection is inclusive and foreign\n     * field is not selected, automatically select it because mongoose needs it.\n     * If projection is exclusive and client explicitly unselected the foreign\n     * field, that's the client's fault. */\n    if (mod.foreignField !== '_id' && query.selectedInclusively() &&\n      !isPathSelectedInclusive(query._fields, mod.foreignField)) {\n      query.select(mod.foreignField);\n    }\n\n    // If we need to sub-populate, call populate recursively\n    if (subPopulate) {\n      query.populate(subPopulate);\n    }\n\n    query.exec(next.bind(this, mod, assignmentOpts));\n  }\n\n  if (!hasOne) {\n    return callback();\n  }\n\n  function next(options, assignmentOpts, err, valsFromDb) {\n    if (err) return callback(err);\n    vals = vals.concat(valsFromDb);\n    _assign(null, vals, options, assignmentOpts);\n    if (--_remaining === 0) {\n      callback();\n    }\n  }\n\n  function _assign(err, vals, mod, assignmentOpts) {\n    if (err) return callback(err);\n\n    var options = mod.options;\n    var isVirtual = mod.isVirtual;\n    var justOne = mod.justOne;\n    var _val;\n    var lean = options.options && options.options.lean;\n    var len = vals.length;\n    var rawOrder = {};\n    var rawDocs = {};\n    var key;\n    var val;\n\n    // optimization:\n    // record the document positions as returned by\n    // the query result.\n    for (var i = 0; i < len; i++) {\n      val = vals[i];\n      if (val) {\n        _val = utils.getValue(mod.foreignField, val);\n        if (Array.isArray(_val)) {\n          var _valLength = _val.length;\n          for (var j = 0; j < _valLength; ++j) {\n            var __val = _val[j];\n            if (__val instanceof Document) {\n              __val = __val._id;\n            }\n            key = String(__val);\n            if (rawDocs[key]) {\n              if (Array.isArray(rawDocs[key])) {\n                rawDocs[key].push(val);\n                rawOrder[key].push(i);\n              } else {\n                rawDocs[key] = [rawDocs[key], val];\n                rawOrder[key] = [rawOrder[key], i];\n              }\n            } else {\n              if (isVirtual && !justOne) {\n                rawDocs[key] = [val];\n                rawOrder[key] = [i];\n              } else {\n                rawDocs[key] = val;\n                rawOrder[key] = i;\n              }\n            }\n          }\n        } else {\n          if (_val instanceof Document) {\n            _val = _val._id;\n          }\n          key = String(_val);\n          if (rawDocs[key]) {\n            if (Array.isArray(rawDocs[key])) {\n              rawDocs[key].push(val);\n              rawOrder[key].push(i);\n            } else {\n              rawDocs[key] = [rawDocs[key], val];\n              rawOrder[key] = [rawOrder[key], i];\n            }\n          } else {\n            rawDocs[key] = val;\n            rawOrder[key] = i;\n          }\n        }\n        // flag each as result of population\n        if (!lean) {\n          val.$__.wasPopulated = true;\n        }\n      }\n    }\n\n    assignVals({\n      originalModel: model,\n      rawIds: mod.allIds,\n      localField: mod.localField,\n      foreignField: mod.foreignField,\n      rawDocs: rawDocs,\n      rawOrder: rawOrder,\n      docs: mod.docs,\n      path: options.path,\n      options: assignmentOpts,\n      justOne: mod.justOne,\n      isVirtual: mod.isVirtual\n    });\n  }\n}\n\n/*!\n * Assigns documents returned from a population query back\n * to the original document path.\n */\n\nfunction assignVals(o) {\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, o.options,\n    o.localField, o.foreignField);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n\n  var docs = o.docs;\n  var rawIds = o.rawIds;\n  var options = o.options;\n\n  function setValue(val) {\n    return valueFilter(val, options);\n  }\n\n  for (var i = 0; i < docs.length; ++i) {\n    if (utils.getValue(o.path, docs[i]) == null &&\n      !o.originalModel.schema._getVirtual(o.path)) {\n      continue;\n    }\n\n    if (o.isVirtual && !o.justOne && !Array.isArray(rawIds[i])) {\n      rawIds[i] = [rawIds[i]];\n    }\n    utils.setValue(o.path, rawIds[i], docs[i], setValue);\n  }\n}\n\n/*!\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} vals\n * @param {Boolean} sort\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, localFields, foreignFields, recursed) {\n  // honor user specified sort order\n  var newOrder = [];\n  var sorting = options.sort && rawIds.length > 1;\n  var doc;\n  var sid;\n  var id;\n\n  for (var i = 0; i < rawIds.length; ++i) {\n    id = rawIds[i];\n\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, localFields, foreignFields, true);\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id === null && !sorting) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n\n    sid = String(id);\n\n    if (recursed) {\n      // apply find behavior\n\n      // assign matching documents in original order unless sorting\n      doc = resultDocs[sid];\n      if (doc) {\n        if (sorting) {\n          newOrder[resultOrder[sid]] = doc;\n        } else {\n          newOrder.push(doc);\n        }\n      } else {\n        newOrder.push(id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc = resultDocs[sid] || null;\n    }\n  }\n\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function(doc, i) {\n      if (!doc) {\n        return;\n      }\n      rawIds[i] = doc;\n    });\n  }\n}\n\nfunction getModelsMapForPopulate(model, docs, options) {\n  var i, doc, len = docs.length,\n      available = {},\n      map = [],\n      modelNameFromQuery = options.model && options.model.modelName || options.model,\n      schema, refPath, Model, currentOptions, modelNames, modelName, discriminatorKey, modelForFindSchema;\n\n  var originalModel = options.model;\n  var isVirtual = false;\n  var isRefPathArray = false;\n\n  schema = model._getSchema(options.path);\n  var isUnderneathDocArray = schema && schema.$isUnderneathDocArray;\n  if (isUnderneathDocArray &&\n      options &&\n      options.options &&\n      options.options.sort) {\n    return new Error('Cannot populate with `sort` on path ' + options.path +\n      ' because it is a subproperty of a document array');\n  }\n\n  if (schema && schema.caster) {\n    schema = schema.caster;\n  }\n\n  if (!schema && model.discriminators) {\n    discriminatorKey = model.schema.discriminatorMapping.key;\n  }\n\n  refPath = schema && schema.options && schema.options.refPath;\n\n  for (i = 0; i < len; i++) {\n    doc = docs[i];\n\n    if (refPath) {\n      modelNames = utils.getValue(refPath, doc);\n      isRefPathArray = Array.isArray(modelNames);\n      if (isRefPathArray) {\n        modelNames = modelNames.filter(function(v) {\n          return v != null;\n        });\n      }\n    } else {\n      if (!modelNameFromQuery) {\n        var modelForCurrentDoc = model;\n        var schemaForCurrentDoc;\n\n        if (!schema && discriminatorKey) {\n          modelForFindSchema = utils.getValue(discriminatorKey, doc);\n\n          if (modelForFindSchema) {\n            modelForCurrentDoc = model.db.model(modelForFindSchema);\n            schemaForCurrentDoc = modelForCurrentDoc._getSchema(options.path);\n\n            if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n              schemaForCurrentDoc = schemaForCurrentDoc.caster;\n            }\n          }\n        } else {\n          schemaForCurrentDoc = schema;\n        }\n        var virtual = modelForCurrentDoc.schema._getVirtual(options.path);\n\n        if (schemaForCurrentDoc && schemaForCurrentDoc.options && schemaForCurrentDoc.options.ref) {\n          modelNames = [schemaForCurrentDoc.options.ref];\n        } else if (virtual && virtual.options && virtual.options.ref) {\n          modelNames = [virtual && virtual.options && virtual.options.ref];\n          isVirtual = true;\n        } else {\n          // We may have a discriminator, in which case we don't want to\n          // populate using the base model by default\n          modelNames = discriminatorKey ? null : [model.modelName];\n        }\n      } else {\n        modelNames = [modelNameFromQuery];  // query options\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    virtual = model.schema._getVirtual(options.path);\n    var localField = virtual && virtual.options ?\n      (virtual.$nestedSchemaPath ? virtual.$nestedSchemaPath + '.' : '') + virtual.options.localField :\n      options.path;\n    var foreignField = virtual && virtual.options ?\n      virtual.options.foreignField :\n      '_id';\n    var justOne = virtual && virtual.options && virtual.options.justOne;\n    if (virtual && virtual.options && virtual.options.ref) {\n      isVirtual = true;\n    }\n\n    if (virtual && (!localField || !foreignField)) {\n      throw new Error('If you are populating a virtual, you must set the ' +\n        'localField and foreignField options');\n    }\n\n    options.isVirtual = isVirtual;\n    var ret = convertTo_id(utils.getValue(localField, doc));\n    var id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n    if (doc.$__) {\n      doc.populated(options.path, options._docs[id], options);\n    }\n\n    var k = modelNames.length;\n    while (k--) {\n      modelName = modelNames[k];\n      var _doc = Array.isArray(doc) && isRefPathArray ? doc[k] : doc;\n      var _ret = Array.isArray(ret) && isRefPathArray ? ret[k] : ret;\n      Model = originalModel && originalModel.modelName ?\n        originalModel :\n        model.db.model(modelName);\n\n      if (!available[modelName]) {\n        currentOptions = {\n          model: Model\n        };\n\n        if (isVirtual && virtual.options && virtual.options.options) {\n          currentOptions.options = utils.clone(virtual.options.options, {\n            retainKeyOrder: true\n          });\n        }\n        utils.merge(currentOptions, options);\n        if (schema && !discriminatorKey) {\n          currentOptions.model = Model;\n        }\n        options.model = Model;\n\n        available[modelName] = {\n          Model: Model,\n          options: currentOptions,\n          docs: [_doc],\n          ids: [_ret],\n          allIds: [ret],\n          // Assume only 1 localField + foreignField\n          localField: localField,\n          foreignField: foreignField,\n          justOne: justOne,\n          isVirtual: isVirtual\n        };\n        map.push(available[modelName]);\n      } else {\n        available[modelName].docs.push(_doc);\n        available[modelName].ids.push(_ret);\n        available[modelName].allIds.push(ret);\n      }\n    }\n  }\n\n  return map;\n}\n\n/*!\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @return {Array|Document|Any}\n */\n\nfunction convertTo_id(val) {\n  if (val instanceof Model) return val._id;\n\n  if (Array.isArray(val)) {\n    for (var i = 0; i < val.length; ++i) {\n      if (val[i] instanceof Model) {\n        val[i] = val[i]._id;\n      }\n    }\n    if (val.isMongooseArray) {\n      return val._schema.cast(val, val._parent);\n    }\n\n    return [].concat(val);\n  }\n\n  return val;\n}\n\n/*!\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n */\n\nfunction valueFilter(val, assignmentOpts) {\n  if (Array.isArray(val)) {\n    // find logic\n    var ret = [];\n    var numValues = val.length;\n    for (var i = 0; i < numValues; ++i) {\n      var subdoc = val[i];\n      if (!isDoc(subdoc)) continue;\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit &&\n          ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > ret.length) {\n      Array.prototype.pop.apply(val, []);\n    }\n    for (i = 0; i < ret.length; ++i) {\n      val[i] = ret[i];\n    }\n    return val;\n  }\n\n  // findOne\n  if (isDoc(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return val;\n  }\n\n  return null;\n}\n\n/*!\n * Remove _id from `subdoc` if user specified \"lean\" query option\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (assignmentOpts.excludeId) {\n    if (typeof subdoc.setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/*!\n * Determine if `doc` is a document returned\n * by a populate query.\n */\n\nfunction isDoc(doc) {\n  if (doc == null) {\n    return false;\n  }\n\n  var type = typeof doc;\n  if (type === 'string') {\n    return false;\n  }\n\n  if (type === 'number') {\n    return false;\n  }\n\n  if (Buffer.isBuffer(doc)) {\n    return false;\n  }\n\n  if (doc.constructor.name === 'ObjectID') {\n    return false;\n  }\n\n  // only docs\n  return true;\n}\n\n/**\n * Finds the schema for `path`. This is different than\n * calling `schema.path` as it also resolves paths with\n * positional selectors (something.$.another.$.path).\n *\n * @param {String} path\n * @return {Schema}\n * @api private\n */\n\nModel._getSchema = function _getSchema(path) {\n  return this.schema._getSchema(path);\n};\n\n/*!\n * Compiler utility.\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} schema\n * @param {String} collectionName\n * @param {Connection} connection\n * @param {Mongoose} base mongoose instance\n */\n\nModel.compile = function compile(name, schema, collectionName, connection, base) {\n  var versioningEnabled = schema.options.versionKey !== false;\n\n  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n    // add versioning to top level documents only\n    var o = {};\n    o[schema.options.versionKey] = Number;\n    schema.add(o);\n  }\n\n  var model;\n  if (typeof name === 'function' && name.prototype instanceof Model) {\n    model = name;\n    name = model.name;\n    schema.loadClass(model, true);\n    model.prototype.$isMongooseModelPrototype = true;\n  } else {\n    // generate new class\n    model = function model(doc, fields, skipId) {\n      if (!(this instanceof model)) {\n        return new model(doc, fields, skipId);\n      }\n      Model.call(this, doc, fields, skipId);\n    };\n  }\n\n  model.hooks = schema.s.hooks.clone();\n  model.base = base;\n  model.modelName = name;\n  if (!(model.prototype instanceof Model)) {\n    model.__proto__ = Model;\n    model.prototype.__proto__ = Model.prototype;\n  }\n  model.model = Model.prototype.model;\n  model.db = model.prototype.db = connection;\n  model.discriminators = model.prototype.discriminators = undefined;\n\n  model.prototype.$__setSchema(schema);\n\n  var collectionOptions = {\n    bufferCommands: schema.options.bufferCommands,\n    capped: schema.options.capped\n  };\n\n  model.prototype.collection = connection.collection(\n      collectionName\n      , collectionOptions\n  );\n\n  // apply methods and statics\n  applyMethods(model, schema);\n  applyStatics(model, schema);\n  applyHooks(model, schema);\n\n  model.schema = model.prototype.schema;\n  model.collection = model.prototype.collection;\n\n  // Create custom query constructor\n  model.Query = function() {\n    Query.apply(this, arguments);\n    this.options.retainKeyOrder = model.schema.options.retainKeyOrder;\n  };\n  model.Query.prototype = Object.create(Query.prototype);\n  model.Query.base = Query.base;\n  applyQueryMethods(model, schema.query);\n\n  var kareemOptions = { useErrorHandlers: true };\n  model.$__insertMany = model.hooks.createWrapper('insertMany',\n    model.insertMany, model, kareemOptions);\n  model.insertMany = function(arr, options, callback) {\n    var Promise = PromiseProvider.get();\n    if (typeof options === 'function') {\n      callback = options;\n      options = null;\n    }\n    return new Promise.ES6(function(resolve, reject) {\n      model.$__insertMany(arr, options, function(error, result) {\n        if (error) {\n          callback && callback(error);\n          return reject(error);\n        }\n        callback && callback(null, result);\n        resolve(result);\n      });\n    });\n  };\n\n  return model;\n};\n\n/*!\n * Register custom query methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nfunction applyQueryMethods(model, methods) {\n  for (var i in methods) {\n    model.Query.prototype[i] = methods[i];\n  }\n}\n\n/*!\n * Subclass this model with `conn`, `schema`, and `collection` settings.\n *\n * @param {Connection} conn\n * @param {Schema} [schema]\n * @param {String} [collection]\n * @return {Model}\n */\n\nModel.__subclass = function subclass(conn, schema, collection) {\n  // subclass model using this connection and collection name\n  var _this = this;\n\n  var Model = function Model(doc, fields, skipId) {\n    if (!(this instanceof Model)) {\n      return new Model(doc, fields, skipId);\n    }\n    _this.call(this, doc, fields, skipId);\n  };\n\n  Model.__proto__ = _this;\n  Model.prototype.__proto__ = _this.prototype;\n  Model.db = Model.prototype.db = conn;\n\n  var s = schema && typeof schema !== 'string'\n      ? schema\n      : _this.prototype.schema;\n\n  var options = s.options || {};\n\n  if (!collection) {\n    collection = _this.prototype.schema.get('collection')\n        || utils.toCollectionName(_this.modelName, options);\n  }\n\n  var collectionOptions = {\n    bufferCommands: s ? options.bufferCommands : true,\n    capped: s && options.capped\n  };\n\n  Model.prototype.collection = conn.collection(collection, collectionOptions);\n  Model.collection = Model.prototype.collection;\n  Model.init();\n  return Model;\n};\n\nModel.$wrapCallback = function(callback) {\n  var _this = this;\n  return function() {\n    try {\n      callback.apply(null, arguments);\n    } catch (error) {\n      _this.emit('error', error);\n    }\n  };\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Model;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/aggregate.js":"/*!\n * Module dependencies\n */\n\nvar util = require('util');\nvar utils = require('./utils');\nvar PromiseProvider = require('./promise_provider');\nvar Query = require('./query');\nvar read = Query.prototype.read;\n\n/**\n * Aggregate constructor used for building aggregation pipelines.\n *\n * ####Example:\n *\n *     new Aggregate();\n *     new Aggregate({ $project: { a: 1, b: 1 } });\n *     new Aggregate({ $project: { a: 1, b: 1 } }, { $skip: 5 });\n *     new Aggregate([{ $project: { a: 1, b: 1 } }, { $skip: 5 }]);\n *\n * Returned when calling Model.aggregate().\n *\n * ####Example:\n *\n *     Model\n *     .aggregate({ $match: { age: { $gte: 21 }}})\n *     .unwind('tags')\n *     .exec(callback)\n *\n * ####Note:\n *\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n * - Requires MongoDB >= 2.1\n * - Mongoose does **not** cast pipeline stages. `new Aggregate({ $match: { _id: '00000000000000000000000a' } });` will not work unless `_id` is a string in the database. Use `new Aggregate({ $match: { _id: mongoose.Types.ObjectId('00000000000000000000000a') } });` instead.\n *\n * @see MongoDB http://docs.mongodb.org/manual/applications/aggregation/\n * @see driver http://mongodb.github.com/node-mongodb-native/api-generated/collection.html#aggregate\n * @param {Object|Array} [ops] aggregation operator(s) or operator array\n * @api public\n */\n\nfunction Aggregate() {\n  this._pipeline = [];\n  this._model = undefined;\n  this.options = undefined;\n\n  if (arguments.length === 1 && util.isArray(arguments[0])) {\n    this.append.apply(this, arguments[0]);\n  } else {\n    this.append.apply(this, arguments);\n  }\n}\n\n/**\n * Binds this aggregate to a model.\n *\n * @param {Model} model the model to which the aggregate is to be bound\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.model = function(model) {\n  this._model = model;\n  return this;\n};\n\n/**\n * Appends new operators to this aggregate pipeline\n *\n * ####Examples:\n *\n *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });\n *\n *     // or pass an array\n *     var pipeline = [{ $match: { daw: 'Logic Audio X' }} ];\n *     aggregate.append(pipeline);\n *\n * @param {Object} ops operator(s) to append\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.append = function() {\n  var args = (arguments.length === 1 && util.isArray(arguments[0]))\n      ? arguments[0]\n      : utils.args(arguments);\n\n  if (!args.every(isOperator)) {\n    throw new Error('Arguments must be aggregate pipeline operators');\n  }\n\n  this._pipeline = this._pipeline.concat(args);\n\n  return this;\n};\n\n/**\n * Appends a new $project operator to this aggregate pipeline.\n *\n * Mongoose query [selection syntax](#query_Query-select) is also supported.\n *\n * ####Examples:\n *\n *     // include a, include b, exclude _id\n *     aggregate.project(\"a b -_id\");\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     aggregate.project({a: 1, b: 1, _id: 0});\n *\n *     // reshaping documents\n *     aggregate.project({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.project({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object|String} arg field specification\n * @see projection http://docs.mongodb.org/manual/reference/aggregation/project/\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.project = function(arg) {\n  var fields = {};\n\n  if (typeof arg === 'object' && !util.isArray(arg)) {\n    Object.keys(arg).forEach(function(field) {\n      fields[field] = arg[field];\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      var include = field[0] === '-' ? 0 : 1;\n      if (include === 0) {\n        field = field.substring(1);\n      }\n      fields[field] = include;\n    });\n  } else {\n    throw new Error('Invalid project() argument. Must be string or object');\n  }\n\n  return this.append({$project: fields});\n};\n\n/**\n * Appends a new custom $group operator to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.group({ _id: \"$department\" });\n *\n * @see $group http://docs.mongodb.org/manual/reference/aggregation/group/\n * @method group\n * @memberOf Aggregate\n * @param {Object} arg $group operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new custom $match operator to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.match({ department: { $in: [ \"sales\", \"engineering\" ] } });\n *\n * @see $match http://docs.mongodb.org/manual/reference/aggregation/match/\n * @method match\n * @memberOf Aggregate\n * @param {Object} arg $match operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $skip operator to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.skip(10);\n *\n * @see $skip http://docs.mongodb.org/manual/reference/aggregation/skip/\n * @method skip\n * @memberOf Aggregate\n * @param {Number} num number of records to skip before next stage\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $limit operator to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.limit(10);\n *\n * @see $limit http://docs.mongodb.org/manual/reference/aggregation/limit/\n * @method limit\n * @memberOf Aggregate\n * @param {Number} num maximum number of records to pass to the next stage\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $geoNear operator to this aggregate pipeline.\n *\n * ####NOTE:\n *\n * **MUST** be used as the first operator in the pipeline.\n *\n * ####Examples:\n *\n *     aggregate.near({\n *       near: [40.724, -73.997],\n *       distanceField: \"dist.calculated\", // required\n *       maxDistance: 0.008,\n *       query: { type: \"public\" },\n *       includeLocs: \"dist.location\",\n *       uniqueDocs: true,\n *       num: 5\n *     });\n *\n * @see $geoNear http://docs.mongodb.org/manual/reference/aggregation/geoNear/\n * @method near\n * @memberOf Aggregate\n * @param {Object} parameters\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.near = function(arg) {\n  var op = {};\n  op.$geoNear = arg;\n  return this.append(op);\n};\n\n/*!\n * define methods\n */\n\n'group match skip limit out'.split(' ').forEach(function($operator) {\n  Aggregate.prototype[$operator] = function(arg) {\n    var op = {};\n    op['$' + $operator] = arg;\n    return this.append(op);\n  };\n});\n\n/**\n * Appends new custom $unwind operator(s) to this aggregate pipeline.\n *\n * Note that the `$unwind` operator requires the path name to start with '$'.\n * Mongoose will prepend '$' if the specified field doesn't start '$'.\n *\n * ####Examples:\n *\n *     aggregate.unwind(\"tags\");\n *     aggregate.unwind(\"a\", \"b\", \"c\");\n *\n * @see $unwind http://docs.mongodb.org/manual/reference/aggregation/unwind/\n * @param {String} fields the field(s) to unwind\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.unwind = function() {\n  var args = utils.args(arguments);\n\n  var res = [];\n  for (var i = 0; i < args.length; ++i) {\n    var arg = args[i];\n    if (arg && typeof arg === 'object') {\n      res.push({ $unwind: arg });\n    } else if (typeof arg === 'string') {\n      res.push({\n        $unwind: (arg && arg.charAt(0) === '$') ? arg : '$' + arg\n      });\n    } else {\n      throw new Error('Invalid arg \"' + arg + '\" to unwind(), ' +\n        'must be string or object');\n    }\n  }\n\n  return this.append.apply(this, res);\n};\n\n/**\n * Appends new custom $lookup operator(s) to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });\n *\n * @see $lookup https://docs.mongodb.org/manual/reference/operator/aggregation/lookup/#pipe._S_lookup\n * @param {Object} options to $lookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.lookup = function(options) {\n  return this.append({$lookup: options});\n};\n\n/**\n * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\n *\n * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.\n *\n * #### Examples:\n *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`\n *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites\n *\n * @see $graphLookup https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup\n * @param {Object} options to $graphLookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.graphLookup = function(options) {\n  var cloneOptions = {};\n  if (options) {\n    if (!utils.isObject(options)) {\n      throw new TypeError('Invalid graphLookup() argument. Must be an object.');\n    }\n\n    utils.mergeClone(cloneOptions, options);\n    var startWith = cloneOptions.startWith;\n\n    if (startWith && typeof startWith === 'string') {\n      cloneOptions.startWith = cloneOptions.startWith.charAt(0) === '$' ?\n        cloneOptions.startWith :\n        '$' + cloneOptions.startWith;\n    }\n\n  }\n  return this.append({ $graphLookup: cloneOptions });\n};\n\n/**\n * Appepnds new custom $sample operator(s) to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.sample(3); // Add a pipeline that picks 3 random documents\n *\n * @see $sample https://docs.mongodb.org/manual/reference/operator/aggregation/sample/#pipe._S_sample\n * @param {Number} size number of random documents to pick\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.sample = function(size) {\n  return this.append({$sample: {size: size}});\n};\n\n/**\n * Appends a new $sort operator to this aggregate pipeline.\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * ####Examples:\n *\n *     // these are equivalent\n *     aggregate.sort({ field: 'asc', test: -1 });\n *     aggregate.sort('field -test');\n *\n * @see $sort http://docs.mongodb.org/manual/reference/aggregation/sort/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sort = function(arg) {\n  // TODO refactor to reuse the query builder logic\n\n  var sort = {};\n\n  if (arg.constructor.name === 'Object') {\n    var desc = ['desc', 'descending', -1];\n    Object.keys(arg).forEach(function(field) {\n      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      var ascend = field[0] === '-' ? -1 : 1;\n      if (ascend === -1) {\n        field = field.substring(1);\n      }\n      sort[field] = ascend;\n    });\n  } else {\n    throw new TypeError('Invalid sort() argument. Must be a string or object.');\n  }\n\n  return this.append({$sort: sort});\n};\n\n/**\n * Sets the readPreference option for the aggregation query.\n *\n * ####Example:\n *\n *     Model.aggregate(..).read('primaryPreferred').exec(callback)\n *\n * @param {String} pref one of the listed preference options or their aliases\n * @param {Array} [tags] optional tags for this query\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n */\n\nAggregate.prototype.read = function(pref, tags) {\n  if (!this.options) {\n    this.options = {};\n  }\n  read.call(this, pref, tags);\n  return this;\n};\n\n/**\n * Execute the aggregation with explain\n *\n * ####Example:\n *\n *     Model.aggregate(..).explain(callback)\n *\n * @param {Function} callback\n * @return {Promise}\n */\n\nAggregate.prototype.explain = function(callback) {\n  var _this = this;\n  var Promise = PromiseProvider.get();\n  return new Promise.ES6(function(resolve, reject) {\n    if (!_this._pipeline.length) {\n      var err = new Error('Aggregate has empty pipeline');\n      if (callback) {\n        callback(err);\n      }\n      reject(err);\n      return;\n    }\n\n    prepareDiscriminatorPipeline(_this);\n\n    _this._model\n        .collection\n        .aggregate(_this._pipeline, _this.options || {})\n        .explain(function(error, result) {\n          if (error) {\n            if (callback) {\n              callback(error);\n            }\n            reject(error);\n            return;\n          }\n\n          if (callback) {\n            callback(null, result);\n          }\n          resolve(result);\n        });\n  });\n};\n\n/**\n * Sets the allowDiskUse option for the aggregation query (ignored for < 2.6.0)\n *\n * ####Example:\n *\n *     Model.aggregate(..).allowDiskUse(true).exec(callback)\n *\n * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.\n * @param {Array} [tags] optional tags for this query\n * @see mongodb http://docs.mongodb.org/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.allowDiskUse = function(value) {\n  if (!this.options) {\n    this.options = {};\n  }\n  this.options.allowDiskUse = value;\n  return this;\n};\n\n/**\n * Sets the cursor option option for the aggregation query (ignored for < 2.6.0).\n * Note the different syntax below: .exec() returns a cursor object, and no callback\n * is necessary.\n *\n * ####Example:\n *\n *     var cursor = Model.aggregate(..).cursor({ batchSize: 1000 }).exec();\n *     cursor.each(function(error, doc) {\n *       // use doc\n *     });\n *\n * @param {Object} options set the cursor batch size\n * @see mongodb http://mongodb.github.io/node-mongodb-native/2.0/api/AggregationCursor.html\n */\n\nAggregate.prototype.cursor = function(options) {\n  if (!this.options) {\n    this.options = {};\n  }\n  this.options.cursor = options || {};\n  return this;\n};\n\n/**\n * Adds a [cursor flag](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#addCursorFlag)\n *\n * ####Example:\n *\n *     Model.aggregate(..).addCursorFlag('noCursorTimeout', true).exec();\n *\n * @param {String} flag\n * @param {Boolean} value\n * @see mongodb http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#addCursorFlag\n */\n\nAggregate.prototype.addCursorFlag = function(flag, value) {\n  if (!this.options) {\n    this.options = {};\n  }\n  this.options[flag] = value;\n  return this;\n};\n\n/**\n * Adds a collation\n *\n * ####Example:\n *\n *     Model.aggregate(..).collation({ locale: 'en_US', strength: 1 }).exec();\n *\n * @param {Object} collation options\n * @param {Boolean} value\n * @see mongodb http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#aggregate\n */\n\nAggregate.prototype.collation = function(collation) {\n  if (!this.options) {\n    this.options = {};\n  }\n  this.options.collation = collation;\n  return this;\n};\n\n/**\n * Combines multiple aggregation pipelines.\n *\n * ####Example:\n *     Model.aggregate(...)\n *      .facet({\n *        books: [{ groupBy: '$author' }],\n *        price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]\n *      })\n *      .exec();\n *\n *     // Output: { books: [...], price: [{...}, {...}] }\n *\n * @param {Object} facet options\n * @return {Aggregate} this\n * @see $facet https://docs.mongodb.com/v3.4/reference/operator/aggregation/facet/\n * @api public\n */\n\nAggregate.prototype.facet = function(options) {\n  return this.append({$facet: options});\n};\n\n/**\n * Executes the aggregate pipeline on the currently bound Model.\n *\n * ####Example:\n *\n *     aggregate.exec(callback);\n *\n *     // Because a promise is returned, the `callback` is optional.\n *     var promise = aggregate.exec();\n *     promise.then(..);\n *\n * @see Promise #promise_Promise\n * @param {Function} [callback]\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.exec = function(callback) {\n  if (!this._model) {\n    throw new Error('Aggregate not bound to any Model');\n  }\n  var _this = this;\n  var Promise = PromiseProvider.get();\n  var options = utils.clone(this.options);\n\n  if (options && options.cursor) {\n    if (options.cursor.async) {\n      delete options.cursor.async;\n      return new Promise.ES6(function(resolve) {\n        if (!_this._model.collection.buffer) {\n          process.nextTick(function() {\n            var cursor = _this._model.collection.\n              aggregate(_this._pipeline, options || {});\n            decorateCursor(cursor);\n            resolve(cursor);\n            callback && callback(null, cursor);\n          });\n          return;\n        }\n        _this._model.collection.emitter.once('queue', function() {\n          var cursor = _this._model.collection.\n            aggregate(_this._pipeline, options || {});\n          decorateCursor(cursor);\n          resolve(cursor);\n          callback && callback(null, cursor);\n        });\n      });\n    }\n    var cursor = this._model.collection.\n      aggregate(this._pipeline, this.options || {});\n    decorateCursor(cursor);\n    return cursor;\n  }\n\n  return new Promise.ES6(function(resolve, reject) {\n    if (!_this._pipeline.length) {\n      var err = new Error('Aggregate has empty pipeline');\n      if (callback) {\n        callback(err);\n      }\n      reject(err);\n      return;\n    }\n\n    prepareDiscriminatorPipeline(_this);\n\n    _this._model\n        .collection\n        .aggregate(_this._pipeline, _this.options || {}, function(error, result) {\n          if (error) {\n            if (callback) {\n              callback(error);\n            }\n            reject(error);\n            return;\n          }\n\n          if (callback) {\n            callback(null, result);\n          }\n          resolve(result);\n        });\n  });\n};\n\n/*!\n * Add `eachAsync()` to aggregation cursors\n */\n\nfunction decorateCursor(cursor) {\n  cursor.eachAsync = function(fn, callback) {\n    var Promise = PromiseProvider.get();\n\n    var handleNextResult = function(doc, callback) {\n      var promise = fn(doc);\n      if (promise && typeof promise.then === 'function') {\n        promise.then(\n          function() { callback(null); },\n          function(error) { callback(error); });\n      } else {\n        callback(null);\n      }\n    };\n\n    var iterate = function(callback) {\n      return cursor.next(function(error, doc) {\n        if (error) {\n          return callback(error);\n        }\n        if (!doc) {\n          return callback(null);\n        }\n        handleNextResult(doc, function(error) {\n          if (error) {\n            return callback(error);\n          }\n          setTimeout(function() {\n            iterate(callback);\n          }, 0);\n        });\n      });\n    };\n\n    return new Promise.ES6(function(resolve, reject) {\n      iterate(function(error) {\n        if (error) {\n          callback && callback(error);\n          return reject(error);\n        }\n        callback && callback(null);\n        return resolve();\n      });\n    });\n  };\n}\n\n/**\n * Provides promise for aggregate.\n *\n * ####Example:\n *\n *     Model.aggregate(..).then(successCallback, errorCallback);\n *\n * @see Promise #promise_Promise\n * @param {Function} [resolve] successCallback\n * @param {Function} [reject]  errorCallback\n * @return {Promise}\n */\nAggregate.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/*!\n * Helpers\n */\n\n/**\n * Checks whether an object is likely a pipeline operator\n *\n * @param {Object} obj object to check\n * @return {Boolean}\n * @api private\n */\n\nfunction isOperator(obj) {\n  var k;\n\n  if (typeof obj !== 'object') {\n    return false;\n  }\n\n  k = Object.keys(obj);\n\n  return k.length === 1 && k\n          .some(function(key) {\n            return key[0] === '$';\n          });\n}\n\n/*!\n * Adds the appropriate `$match` pipeline step to the top of an aggregate's\n * pipeline, should it's model is a non-root discriminator type. This is\n * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.\n *\n * @param {Aggregate} aggregate Aggregate to prepare\n */\n\nfunction prepareDiscriminatorPipeline(aggregate) {\n  var schema = aggregate._model.schema,\n      discriminatorMapping = schema && schema.discriminatorMapping;\n\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\n    var originalPipeline = aggregate._pipeline,\n        discriminatorKey = discriminatorMapping.key,\n        discriminatorValue = discriminatorMapping.value;\n\n    // If the first pipeline stage is a match and it doesn't specify a `__t`\n    // key, add the discriminator key to it. This allows for potential\n    // aggregation query optimizations not to be disturbed by this feature.\n    if (originalPipeline[0] && originalPipeline[0].$match && !originalPipeline[0].$match[discriminatorKey]) {\n      originalPipeline[0].$match[discriminatorKey] = discriminatorValue;\n      // `originalPipeline` is a ref, so there's no need for\n      // aggregate._pipeline = originalPipeline\n    } else if (originalPipeline[0] && originalPipeline[0].$geoNear) {\n      originalPipeline[0].$geoNear.query =\n          originalPipeline[0].$geoNear.query || {};\n      originalPipeline[0].$geoNear.query[discriminatorKey] = discriminatorValue;\n    } else {\n      var match = {};\n      match[discriminatorKey] = discriminatorValue;\n      aggregate._pipeline = [{$match: match}].concat(originalPipeline);\n    }\n  }\n}\n\n\n/*!\n * Exports\n */\n\nmodule.exports = Aggregate;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/services/model/applyMethods.js":"'use strict';\n\n/*!\n * Register methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nmodule.exports = function applyMethods(model, schema) {\n  function apply(method, schema) {\n    Object.defineProperty(model.prototype, method, {\n      get: function() {\n        var h = {};\n        for (var k in schema.methods[method]) {\n          h[k] = schema.methods[method][k].bind(this);\n        }\n        return h;\n      },\n      configurable: true\n    });\n  }\n  for (var method in schema.methods) {\n    if (schema.tree.hasOwnProperty(method)) {\n      throw new Error('You have a method and a property in your schema both ' +\n        'named \"' + method + '\"');\n    }\n    if (typeof schema.methods[method] === 'function') {\n      model.prototype[method] = schema.methods[method];\n    } else {\n      apply(method, schema);\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/services/model/applyStatics.js":"'use strict';\n\n/*!\n * Register statics for this model\n * @param {Model} model\n * @param {Schema} schema\n */\nmodule.exports = function applyStatics(model, schema) {\n  for (var i in schema.statics) {\n    model[i] = schema.statics[i];\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/services/projection/isPathSelectedInclusive.js":"'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function isPathSelectedInclusive(fields, path) {\n  var chunks = path.split('.');\n  var cur = '';\n  var j;\n  var keys;\n  var numKeys;\n  for (var i = 0; i < chunks.length; ++i) {\n    cur += cur.length ? '.' : '' + chunks[i];\n    if (fields[cur]) {\n      keys = Object.keys(fields);\n      numKeys = keys.length;\n      for (j = 0; j < numKeys; ++j) {\n        if (keys[i].indexOf(cur + '.') === 0 && keys[i].indexOf(path) !== 0) {\n          continue;\n        }\n      }\n      return true;\n    }\n  }\n\n  return false;\n};\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/drivers/node-mongodb-native/connection.js":"/*!\n * Module dependencies.\n */\n\nvar MongooseConnection = require('../../connection');\nvar mongo = require('mongodb');\nvar Db = mongo.Db;\nvar Server = mongo.Server;\nvar Mongos = mongo.Mongos;\nvar STATES = require('../../connectionstate');\nvar ReplSetServers = mongo.ReplSet;\nvar DisconnectedError = require('../../error/disconnected');\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nNativeConnection.prototype.__proto__ = MongooseConnection.prototype;\n\n/**\n * Opens the connection to MongoDB.\n *\n * @param {Function} fn\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doOpen = function(fn) {\n  var _this = this;\n  var server = new Server(this.host, this.port, this.options.server);\n\n  if (this.options && this.options.mongos) {\n    var mongos = new Mongos([server], this.options.mongos);\n    this.db = new Db(this.name, mongos, this.options.db);\n  } else {\n    this.db = new Db(this.name, server, this.options.db);\n  }\n\n  this.db.open(function(err) {\n    listen(_this);\n\n    if (!mongos) {\n      server.s.server.on('error', function(error) {\n        if (/after \\d+ attempts/.test(error.message)) {\n          _this.emit('error', new DisconnectedError(server.s.server.name));\n        }\n      });\n    }\n\n    if (err) return fn(err);\n\n    fn();\n  });\n\n  return this;\n};\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db.\n *\n * @param {String} name The database name\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function(name) {\n  // we have to manually copy all of the attributes...\n  var newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.hosts = this.hosts;\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  var _this = this;\n\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this.once('connected', wireup);\n  }\n\n  function wireup() {\n    newConn.db = _this.db.db(name);\n    newConn.onOpen();\n    // setup the events appropriately\n    listen(newConn);\n  }\n\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  this.otherDbs.push(newConn);\n  newConn.otherDbs.push(this);\n\n  return newConn;\n};\n\n/*!\n * Register listeners for important events and bubble appropriately.\n */\n\nfunction listen(conn) {\n  if (conn.db._listening) {\n    return;\n  }\n  conn.db._listening = true;\n\n  conn.db.on('close', function() {\n    if (conn._closeCalled) return;\n\n    // the driver never emits an `open` event. auto_reconnect still\n    // emits a `close` event but since we never get another\n    // `open` we can't emit close\n    if (conn.db.serverConfig.autoReconnect) {\n      conn.readyState = STATES.disconnected;\n      conn.emit('close');\n      return;\n    }\n    conn.onClose();\n  });\n  conn.db.on('error', function(err) {\n    conn.emit('error', err);\n  });\n  conn.db.on('reconnect', function() {\n    conn.readyState = STATES.connected;\n    conn.emit('reconnected');\n    conn.onOpen();\n  });\n  conn.db.on('timeout', function(err) {\n    conn.emit('timeout', err);\n  });\n  conn.db.on('open', function(err, db) {\n    if (STATES.disconnected === conn.readyState && db && db.databaseName) {\n      conn.readyState = STATES.connected;\n      conn.emit('reconnected');\n    }\n  });\n  conn.db.on('parseError', function(err) {\n    conn.emit('parseError', err);\n  });\n}\n\n/**\n * Opens a connection to a MongoDB ReplicaSet.\n *\n * See description of [doOpen](#NativeConnection-doOpen) for server options. In this case `options.replset` is also passed to ReplSetServers.\n *\n * @param {Function} fn\n * @api private\n * @return {Connection} this\n */\n\nNativeConnection.prototype.doOpenSet = function(fn) {\n  var servers = [],\n      _this = this;\n\n  this.hosts.forEach(function(server) {\n    var host = server.host || server.ipc;\n    var port = server.port || 27017;\n    servers.push(new Server(host, port, _this.options.server));\n  });\n\n  var server = this.options.mongos\n    ? new Mongos(servers, this.options.mongos)\n    : new ReplSetServers(servers, this.options.replset || this.options.replSet);\n  this.db = new Db(this.name, server, this.options.db);\n\n  this.db.on('fullsetup', function() {\n    _this.emit('fullsetup');\n  });\n\n  this.db.on('all', function() {\n    _this.emit('all');\n  });\n\n  this.db.open(function(err) {\n    if (err) return fn(err);\n    fn();\n    listen(_this);\n  });\n\n  return this;\n};\n\n/**\n * Closes the connection\n *\n * @param {Function} fn\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = function(fn) {\n  this.db.close(fn);\n  return this;\n};\n\n/**\n * Prepares default connection options for the node-mongodb-native driver.\n *\n * _NOTE: `passed` options take precedence over connection string options._\n *\n * @param {Object} passed options that were passed directly during connection\n * @param {Object} [connStrOptions] options that were passed in the connection string\n * @api private\n */\n\nNativeConnection.prototype.parseOptions = function(passed, connStrOpts) {\n  var o = passed || {};\n  o.db || (o.db = {});\n  o.auth || (o.auth = {});\n  o.server || (o.server = {});\n  o.replset || (o.replset = o.replSet) || (o.replset = {});\n  o.server.socketOptions || (o.server.socketOptions = {});\n  o.replset.socketOptions || (o.replset.socketOptions = {});\n  o.mongos || (o.mongos = (connStrOpts && connStrOpts.mongos));\n  (o.mongos === true) && (o.mongos = {});\n\n  var opts = connStrOpts || {};\n  Object.keys(opts).forEach(function(name) {\n    switch (name) {\n      case 'ssl':\n        o.server.ssl = opts.ssl;\n        o.replset.ssl = opts.ssl;\n        o.mongos && (o.mongos.ssl = opts.ssl);\n        break;\n      case 'poolSize':\n        if (typeof o.server[name] === 'undefined') {\n          o.server[name] = o.replset[name] = opts[name];\n        }\n        break;\n      case 'slaveOk':\n        if (typeof o.server.slave_ok === 'undefined') {\n          o.server.slave_ok = opts[name];\n        }\n        break;\n      case 'autoReconnect':\n        if (typeof o.server.auto_reconnect === 'undefined') {\n          o.server.auto_reconnect = opts[name];\n        }\n        break;\n      case 'socketTimeoutMS':\n      case 'connectTimeoutMS':\n        if (typeof o.server.socketOptions[name] === 'undefined') {\n          o.server.socketOptions[name] = o.replset.socketOptions[name] = opts[name];\n        }\n        break;\n      case 'authdb':\n        if (typeof o.auth.authdb === 'undefined') {\n          o.auth.authdb = opts[name];\n        }\n        break;\n      case 'authSource':\n        if (typeof o.auth.authSource === 'undefined') {\n          o.auth.authSource = opts[name];\n        }\n        break;\n      case 'authMechanism':\n        if (typeof o.auth.authMechanism === 'undefined') {\n          o.auth.authMechanism = opts[name];\n        }\n        break;\n      case 'retries':\n      case 'reconnectWait':\n      case 'rs_name':\n        if (typeof o.replset[name] === 'undefined') {\n          o.replset[name] = opts[name];\n        }\n        break;\n      case 'replicaSet':\n        if (typeof o.replset.rs_name === 'undefined') {\n          o.replset.rs_name = opts[name];\n        }\n        break;\n      case 'readSecondary':\n        if (typeof o.replset.read_secondary === 'undefined') {\n          o.replset.read_secondary = opts[name];\n        }\n        break;\n      case 'nativeParser':\n        if (typeof o.db.native_parser === 'undefined') {\n          o.db.native_parser = opts[name];\n        }\n        break;\n      case 'w':\n      case 'safe':\n      case 'fsync':\n      case 'journal':\n      case 'wtimeoutMS':\n        if (typeof o.db[name] === 'undefined') {\n          o.db[name] = opts[name];\n        }\n        break;\n      case 'readPreference':\n        if (typeof o.db.readPreference === 'undefined') {\n          o.db.readPreference = opts[name];\n        }\n        break;\n      case 'readPreferenceTags':\n        if (typeof o.db.read_preference_tags === 'undefined') {\n          o.db.read_preference_tags = opts[name];\n        }\n        break;\n      case 'sslValidate':\n        o.server.sslValidate = opts.sslValidate;\n        o.replset.sslValidate = opts.sslValidate;\n        o.mongos && (o.mongos.sslValidate = opts.sslValidate);\n    }\n  });\n\n  if (!('auto_reconnect' in o.server)) {\n    o.server.auto_reconnect = true;\n  }\n\n  // mongoose creates its own ObjectIds\n  o.db.forceServerObjectId = false;\n\n  // default safe using new nomenclature\n  if (!('journal' in o.db || 'j' in o.db ||\n        'fsync' in o.db || 'safe' in o.db || 'w' in o.db)) {\n    o.db.w = 1;\n  }\n\n  if (o.promiseLibrary) {\n    o.db.promiseLibrary = o.promiseLibrary;\n  }\n\n  validate(o);\n  return o;\n};\n\n/*!\n * Validates the driver db options.\n *\n * @param {Object} o\n */\n\nfunction validate(o) {\n  if (o.db.w === -1 || o.db.w === 0) {\n    if (o.db.journal || o.db.fsync || o.db.safe) {\n      throw new Error(\n          'Invalid writeConcern: '\n        + 'w set to -1 or 0 cannot be combined with safe|fsync|journal');\n    }\n  }\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/connection.js":"/*!\n * Module dependencies.\n */\n\nvar utils = require('./utils');\nvar EventEmitter = require('events').EventEmitter;\nvar driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';\nvar Schema = require('./schema');\nvar Collection = require(driver + '/collection');\nvar STATES = require('./connectionstate');\nvar MongooseError = require('./error');\nvar muri = require('muri');\nvar PromiseProvider = require('./promise_provider');\n\n/*!\n * Protocol prefix regexp.\n *\n * @api private\n */\n\nvar rgxProtocol = /^(?:.)+:\\/\\//;\n\n/*!\n * A list of authentication mechanisms that don't require a password for authentication.\n * This is used by the authMechanismDoesNotRequirePassword method.\n *\n * @api private\n */\nvar authMechanismsWhichDontRequirePassword = [\n  'MONGODB-X509'\n];\n\n/**\n * Connection constructor\n *\n * For practical reasons, a Connection equals a Db.\n *\n * @param {Mongoose} base a mongoose instance\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `connecting`: Emitted when `connection.{open,openSet}()` is executed on this connection.\n * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.\n * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connections models.\n * @event `disconnecting`: Emitted when `connection.close()` was executed.\n * @event `disconnected`: Emitted after getting disconnected from the db.\n * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connections models.\n * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successfull connection.\n * @event `error`: Emitted when an error occurs on this connection.\n * @event `fullsetup`: Emitted in a replica-set scenario, when primary and at least one seconaries specified in the connection string are connected.\n * @event `all`: Emitted in a replica-set scenario, when all nodes specified in the connection string are connected.\n * @api public\n */\n\nfunction Connection(base) {\n  this.base = base;\n  this.collections = {};\n  this.models = {};\n  this.config = {autoIndex: true};\n  this.replica = false;\n  this.hosts = null;\n  this.host = null;\n  this.port = null;\n  this.user = null;\n  this.pass = null;\n  this.name = null;\n  this.options = null;\n  this.otherDbs = [];\n  this._readyState = STATES.disconnected;\n  this._closeCalled = false;\n  this._hasOpened = false;\n}\n\n/*!\n * Inherit from EventEmitter\n */\n\nConnection.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Connection ready state\n *\n * - 0 = disconnected\n * - 1 = connected\n * - 2 = connecting\n * - 3 = disconnecting\n *\n * Each state change emits its associated event name.\n *\n * ####Example\n *\n *     conn.on('connected', callback);\n *     conn.on('disconnected', callback);\n *\n * @property readyState\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'readyState', {\n  get: function() {\n    return this._readyState;\n  },\n  set: function(val) {\n    if (!(val in STATES)) {\n      throw new Error('Invalid connection state: ' + val);\n    }\n\n    if (this._readyState !== val) {\n      this._readyState = val;\n      // loop over the otherDbs on this connection and change their state\n      for (var i = 0; i < this.otherDbs.length; i++) {\n        this.otherDbs[i].readyState = val;\n      }\n\n      if (STATES.connected === val) {\n        this._hasOpened = true;\n      }\n\n      this.emit(STATES[val]);\n    }\n  }\n});\n\n/**\n * A hash of the collections associated with this connection\n *\n * @property collections\n */\n\nConnection.prototype.collections;\n\n/**\n * The mongodb.Db instance, set when the connection is opened\n *\n * @property db\n */\n\nConnection.prototype.db;\n\n/**\n * A hash of the global options that are associated with this connection\n *\n * @property config\n */\n\nConnection.prototype.config;\n\n/**\n * Opens the connection to MongoDB.\n *\n * `options` is a hash with the following possible properties:\n *\n *     config  - passed to the connection config instance\n *     db      - passed to the connection db instance\n *     server  - passed to the connection server instance(s)\n *     replset - passed to the connection ReplSet instance\n *     user    - username for authentication\n *     pass    - password for authentication\n *     auth    - options for authentication (see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate)\n *\n * ####Notes:\n *\n * Mongoose forces the db option `forceServerObjectId` false and cannot be overridden.\n * Mongoose defaults the server `auto_reconnect` options to true which can be overridden.\n * See the node-mongodb-native driver instance for options that it understands.\n *\n * _Options passed take precedence over options included in connection strings._\n *\n * @param {String} connection_string mongodb://uri or the host to which you are connecting\n * @param {String} [database] database name\n * @param {Number} [port] database port\n * @param {Object} [options] options\n * @param {Function} [callback]\n * @see node-mongodb-native https://github.com/mongodb/node-mongodb-native\n * @see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate\n * @api public\n */\n\nConnection.prototype.open = function(host, database, port, options, callback) {\n  var parsed;\n  var Promise = PromiseProvider.get();\n  var err;\n\n  if (typeof database === 'string') {\n    switch (arguments.length) {\n      case 2:\n        port = 27017;\n        break;\n      case 3:\n        switch (typeof port) {\n          case 'function':\n            callback = port;\n            port = 27017;\n            break;\n          case 'object':\n            options = port;\n            port = 27017;\n            break;\n        }\n        break;\n      case 4:\n        if (typeof options === 'function') {\n          callback = options;\n          options = {};\n        }\n    }\n  } else {\n    switch (typeof database) {\n      case 'function':\n        callback = database;\n        database = undefined;\n        break;\n      case 'object':\n        options = database;\n        database = undefined;\n        callback = port;\n        break;\n    }\n\n    if (!rgxProtocol.test(host)) {\n      host = 'mongodb://' + host;\n    }\n\n    try {\n      parsed = muri(host);\n    } catch (err) {\n      this.error(err, callback);\n      return new Promise.ES6(function(resolve, reject) {\n        reject(err);\n      });\n    }\n\n    database = parsed.db;\n    host = parsed.hosts[0].host || parsed.hosts[0].ipc;\n    port = parsed.hosts[0].port || 27017;\n  }\n\n  this.options = this.parseOptions(options, parsed && parsed.options);\n\n  // make sure we can open\n  if (STATES.disconnected !== this.readyState) {\n    err = new Error('Trying to open unclosed connection.');\n    err.state = this.readyState;\n    this.error(err, callback);\n    return new Promise.ES6(function(resolve, reject) {\n      reject(err);\n    });\n  }\n\n  if (!host) {\n    err = new Error('Missing hostname.');\n    this.error(err, callback);\n    return new Promise.ES6(function(resolve, reject) {\n      reject(err);\n    });\n  }\n\n  if (!database) {\n    err = new Error('Missing database name.');\n    this.error(err, callback);\n    return new Promise.ES6(function(resolve, reject) {\n      reject(err);\n    });\n  }\n\n  // authentication\n  if (this.optionsProvideAuthenticationData(options)) {\n    this.user = options.user;\n    this.pass = options.pass;\n  } else if (parsed && parsed.auth) {\n    this.user = parsed.auth.user;\n    this.pass = parsed.auth.pass;\n\n    // Check hostname for user/pass\n  } else if (/@/.test(host) && /:/.test(host.split('@')[0])) {\n    host = host.split('@');\n    if (host.length > 2) {\n      err = new Error('Username and password must be URI encoded if they ' +\n        'contain \"@\", see http://bit.ly/2nRYRyq');\n      this.error(err, callback);\n      return new Promise.ES6(function(resolve, reject) {\n        reject(err);\n      });\n    }\n    var auth = host.shift().split(':');\n    if (auth.length > 2) {\n      err = new Error('Username and password must be URI encoded if they ' +\n        'contain \":\", see http://bit.ly/2nRYRyq');\n      this.error(err, callback);\n      return new Promise.ES6(function(resolve, reject) {\n        reject(err);\n      });\n    }\n    host = host.pop();\n    this.user = auth[0];\n    this.pass = auth[1];\n  } else {\n    this.user = this.pass = undefined;\n  }\n\n  // global configuration options\n  if (options && options.config) {\n    this.config.autoIndex = options.config.autoIndex !== false;\n  }\n\n  this.name = database;\n  this.host = host;\n  this.port = port;\n\n  var _this = this;\n  var promise = new Promise.ES6(function(resolve, reject) {\n    _this._open(true, function(error) {\n      callback && callback(error);\n      if (error) {\n        // Error can be on same tick re: christkv/mongodb-core#157\n        setImmediate(function() {\n          reject(error);\n          if (!callback && !promise.$hasHandler) {\n            _this.emit('error', error);\n          }\n        });\n        return;\n      }\n      resolve();\n    });\n  });\n  return promise;\n};\n\n/**\n * Helper for `dropDatabase()`.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropDatabase = function(callback) {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  var promise = new Promise.ES6(function(resolve, reject) {\n    if (_this.readyState !== STATES.connected) {\n      _this.on('open', function() {\n        _this.db.dropDatabase(function(error) {\n          if (error) {\n            reject(error);\n          } else {\n            resolve();\n          }\n        });\n      });\n    } else {\n      _this.db.dropDatabase(function(error) {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    }\n  });\n  if (callback) {\n    promise.then(function() { callback(); }, callback);\n  }\n  return promise;\n};\n\n/**\n * Opens the connection to a replica set.\n *\n * ####Example:\n *\n *     var db = mongoose.createConnection();\n *     db.openSet(\"mongodb://user:pwd@localhost:27020,localhost:27021,localhost:27012/mydb\");\n *\n * The database name and/or auth need only be included in one URI.\n * The `options` is a hash which is passed to the internal driver connection object.\n *\n * Valid `options`\n *\n *     db      - passed to the connection db instance\n *     server  - passed to the connection server instance(s)\n *     replset - passed to the connection ReplSetServer instance\n *     user    - username for authentication\n *     pass    - password for authentication\n *     auth    - options for authentication (see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate)\n *     mongos  - Boolean - if true, enables High Availability support for mongos\n *\n * _Options passed take precedence over options included in connection strings._\n *\n * ####Notes:\n *\n * _If connecting to multiple mongos servers, set the `mongos` option to true._\n *\n *     conn.open('mongodb://mongosA:27501,mongosB:27501', { mongos: true }, cb);\n *\n * Mongoose forces the db option `forceServerObjectId` false and cannot be overridden.\n * Mongoose defaults the server `auto_reconnect` options to true which can be overridden.\n * See the node-mongodb-native driver instance for options that it understands.\n *\n * _Options passed take precedence over options included in connection strings._\n *\n * @param {String} uris MongoDB connection string\n * @param {String} [database] database name if not included in `uris`\n * @param {Object} [options] passed to the internal driver\n * @param {Function} [callback]\n * @see node-mongodb-native https://github.com/mongodb/node-mongodb-native\n * @see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate\n * @api public\n */\n\nConnection.prototype.openSet = function(uris, database, options, callback) {\n  if (!rgxProtocol.test(uris)) {\n    uris = 'mongodb://' + uris;\n  }\n\n  var Promise = PromiseProvider.get();\n\n  switch (arguments.length) {\n    case 3:\n      switch (typeof database) {\n        case 'string':\n          this.name = database;\n          break;\n        case 'object':\n          callback = options;\n          options = database;\n          database = null;\n          break;\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      break;\n    case 2:\n      switch (typeof database) {\n        case 'string':\n          this.name = database;\n          break;\n        case 'function':\n          callback = database;\n          database = null;\n          break;\n        case 'object':\n          options = database;\n          database = null;\n          break;\n      }\n  }\n\n  if (typeof database === 'string') {\n    this.name = database;\n  }\n\n  var parsed;\n  try {\n    parsed = muri(uris);\n  } catch (err) {\n    this.error(err, callback);\n    return new Promise.ES6(function(resolve, reject) {\n      reject(err);\n    });\n  }\n\n  if (!this.name) {\n    this.name = parsed.db;\n  }\n\n  this.hosts = parsed.hosts;\n  this.options = this.parseOptions(options, parsed && parsed.options);\n  this.replica = true;\n\n  if (!this.name) {\n    var err = new Error('No database name provided for replica set');\n    this.error(err, callback);\n    return new Promise.ES6(function(resolve, reject) {\n      reject(err);\n    });\n  }\n\n  // authentication\n  if (this.optionsProvideAuthenticationData(options)) {\n    this.user = options.user;\n    this.pass = options.pass;\n  } else if (parsed && parsed.auth) {\n    this.user = parsed.auth.user;\n    this.pass = parsed.auth.pass;\n  } else {\n    this.user = this.pass = undefined;\n  }\n\n  // global configuration options\n  if (options && options.config) {\n    this.config.autoIndex = options.config.autoIndex !== false;\n  }\n\n  var _this = this;\n  var emitted = false;\n  var promise = new Promise.ES6(function(resolve, reject) {\n    _this._open(true, function(error) {\n      callback && callback(error);\n      if (error) {\n        reject(error);\n        if (!callback && !promise.$hasHandler && !emitted) {\n          emitted = true;\n          _this.emit('error', error);\n        }\n        return;\n      }\n      resolve();\n    });\n  });\n  return promise;\n};\n\n/**\n * error\n *\n * Graceful error handling, passes error to callback\n * if available, else emits error on the connection.\n *\n * @param {Error} err\n * @param {Function} callback optional\n * @api private\n */\n\nConnection.prototype.error = function(err, callback) {\n  if (callback) {\n    return callback(err);\n  }\n  this.emit('error', err);\n};\n\n/**\n * Handles opening the connection with the appropriate method based on connection type.\n *\n * @param {Function} callback\n * @api private\n */\n\nConnection.prototype._open = function(emit, callback) {\n  this.readyState = STATES.connecting;\n  this._closeCalled = false;\n\n  var _this = this;\n\n  var method = this.replica\n      ? 'doOpenSet'\n      : 'doOpen';\n\n  // open connection\n  this[method](function(err) {\n    if (err) {\n      _this.readyState = STATES.disconnected;\n      if (_this._hasOpened) {\n        if (callback) {\n          callback(err);\n        }\n      } else {\n        _this.error(err, emit && callback);\n      }\n      return;\n    }\n\n    _this.onOpen(callback);\n  });\n};\n\n/**\n * Called when the connection is opened\n *\n * @api private\n */\n\nConnection.prototype.onOpen = function(callback) {\n  var _this = this;\n\n  function open(err, isAuth) {\n    if (err) {\n      _this.readyState = isAuth ? STATES.unauthorized : STATES.disconnected;\n      _this.error(err, callback);\n      return;\n    }\n\n    _this.readyState = STATES.connected;\n\n    // avoid having the collection subscribe to our event emitter\n    // to prevent 0.3 warning\n    for (var i in _this.collections) {\n      if (utils.object.hasOwnProperty(_this.collections, i)) {\n        _this.collections[i].onOpen();\n      }\n    }\n\n    callback && callback();\n    _this.emit('open');\n  }\n\n  // re-authenticate if we're not already connected #3871\n  if (this._readyState !== STATES.connected && this.shouldAuthenticate()) {\n    _this.db.authenticate(_this.user, _this.pass, _this.options.auth, function(err) {\n      open(err, true);\n    });\n  } else {\n    open();\n  }\n};\n\n/**\n * Closes the connection\n *\n * @param {Function} [callback] optional\n * @return {Connection} self\n * @api public\n */\n\nConnection.prototype.close = function(callback) {\n  var _this = this;\n  var Promise = PromiseProvider.get();\n  return new Promise.ES6(function(resolve, reject) {\n    _this._close(function(error) {\n      callback && callback(error);\n      if (error) {\n        reject(error);\n        return;\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Handles closing the connection\n *\n * @param {Function} callback\n * @api private\n */\nConnection.prototype._close = function(callback) {\n  var _this = this;\n  this._closeCalled = true;\n\n  switch (this.readyState) {\n    case 0: // disconnected\n      callback && callback();\n      break;\n\n    case 1: // connected\n    case 4: // unauthorized\n      this.readyState = STATES.disconnecting;\n      this.doClose(function(err) {\n        if (err) {\n          _this.error(err, callback);\n        } else {\n          _this.onClose();\n          callback && callback();\n        }\n      });\n      break;\n\n    case 2: // connecting\n      this.once('open', function() {\n        _this.close(callback);\n      });\n      break;\n\n    case 3: // disconnecting\n      if (!callback) {\n        break;\n      }\n      this.once('close', function() {\n        callback();\n      });\n      break;\n  }\n\n  return this;\n};\n\n/**\n * Called when the connection closes\n *\n * @api private\n */\n\nConnection.prototype.onClose = function() {\n  this.readyState = STATES.disconnected;\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (var i in this.collections) {\n    if (utils.object.hasOwnProperty(this.collections, i)) {\n      this.collections[i].onClose();\n    }\n  }\n\n  this.emit('close');\n};\n\n/**\n * Retrieves a collection, creating it if not cached.\n *\n * Not typically needed by applications. Just talk to your collection through your model.\n *\n * @param {String} name of the collection\n * @param {Object} [options] optional collection options\n * @return {Collection} collection instance\n * @api public\n */\n\nConnection.prototype.collection = function(name, options) {\n  if (!(name in this.collections)) {\n    this.collections[name] = new Collection(name, this, options);\n  }\n  return this.collections[name];\n};\n\n/**\n * Defines or retrieves a model.\n *\n *     var mongoose = require('mongoose');\n *     var db = mongoose.createConnection(..);\n *     db.model('Venue', new Schema(..));\n *     var Ticket = db.model('Ticket', new Schema(..));\n *     var Venue = db.model('Venue');\n *\n * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the [utils.toCollectionName](#utils_exports.toCollectionName) method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._\n *\n * ####Example:\n *\n *     var schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     var collectionName = 'actor'\n *     var M = conn.model('Actor', schema, collectionName)\n *\n * @param {String} name the model name\n * @param {Schema} [schema] a schema. necessary when defining a model\n * @param {String} [collection] name of mongodb collection (optional) if not given it will be induced from model name\n * @see Mongoose#model #index_Mongoose-model\n * @return {Model} The compiled model\n * @api public\n */\n\nConnection.prototype.model = function(name, schema, collection) {\n  // collection name discovery\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n  if (schema && !schema.instanceOfSchema) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  if (this.models[name] && !collection) {\n    // model exists but we are not subclassing with custom collection\n    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {\n      throw new MongooseError.OverwriteModelError(name);\n    }\n    return this.models[name];\n  }\n\n  var opts = {cache: false, connection: this};\n  var model;\n\n  if (schema && schema.instanceOfSchema) {\n    // compile a model\n    model = this.base.model(name, schema, collection, opts);\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    model.init();\n    return model;\n  }\n\n  if (this.models[name] && collection) {\n    // subclassing current model with alternate collection\n    model = this.models[name];\n    schema = model.prototype.schema;\n    var sub = model.__subclass(this, schema, collection);\n    // do not cache the sub model\n    return sub;\n  }\n\n  // lookup model in mongoose module\n  model = this.base.models[name];\n\n  if (!model) {\n    throw new MongooseError.MissingSchemaError(name);\n  }\n\n  if (this === model.prototype.db\n      && (!collection || collection === model.collection.name)) {\n    // model already uses this connection.\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    return model;\n  }\n  this.models[name] = model.__subclass(this, schema, collection);\n  return this.models[name];\n};\n\n/**\n * Returns an array of model names created on this connection.\n * @api public\n * @return {Array}\n */\n\nConnection.prototype.modelNames = function() {\n  return Object.keys(this.models);\n};\n\n/**\n * @brief Returns if the connection requires authentication after it is opened. Generally if a\n * username and password are both provided than authentication is needed, but in some cases a\n * password is not required.\n * @api private\n * @return {Boolean} true if the connection should be authenticated after it is opened, otherwise false.\n */\nConnection.prototype.shouldAuthenticate = function() {\n  return (this.user !== null && this.user !== void 0) &&\n      ((this.pass !== null || this.pass !== void 0) || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * @brief Returns a boolean value that specifies if the current authentication mechanism needs a\n * password to authenticate according to the auth objects passed into the open/openSet methods.\n * @api private\n * @return {Boolean} true if the authentication mechanism specified in the options object requires\n *  a password, otherwise false.\n */\nConnection.prototype.authMechanismDoesNotRequirePassword = function() {\n  if (this.options && this.options.auth) {\n    return authMechanismsWhichDontRequirePassword.indexOf(this.options.auth.authMechanism) >= 0;\n  }\n  return true;\n};\n\n/**\n * @brief Returns a boolean value that specifies if the provided objects object provides enough\n * data to authenticate with. Generally this is true if the username and password are both specified\n * but in some authentication methods, a password is not required for authentication so only a username\n * is required.\n * @param {Object} [options] the options object passed into the open/openSet methods.\n * @api private\n * @return {Boolean} true if the provided options object provides enough data to authenticate with,\n *   otherwise false.\n */\nConnection.prototype.optionsProvideAuthenticationData = function(options) {\n  return (options) &&\n      (options.user) &&\n      ((options.pass) || this.authMechanismDoesNotRequirePassword());\n};\n\n/*!\n * Module exports.\n */\n\nConnection.STATES = STATES;\nmodule.exports = Connection;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/drivers/node-mongodb-native/collection.js":"/*!\n * Module dependencies.\n */\n\nvar MongooseCollection = require('../../collection'),\n    Collection = require('mongodb').Collection,\n    utils = require('../../utils');\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.\n *\n * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.\n *\n * @inherits Collection\n * @api private\n */\n\nfunction NativeCollection() {\n  this.collection = null;\n  MongooseCollection.apply(this, arguments);\n}\n\n/*!\n * Inherit from abstract Collection.\n */\n\nNativeCollection.prototype.__proto__ = MongooseCollection.prototype;\n\n/**\n * Called when the connection opens.\n *\n * @api private\n */\n\nNativeCollection.prototype.onOpen = function() {\n  var _this = this;\n\n  // always get a new collection in case the user changed host:port\n  // of parent db instance when re-opening the connection.\n\n  if (!_this.opts.capped.size) {\n    // non-capped\n    callback(null, _this.conn.db.collection(_this.name));\n    return _this.collection;\n  }\n\n  // capped\n  return _this.conn.db.collection(_this.name, function(err, c) {\n    if (err) return callback(err);\n\n    // discover if this collection exists and if it is capped\n    _this.conn.db.listCollections({name: _this.name}).toArray(function(err, docs) {\n      if (err) {\n        return callback(err);\n      }\n      var doc = docs[0];\n      var exists = !!doc;\n\n      if (exists) {\n        if (doc.options && doc.options.capped) {\n          callback(null, c);\n        } else {\n          var msg = 'A non-capped collection exists with the name: ' + _this.name + '\\n\\n'\n              + ' To use this collection as a capped collection, please '\n              + 'first convert it.\\n'\n              + ' http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-Convertingacollectiontocapped';\n          err = new Error(msg);\n          callback(err);\n        }\n      } else {\n        // create\n        var opts = utils.clone(_this.opts.capped);\n        opts.capped = true;\n        _this.conn.db.createCollection(_this.name, opts, callback);\n      }\n    });\n  });\n\n  function callback(err, collection) {\n    if (err) {\n      // likely a strict mode error\n      _this.conn.emit('error', err);\n    } else {\n      _this.collection = collection;\n      MongooseCollection.prototype.onOpen.call(_this);\n    }\n  }\n};\n\n/**\n * Called when the connection closes\n *\n * @api private\n */\n\nNativeCollection.prototype.onClose = function() {\n  MongooseCollection.prototype.onClose.call(this);\n};\n\n/*!\n * Copy the collection methods and make them subject to queues\n */\n\nfunction iter(i) {\n  NativeCollection.prototype[i] = function() {\n    if (this.buffer) {\n      this.addQueue(i, arguments);\n      return;\n    }\n\n    var collection = this.collection;\n    var args = arguments;\n    var _this = this;\n    var debug = _this.conn.base.options.debug;\n\n    if (debug) {\n      if (typeof debug === 'function') {\n        debug.apply(_this,\n          [_this.name, i].concat(utils.args(args, 0, args.length - 1)));\n      } else {\n        this.$print(_this.name, i, args);\n      }\n    }\n\n    try {\n      return collection[i].apply(collection, args);\n    } catch (error) {\n      // Collection operation may throw because of max bson size, catch it here\n      // See gh-3906\n      if (args.length > 0 &&\n          typeof args[args.length - 1] === 'function') {\n        args[args.length - 1](error);\n      } else {\n        throw error;\n      }\n    }\n  };\n}\n\nfor (var i in Collection.prototype) {\n  // Janky hack to work around gh-3005 until we can get rid of the mongoose\n  // collection abstraction\n  try {\n    if (typeof Collection.prototype[i] !== 'function') {\n      continue;\n    }\n  } catch (e) {\n    continue;\n  }\n\n  iter(i);\n}\n\n/**\n * Debug print helper\n *\n * @api public\n * @method $print\n */\n\nNativeCollection.prototype.$print = function(name, i, args) {\n  var moduleName = '\\x1B[0;36mMongoose:\\x1B[0m ';\n  var functionCall = [name, i].join('.');\n  var _args = [];\n  for (var j = args.length - 1; j >= 0; --j) {\n    if (this.$format(args[j]) || _args.length) {\n      _args.unshift(this.$format(args[j]));\n    }\n  }\n  var params = '(' + _args.join(', ') + ')';\n\n  console.error(moduleName + functionCall + params);\n};\n\n/**\n * Formatter for debug print args\n *\n * @api public\n * @method $format\n */\n\nNativeCollection.prototype.$format = function(arg) {\n  var type = typeof arg;\n  if (type === 'function' || type === 'undefined') return '';\n  return format(arg);\n};\n\n/*!\n * Debug print helper\n */\n\nfunction map(o) {\n  return format(o, true);\n}\nfunction formatObjectId(x, key) {\n  var representation = 'ObjectId(\"' + x[key].toHexString() + '\")';\n  x[key] = {inspect: function() { return representation; }};\n}\nfunction formatDate(x, key) {\n  var representation = 'new Date(\"' + x[key].toUTCString() + '\")';\n  x[key] = {inspect: function() { return representation; }};\n}\nfunction format(obj, sub) {\n  if (obj && typeof obj.toBSON === 'function') {\n    obj = obj.toBSON();\n  }\n  var x = utils.clone(obj, {retainKeyOrder: 1, transform: false});\n  var representation;\n\n  if (x != null) {\n    if (x.constructor.name === 'Binary') {\n      x = 'BinData(' + x.sub_type + ', \"' + x.toString('base64') + '\")';\n    } else if (x.constructor.name === 'ObjectID') {\n      representation = 'ObjectId(\"' + x.toHexString() + '\")';\n      x = {inspect: function() { return representation; }};\n    } else if (x.constructor.name === 'Date') {\n      representation = 'new Date(\"' + x.toUTCString() + '\")';\n      x = {inspect: function() { return representation; }};\n    } else if (x.constructor.name === 'Object') {\n      var keys = Object.keys(x);\n      var numKeys = keys.length;\n      var key;\n      for (var i = 0; i < numKeys; ++i) {\n        key = keys[i];\n        if (x[key]) {\n          if (typeof x[key].toBSON === 'function') {\n            x[key] = x[key].toBSON();\n          }\n          if (x[key].constructor.name === 'Binary') {\n            x[key] = 'BinData(' + x[key].sub_type + ', \"' +\n              x[key].buffer.toString('base64') + '\")';\n          } else if (x[key].constructor.name === 'Object') {\n            x[key] = format(x[key], true);\n          } else if (x[key].constructor.name === 'ObjectID') {\n            formatObjectId(x, key);\n          } else if (x[key].constructor.name === 'Date') {\n            formatDate(x, key);\n          } else if (Array.isArray(x[key])) {\n            x[key] = x[key].map(map);\n          }\n        }\n      }\n    }\n    if (sub) return x;\n  }\n\n  return require('util')\n  .inspect(x, false, 10, true)\n  .replace(/\\n/g, '')\n  .replace(/\\s{2,}/g, ' ');\n}\n\n/**\n * Retreives information about this collections indexes.\n *\n * @param {Function} callback\n * @method getIndexes\n * @api public\n */\n\nNativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeCollection;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/collection.js":"/*!\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar STATES = require('./connectionstate');\n\n/**\n * Abstract Collection constructor\n *\n * This is the base class that drivers inherit from and implement.\n *\n * @param {String} name name of the collection\n * @param {Connection} conn A MongooseConnection instance\n * @param {Object} opts optional collection options\n * @api public\n */\n\nfunction Collection(name, conn, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  if (opts.capped === void 0) {\n    opts.capped = {};\n  }\n\n  opts.bufferCommands = undefined === opts.bufferCommands\n      ? true\n      : opts.bufferCommands;\n\n  if (typeof opts.capped === 'number') {\n    opts.capped = {size: opts.capped};\n  }\n\n  this.opts = opts;\n  this.name = name;\n  this.collectionName = name;\n  this.conn = conn;\n  this.queue = [];\n  this.buffer = this.opts.bufferCommands;\n  this.emitter = new EventEmitter();\n\n  if (STATES.connected === this.conn.readyState) {\n    this.onOpen();\n  }\n}\n\n/**\n * The collection name\n *\n * @api public\n * @property name\n */\n\nCollection.prototype.name;\n\n/**\n * The collection name\n *\n * @api public\n * @property collectionName\n */\n\nCollection.prototype.collectionName;\n\n/**\n * The Connection instance\n *\n * @api public\n * @property conn\n */\n\nCollection.prototype.conn;\n\n/**\n * Called when the database connects\n *\n * @api private\n */\n\nCollection.prototype.onOpen = function() {\n  this.buffer = false;\n  this.doQueue();\n};\n\n/**\n * Called when the database disconnects\n *\n * @api private\n */\n\nCollection.prototype.onClose = function() {\n  if (this.opts.bufferCommands) {\n    this.buffer = true;\n  }\n};\n\n/**\n * Queues a method for later execution when its\n * database connection opens.\n *\n * @param {String} name name of the method to queue\n * @param {Array} args arguments to pass to the method when executed\n * @api private\n */\n\nCollection.prototype.addQueue = function(name, args) {\n  this.queue.push([name, args]);\n  return this;\n};\n\n/**\n * Executes all queued methods and clears the queue.\n *\n * @api private\n */\n\nCollection.prototype.doQueue = function() {\n  for (var i = 0, l = this.queue.length; i < l; i++) {\n    if (typeof this.queue[i][0] === 'function') {\n      this.queue[i][0].apply(this, this.queue[i][1]);\n    } else {\n      this[this.queue[i][0]].apply(this, this.queue[i][1]);\n    }\n  }\n  this.queue = [];\n  var _this = this;\n  process.nextTick(function() {\n    _this.emitter.emit('queue');\n  });\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.ensureIndex = function() {\n  throw new Error('Collection#ensureIndex unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findAndModify = function() {\n  throw new Error('Collection#findAndModify unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOne = function() {\n  throw new Error('Collection#findOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.find = function() {\n  throw new Error('Collection#find unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insert = function() {\n  throw new Error('Collection#insert unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.save = function() {\n  throw new Error('Collection#save unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.update = function() {\n  throw new Error('Collection#update unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.getIndexes = function() {\n  throw new Error('Collection#getIndexes unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.mapReduce = function() {\n  throw new Error('Collection#mapReduce unimplemented by driver');\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Collection;\n","/home/travis/build/npmtest/node-npmtest-mongoose/mongoose/lib/error/disconnected.js":"/*!\n * Module dependencies.\n */\n\nvar MongooseError = require('../error.js');\n\n/**\n * Casting Error constructor.\n *\n * @param {String} type\n * @param {String} value\n * @inherits MongooseError\n * @api private\n */\n\nfunction DisconnectedError(connectionString) {\n  MongooseError.call(this, 'Ran out of retries trying to reconnect to \"' +\n    connectionString + '\". Try setting `server.reconnectTries` and ' +\n    '`server.reconnectInterval` to something higher.');\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.name = 'DisconnectedError';\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nDisconnectedError.prototype = Object.create(MongooseError.prototype);\nDisconnectedError.prototype.constructor = MongooseError;\n\n\n/*!\n * exports\n */\n\nmodule.exports = DisconnectedError;\n"}